<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="generator" content="Asciidoctor 2.0.22">
<title>Все лекции по сетям</title>
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:300,300italic,400,400italic,600,600italic%7CNoto+Serif:400,400italic,700,700italic%7CDroid+Sans+Mono:400,700">
<style>
/*! Asciidoctor default stylesheet | MIT License | https://asciidoctor.org */
/* Uncomment the following line when using as a custom stylesheet */
/* @import "https://fonts.googleapis.com/css?family=Open+Sans:300,300italic,400,400italic,600,600italic%7CNoto+Serif:400,400italic,700,700italic%7CDroid+Sans+Mono:400,700"; */
html{font-family:sans-serif;-webkit-text-size-adjust:100%}
a{background:none}
a:focus{outline:thin dotted}
a:active,a:hover{outline:0}
h1{font-size:2em;margin:.67em 0}
b,strong{font-weight:bold}
abbr{font-size:.9em}
abbr[title]{cursor:help;border-bottom:1px dotted #dddddf;text-decoration:none}
dfn{font-style:italic}
hr{height:0}
mark{background:#ff0;color:#000}
code,kbd,pre,samp{font-family:monospace;font-size:1em}
pre{white-space:pre-wrap}
q{quotes:"\201C" "\201D" "\2018" "\2019"}
small{font-size:80%}
sub,sup{font-size:75%;line-height:0;position:relative;vertical-align:baseline}
sup{top:-.5em}
sub{bottom:-.25em}
img{border:0}
svg:not(:root){overflow:hidden}
figure{margin:0}
audio,video{display:inline-block}
audio:not([controls]){display:none;height:0}
fieldset{border:1px solid silver;margin:0 2px;padding:.35em .625em .75em}
legend{border:0;padding:0}
button,input,select,textarea{font-family:inherit;font-size:100%;margin:0}
button,input{line-height:normal}
button,select{text-transform:none}
button,html input[type=button],input[type=reset],input[type=submit]{-webkit-appearance:button;cursor:pointer}
button[disabled],html input[disabled]{cursor:default}
input[type=checkbox],input[type=radio]{padding:0}
button::-moz-focus-inner,input::-moz-focus-inner{border:0;padding:0}
textarea{overflow:auto;vertical-align:top}
table{border-collapse:collapse;border-spacing:0}
*,::before,::after{box-sizing:border-box}
html,body{font-size:100%}
body{background:#fff;color:rgba(0,0,0,.8);padding:0;margin:0;font-family:"Noto Serif","DejaVu Serif",serif;line-height:1;position:relative;cursor:auto;-moz-tab-size:4;-o-tab-size:4;tab-size:4;word-wrap:anywhere;-moz-osx-font-smoothing:grayscale;-webkit-font-smoothing:antialiased}
a:hover{cursor:pointer}
img,object,embed{max-width:100%;height:auto}
object,embed{height:100%}
img{-ms-interpolation-mode:bicubic}
.left{float:left!important}
.right{float:right!important}
.text-left{text-align:left!important}
.text-right{text-align:right!important}
.text-center{text-align:center!important}
.text-justify{text-align:justify!important}
.hide{display:none}
img,object,svg{display:inline-block;vertical-align:middle}
textarea{height:auto;min-height:50px}
select{width:100%}
.subheader,.admonitionblock td.content>.title,.audioblock>.title,.exampleblock>.title,.imageblock>.title,.listingblock>.title,.literalblock>.title,.stemblock>.title,.openblock>.title,.paragraph>.title,.quoteblock>.title,table.tableblock>.title,.verseblock>.title,.videoblock>.title,.dlist>.title,.olist>.title,.ulist>.title,.qlist>.title,.hdlist>.title{line-height:1.45;color:#7a2518;font-weight:400;margin-top:0;margin-bottom:.25em}
div,dl,dt,dd,ul,ol,li,h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6,pre,form,p,blockquote,th,td{margin:0;padding:0}
a{color:#2156a5;text-decoration:underline;line-height:inherit}
a:hover,a:focus{color:#1d4b8f}
a img{border:0}
p{line-height:1.6;margin-bottom:1.25em;text-rendering:optimizeLegibility}
p aside{font-size:.875em;line-height:1.35;font-style:italic}
h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6{font-family:"Open Sans","DejaVu Sans",sans-serif;font-weight:300;font-style:normal;color:#ba3925;text-rendering:optimizeLegibility;margin-top:1em;margin-bottom:.5em;line-height:1.0125em}
h1 small,h2 small,h3 small,#toctitle small,.sidebarblock>.content>.title small,h4 small,h5 small,h6 small{font-size:60%;color:#e99b8f;line-height:0}
h1{font-size:2.125em}
h2{font-size:1.6875em}
h3,#toctitle,.sidebarblock>.content>.title{font-size:1.375em}
h4,h5{font-size:1.125em}
h6{font-size:1em}
hr{border:solid #dddddf;border-width:1px 0 0;clear:both;margin:1.25em 0 1.1875em}
em,i{font-style:italic;line-height:inherit}
strong,b{font-weight:bold;line-height:inherit}
small{font-size:60%;line-height:inherit}
code{font-family:"Droid Sans Mono","DejaVu Sans Mono",monospace;font-weight:400;color:rgba(0,0,0,.9)}
ul,ol,dl{line-height:1.6;margin-bottom:1.25em;list-style-position:outside;font-family:inherit}
ul,ol{margin-left:1.5em}
ul li ul,ul li ol{margin-left:1.25em;margin-bottom:0}
ul.circle{list-style-type:circle}
ul.disc{list-style-type:disc}
ul.square{list-style-type:square}
ul.circle ul:not([class]),ul.disc ul:not([class]),ul.square ul:not([class]){list-style:inherit}
ol li ul,ol li ol{margin-left:1.25em;margin-bottom:0}
dl dt{margin-bottom:.3125em;font-weight:bold}
dl dd{margin-bottom:1.25em}
blockquote{margin:0 0 1.25em;padding:.5625em 1.25em 0 1.1875em;border-left:1px solid #ddd}
blockquote,blockquote p{line-height:1.6;color:rgba(0,0,0,.85)}
@media screen and (min-width:768px){h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6{line-height:1.2}
h1{font-size:2.75em}
h2{font-size:2.3125em}
h3,#toctitle,.sidebarblock>.content>.title{font-size:1.6875em}
h4{font-size:1.4375em}}
table{background:#fff;margin-bottom:1.25em;border:1px solid #dedede;word-wrap:normal}
table thead,table tfoot{background:#f7f8f7}
table thead tr th,table thead tr td,table tfoot tr th,table tfoot tr td{padding:.5em .625em .625em;font-size:inherit;color:rgba(0,0,0,.8);text-align:left}
table tr th,table tr td{padding:.5625em .625em;font-size:inherit;color:rgba(0,0,0,.8)}
table tr.even,table tr.alt{background:#f8f8f7}
table thead tr th,table tfoot tr th,table tbody tr td,table tr td,table tfoot tr td{line-height:1.6}
h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6{line-height:1.2;word-spacing:-.05em}
h1 strong,h2 strong,h3 strong,#toctitle strong,.sidebarblock>.content>.title strong,h4 strong,h5 strong,h6 strong{font-weight:400}
.center{margin-left:auto;margin-right:auto}
.stretch{width:100%}
.clearfix::before,.clearfix::after,.float-group::before,.float-group::after{content:" ";display:table}
.clearfix::after,.float-group::after{clear:both}
:not(pre).nobreak{word-wrap:normal}
:not(pre).nowrap{white-space:nowrap}
:not(pre).pre-wrap{white-space:pre-wrap}
:not(pre):not([class^=L])>code{font-size:.9375em;font-style:normal!important;letter-spacing:0;padding:.1em .5ex;word-spacing:-.15em;background:#f7f7f8;border-radius:4px;line-height:1.45;text-rendering:optimizeSpeed}
pre{color:rgba(0,0,0,.9);font-family:"Droid Sans Mono","DejaVu Sans Mono",monospace;line-height:1.45;text-rendering:optimizeSpeed}
pre code,pre pre{color:inherit;font-size:inherit;line-height:inherit}
pre>code{display:block}
pre.nowrap,pre.nowrap pre{white-space:pre;word-wrap:normal}
em em{font-style:normal}
strong strong{font-weight:400}
.keyseq{color:rgba(51,51,51,.8)}
kbd{font-family:"Droid Sans Mono","DejaVu Sans Mono",monospace;display:inline-block;color:rgba(0,0,0,.8);font-size:.65em;line-height:1.45;background:#f7f7f7;border:1px solid #ccc;border-radius:3px;box-shadow:0 1px 0 rgba(0,0,0,.2),inset 0 0 0 .1em #fff;margin:0 .15em;padding:.2em .5em;vertical-align:middle;position:relative;top:-.1em;white-space:nowrap}
.keyseq kbd:first-child{margin-left:0}
.keyseq kbd:last-child{margin-right:0}
.menuseq,.menuref{color:#000}
.menuseq b:not(.caret),.menuref{font-weight:inherit}
.menuseq{word-spacing:-.02em}
.menuseq b.caret{font-size:1.25em;line-height:.8}
.menuseq i.caret{font-weight:bold;text-align:center;width:.45em}
b.button::before,b.button::after{position:relative;top:-1px;font-weight:400}
b.button::before{content:"[";padding:0 3px 0 2px}
b.button::after{content:"]";padding:0 2px 0 3px}
p a>code:hover{color:rgba(0,0,0,.9)}
#header,#content,#footnotes,#footer{width:100%;margin:0 auto;max-width:62.5em;*zoom:1;position:relative;padding-left:.9375em;padding-right:.9375em}
#header::before,#header::after,#content::before,#content::after,#footnotes::before,#footnotes::after,#footer::before,#footer::after{content:" ";display:table}
#header::after,#content::after,#footnotes::after,#footer::after{clear:both}
#content{margin-top:1.25em}
#content::before{content:none}
#header>h1:first-child{color:rgba(0,0,0,.85);margin-top:2.25rem;margin-bottom:0}
#header>h1:first-child+#toc{margin-top:8px;border-top:1px solid #dddddf}
#header>h1:only-child{border-bottom:1px solid #dddddf;padding-bottom:8px}
#header .details{border-bottom:1px solid #dddddf;line-height:1.45;padding-top:.25em;padding-bottom:.25em;padding-left:.25em;color:rgba(0,0,0,.6);display:flex;flex-flow:row wrap}
#header .details span:first-child{margin-left:-.125em}
#header .details span.email a{color:rgba(0,0,0,.85)}
#header .details br{display:none}
#header .details br+span::before{content:"\00a0\2013\00a0"}
#header .details br+span.author::before{content:"\00a0\22c5\00a0";color:rgba(0,0,0,.85)}
#header .details br+span#revremark::before{content:"\00a0|\00a0"}
#header #revnumber{text-transform:capitalize}
#header #revnumber::after{content:"\00a0"}
#content>h1:first-child:not([class]){color:rgba(0,0,0,.85);border-bottom:1px solid #dddddf;padding-bottom:8px;margin-top:0;padding-top:1rem;margin-bottom:1.25rem}
#toc{border-bottom:1px solid #e7e7e9;padding-bottom:.5em}
#toc>ul{margin-left:.125em}
#toc ul.sectlevel0>li>a{font-style:italic}
#toc ul.sectlevel0 ul.sectlevel1{margin:.5em 0}
#toc ul{font-family:"Open Sans","DejaVu Sans",sans-serif;list-style-type:none}
#toc li{line-height:1.3334;margin-top:.3334em}
#toc a{text-decoration:none}
#toc a:active{text-decoration:underline}
#toctitle{color:#7a2518;font-size:1.2em}
@media screen and (min-width:768px){#toctitle{font-size:1.375em}
body.toc2{padding-left:15em;padding-right:0}
body.toc2 #header>h1:nth-last-child(2){border-bottom:1px solid #dddddf;padding-bottom:8px}
#toc.toc2{margin-top:0!important;background:#f8f8f7;position:fixed;width:15em;left:0;top:0;border-right:1px solid #e7e7e9;border-top-width:0!important;border-bottom-width:0!important;z-index:1000;padding:1.25em 1em;height:100%;overflow:auto}
#toc.toc2 #toctitle{margin-top:0;margin-bottom:.8rem;font-size:1.2em}
#toc.toc2>ul{font-size:.9em;margin-bottom:0}
#toc.toc2 ul ul{margin-left:0;padding-left:1em}
#toc.toc2 ul.sectlevel0 ul.sectlevel1{padding-left:0;margin-top:.5em;margin-bottom:.5em}
body.toc2.toc-right{padding-left:0;padding-right:15em}
body.toc2.toc-right #toc.toc2{border-right-width:0;border-left:1px solid #e7e7e9;left:auto;right:0}}
@media screen and (min-width:1280px){body.toc2{padding-left:20em;padding-right:0}
#toc.toc2{width:20em}
#toc.toc2 #toctitle{font-size:1.375em}
#toc.toc2>ul{font-size:.95em}
#toc.toc2 ul ul{padding-left:1.25em}
body.toc2.toc-right{padding-left:0;padding-right:20em}}
#content #toc{border:1px solid #e0e0dc;margin-bottom:1.25em;padding:1.25em;background:#f8f8f7;border-radius:4px}
#content #toc>:first-child{margin-top:0}
#content #toc>:last-child{margin-bottom:0}
#footer{max-width:none;background:rgba(0,0,0,.8);padding:1.25em}
#footer-text{color:hsla(0,0%,100%,.8);line-height:1.44}
#content{margin-bottom:.625em}
.sect1{padding-bottom:.625em}
@media screen and (min-width:768px){#content{margin-bottom:1.25em}
.sect1{padding-bottom:1.25em}}
.sect1:last-child{padding-bottom:0}
.sect1+.sect1{border-top:1px solid #e7e7e9}
#content h1>a.anchor,h2>a.anchor,h3>a.anchor,#toctitle>a.anchor,.sidebarblock>.content>.title>a.anchor,h4>a.anchor,h5>a.anchor,h6>a.anchor{position:absolute;z-index:1001;width:1.5ex;margin-left:-1.5ex;display:block;text-decoration:none!important;visibility:hidden;text-align:center;font-weight:400}
#content h1>a.anchor::before,h2>a.anchor::before,h3>a.anchor::before,#toctitle>a.anchor::before,.sidebarblock>.content>.title>a.anchor::before,h4>a.anchor::before,h5>a.anchor::before,h6>a.anchor::before{content:"\00A7";font-size:.85em;display:block;padding-top:.1em}
#content h1:hover>a.anchor,#content h1>a.anchor:hover,h2:hover>a.anchor,h2>a.anchor:hover,h3:hover>a.anchor,#toctitle:hover>a.anchor,.sidebarblock>.content>.title:hover>a.anchor,h3>a.anchor:hover,#toctitle>a.anchor:hover,.sidebarblock>.content>.title>a.anchor:hover,h4:hover>a.anchor,h4>a.anchor:hover,h5:hover>a.anchor,h5>a.anchor:hover,h6:hover>a.anchor,h6>a.anchor:hover{visibility:visible}
#content h1>a.link,h2>a.link,h3>a.link,#toctitle>a.link,.sidebarblock>.content>.title>a.link,h4>a.link,h5>a.link,h6>a.link{color:#ba3925;text-decoration:none}
#content h1>a.link:hover,h2>a.link:hover,h3>a.link:hover,#toctitle>a.link:hover,.sidebarblock>.content>.title>a.link:hover,h4>a.link:hover,h5>a.link:hover,h6>a.link:hover{color:#a53221}
details,.audioblock,.imageblock,.literalblock,.listingblock,.stemblock,.videoblock{margin-bottom:1.25em}
details{margin-left:1.25rem}
details>summary{cursor:pointer;display:block;position:relative;line-height:1.6;margin-bottom:.625rem;outline:none;-webkit-tap-highlight-color:transparent}
details>summary::-webkit-details-marker{display:none}
details>summary::before{content:"";border:solid transparent;border-left:solid;border-width:.3em 0 .3em .5em;position:absolute;top:.5em;left:-1.25rem;transform:translateX(15%)}
details[open]>summary::before{border:solid transparent;border-top:solid;border-width:.5em .3em 0;transform:translateY(15%)}
details>summary::after{content:"";width:1.25rem;height:1em;position:absolute;top:.3em;left:-1.25rem}
.admonitionblock td.content>.title,.audioblock>.title,.exampleblock>.title,.imageblock>.title,.listingblock>.title,.literalblock>.title,.stemblock>.title,.openblock>.title,.paragraph>.title,.quoteblock>.title,table.tableblock>.title,.verseblock>.title,.videoblock>.title,.dlist>.title,.olist>.title,.ulist>.title,.qlist>.title,.hdlist>.title{text-rendering:optimizeLegibility;text-align:left;font-family:"Noto Serif","DejaVu Serif",serif;font-size:1rem;font-style:italic}
table.tableblock.fit-content>caption.title{white-space:nowrap;width:0}
.paragraph.lead>p,#preamble>.sectionbody>[class=paragraph]:first-of-type p{font-size:1.21875em;line-height:1.6;color:rgba(0,0,0,.85)}
.admonitionblock>table{border-collapse:separate;border:0;background:none;width:100%}
.admonitionblock>table td.icon{text-align:center;width:80px}
.admonitionblock>table td.icon img{max-width:none}
.admonitionblock>table td.icon .title{font-weight:bold;font-family:"Open Sans","DejaVu Sans",sans-serif;text-transform:uppercase}
.admonitionblock>table td.content{padding-left:1.125em;padding-right:1.25em;border-left:1px solid #dddddf;color:rgba(0,0,0,.6);word-wrap:anywhere}
.admonitionblock>table td.content>:last-child>:last-child{margin-bottom:0}
.exampleblock>.content{border:1px solid #e6e6e6;margin-bottom:1.25em;padding:1.25em;background:#fff;border-radius:4px}
.sidebarblock{border:1px solid #dbdbd6;margin-bottom:1.25em;padding:1.25em;background:#f3f3f2;border-radius:4px}
.sidebarblock>.content>.title{color:#7a2518;margin-top:0;text-align:center}
.exampleblock>.content>:first-child,.sidebarblock>.content>:first-child{margin-top:0}
.exampleblock>.content>:last-child,.exampleblock>.content>:last-child>:last-child,.exampleblock>.content .olist>ol>li:last-child>:last-child,.exampleblock>.content .ulist>ul>li:last-child>:last-child,.exampleblock>.content .qlist>ol>li:last-child>:last-child,.sidebarblock>.content>:last-child,.sidebarblock>.content>:last-child>:last-child,.sidebarblock>.content .olist>ol>li:last-child>:last-child,.sidebarblock>.content .ulist>ul>li:last-child>:last-child,.sidebarblock>.content .qlist>ol>li:last-child>:last-child{margin-bottom:0}
.literalblock pre,.listingblock>.content>pre{border-radius:4px;overflow-x:auto;padding:1em;font-size:.8125em}
@media screen and (min-width:768px){.literalblock pre,.listingblock>.content>pre{font-size:.90625em}}
@media screen and (min-width:1280px){.literalblock pre,.listingblock>.content>pre{font-size:1em}}
.literalblock pre,.listingblock>.content>pre:not(.highlight),.listingblock>.content>pre[class=highlight],.listingblock>.content>pre[class^="highlight "]{background:#f7f7f8}
.literalblock.output pre{color:#f7f7f8;background:rgba(0,0,0,.9)}
.listingblock>.content{position:relative}
.listingblock code[data-lang]::before{display:none;content:attr(data-lang);position:absolute;font-size:.75em;top:.425rem;right:.5rem;line-height:1;text-transform:uppercase;color:inherit;opacity:.5}
.listingblock:hover code[data-lang]::before{display:block}
.listingblock.terminal pre .command::before{content:attr(data-prompt);padding-right:.5em;color:inherit;opacity:.5}
.listingblock.terminal pre .command:not([data-prompt])::before{content:"$"}
.listingblock pre.highlightjs{padding:0}
.listingblock pre.highlightjs>code{padding:1em;border-radius:4px}
.listingblock pre.prettyprint{border-width:0}
.prettyprint{background:#f7f7f8}
pre.prettyprint .linenums{line-height:1.45;margin-left:2em}
pre.prettyprint li{background:none;list-style-type:inherit;padding-left:0}
pre.prettyprint li code[data-lang]::before{opacity:1}
pre.prettyprint li:not(:first-child) code[data-lang]::before{display:none}
table.linenotable{border-collapse:separate;border:0;margin-bottom:0;background:none}
table.linenotable td[class]{color:inherit;vertical-align:top;padding:0;line-height:inherit;white-space:normal}
table.linenotable td.code{padding-left:.75em}
table.linenotable td.linenos,pre.pygments .linenos{border-right:1px solid;opacity:.35;padding-right:.5em;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}
pre.pygments span.linenos{display:inline-block;margin-right:.75em}
.quoteblock{margin:0 1em 1.25em 1.5em;display:table}
.quoteblock:not(.excerpt)>.title{margin-left:-1.5em;margin-bottom:.75em}
.quoteblock blockquote,.quoteblock p{color:rgba(0,0,0,.85);font-size:1.15rem;line-height:1.75;word-spacing:.1em;letter-spacing:0;font-style:italic;text-align:justify}
.quoteblock blockquote{margin:0;padding:0;border:0}
.quoteblock blockquote::before{content:"\201c";float:left;font-size:2.75em;font-weight:bold;line-height:.6em;margin-left:-.6em;color:#7a2518;text-shadow:0 1px 2px rgba(0,0,0,.1)}
.quoteblock blockquote>.paragraph:last-child p{margin-bottom:0}
.quoteblock .attribution{margin-top:.75em;margin-right:.5ex;text-align:right}
.verseblock{margin:0 1em 1.25em}
.verseblock pre{font-family:"Open Sans","DejaVu Sans",sans-serif;font-size:1.15rem;color:rgba(0,0,0,.85);font-weight:300;text-rendering:optimizeLegibility}
.verseblock pre strong{font-weight:400}
.verseblock .attribution{margin-top:1.25rem;margin-left:.5ex}
.quoteblock .attribution,.verseblock .attribution{font-size:.9375em;line-height:1.45;font-style:italic}
.quoteblock .attribution br,.verseblock .attribution br{display:none}
.quoteblock .attribution cite,.verseblock .attribution cite{display:block;letter-spacing:-.025em;color:rgba(0,0,0,.6)}
.quoteblock.abstract blockquote::before,.quoteblock.excerpt blockquote::before,.quoteblock .quoteblock blockquote::before{display:none}
.quoteblock.abstract blockquote,.quoteblock.abstract p,.quoteblock.excerpt blockquote,.quoteblock.excerpt p,.quoteblock .quoteblock blockquote,.quoteblock .quoteblock p{line-height:1.6;word-spacing:0}
.quoteblock.abstract{margin:0 1em 1.25em;display:block}
.quoteblock.abstract>.title{margin:0 0 .375em;font-size:1.15em;text-align:center}
.quoteblock.excerpt>blockquote,.quoteblock .quoteblock{padding:0 0 .25em 1em;border-left:.25em solid #dddddf}
.quoteblock.excerpt,.quoteblock .quoteblock{margin-left:0}
.quoteblock.excerpt blockquote,.quoteblock.excerpt p,.quoteblock .quoteblock blockquote,.quoteblock .quoteblock p{color:inherit;font-size:1.0625rem}
.quoteblock.excerpt .attribution,.quoteblock .quoteblock .attribution{color:inherit;font-size:.85rem;text-align:left;margin-right:0}
p.tableblock:last-child{margin-bottom:0}
td.tableblock>.content{margin-bottom:1.25em;word-wrap:anywhere}
td.tableblock>.content>:last-child{margin-bottom:-1.25em}
table.tableblock,th.tableblock,td.tableblock{border:0 solid #dedede}
table.grid-all>*>tr>*{border-width:1px}
table.grid-cols>*>tr>*{border-width:0 1px}
table.grid-rows>*>tr>*{border-width:1px 0}
table.frame-all{border-width:1px}
table.frame-ends{border-width:1px 0}
table.frame-sides{border-width:0 1px}
table.frame-none>colgroup+*>:first-child>*,table.frame-sides>colgroup+*>:first-child>*{border-top-width:0}
table.frame-none>:last-child>:last-child>*,table.frame-sides>:last-child>:last-child>*{border-bottom-width:0}
table.frame-none>*>tr>:first-child,table.frame-ends>*>tr>:first-child{border-left-width:0}
table.frame-none>*>tr>:last-child,table.frame-ends>*>tr>:last-child{border-right-width:0}
table.stripes-all>*>tr,table.stripes-odd>*>tr:nth-of-type(odd),table.stripes-even>*>tr:nth-of-type(even),table.stripes-hover>*>tr:hover{background:#f8f8f7}
th.halign-left,td.halign-left{text-align:left}
th.halign-right,td.halign-right{text-align:right}
th.halign-center,td.halign-center{text-align:center}
th.valign-top,td.valign-top{vertical-align:top}
th.valign-bottom,td.valign-bottom{vertical-align:bottom}
th.valign-middle,td.valign-middle{vertical-align:middle}
table thead th,table tfoot th{font-weight:bold}
tbody tr th{background:#f7f8f7}
tbody tr th,tbody tr th p,tfoot tr th,tfoot tr th p{color:rgba(0,0,0,.8);font-weight:bold}
p.tableblock>code:only-child{background:none;padding:0}
p.tableblock{font-size:1em}
ol{margin-left:1.75em}
ul li ol{margin-left:1.5em}
dl dd{margin-left:1.125em}
dl dd:last-child,dl dd:last-child>:last-child{margin-bottom:0}
li p,ul dd,ol dd,.olist .olist,.ulist .ulist,.ulist .olist,.olist .ulist{margin-bottom:.625em}
ul.checklist,ul.none,ol.none,ul.no-bullet,ol.no-bullet,ol.unnumbered,ul.unstyled,ol.unstyled{list-style-type:none}
ul.no-bullet,ol.no-bullet,ol.unnumbered{margin-left:.625em}
ul.unstyled,ol.unstyled{margin-left:0}
li>p:empty:only-child::before{content:"";display:inline-block}
ul.checklist>li>p:first-child{margin-left:-1em}
ul.checklist>li>p:first-child>.fa-square-o:first-child,ul.checklist>li>p:first-child>.fa-check-square-o:first-child{width:1.25em;font-size:.8em;position:relative;bottom:.125em}
ul.checklist>li>p:first-child>input[type=checkbox]:first-child{margin-right:.25em}
ul.inline{display:flex;flex-flow:row wrap;list-style:none;margin:0 0 .625em -1.25em}
ul.inline>li{margin-left:1.25em}
.unstyled dl dt{font-weight:400;font-style:normal}
ol.arabic{list-style-type:decimal}
ol.decimal{list-style-type:decimal-leading-zero}
ol.loweralpha{list-style-type:lower-alpha}
ol.upperalpha{list-style-type:upper-alpha}
ol.lowerroman{list-style-type:lower-roman}
ol.upperroman{list-style-type:upper-roman}
ol.lowergreek{list-style-type:lower-greek}
.hdlist>table,.colist>table{border:0;background:none}
.hdlist>table>tbody>tr,.colist>table>tbody>tr{background:none}
td.hdlist1,td.hdlist2{vertical-align:top;padding:0 .625em}
td.hdlist1{font-weight:bold;padding-bottom:1.25em}
td.hdlist2{word-wrap:anywhere}
.literalblock+.colist,.listingblock+.colist{margin-top:-.5em}
.colist td:not([class]):first-child{padding:.4em .75em 0;line-height:1;vertical-align:top}
.colist td:not([class]):first-child img{max-width:none}
.colist td:not([class]):last-child{padding:.25em 0}
.thumb,.th{line-height:0;display:inline-block;border:4px solid #fff;box-shadow:0 0 0 1px #ddd}
.imageblock.left{margin:.25em .625em 1.25em 0}
.imageblock.right{margin:.25em 0 1.25em .625em}
.imageblock>.title{margin-bottom:0}
.imageblock.thumb,.imageblock.th{border-width:6px}
.imageblock.thumb>.title,.imageblock.th>.title{padding:0 .125em}
.image.left,.image.right{margin-top:.25em;margin-bottom:.25em;display:inline-block;line-height:0}
.image.left{margin-right:.625em}
.image.right{margin-left:.625em}
a.image{text-decoration:none;display:inline-block}
a.image object{pointer-events:none}
sup.footnote,sup.footnoteref{font-size:.875em;position:static;vertical-align:super}
sup.footnote a,sup.footnoteref a{text-decoration:none}
sup.footnote a:active,sup.footnoteref a:active,#footnotes .footnote a:first-of-type:active{text-decoration:underline}
#footnotes{padding-top:.75em;padding-bottom:.75em;margin-bottom:.625em}
#footnotes hr{width:20%;min-width:6.25em;margin:-.25em 0 .75em;border-width:1px 0 0}
#footnotes .footnote{padding:0 .375em 0 .225em;line-height:1.3334;font-size:.875em;margin-left:1.2em;margin-bottom:.2em}
#footnotes .footnote a:first-of-type{font-weight:bold;text-decoration:none;margin-left:-1.05em}
#footnotes .footnote:last-of-type{margin-bottom:0}
#content #footnotes{margin-top:-.625em;margin-bottom:0;padding:.75em 0}
div.unbreakable{page-break-inside:avoid}
.big{font-size:larger}
.small{font-size:smaller}
.underline{text-decoration:underline}
.overline{text-decoration:overline}
.line-through{text-decoration:line-through}
.aqua{color:#00bfbf}
.aqua-background{background:#00fafa}
.black{color:#000}
.black-background{background:#000}
.blue{color:#0000bf}
.blue-background{background:#0000fa}
.fuchsia{color:#bf00bf}
.fuchsia-background{background:#fa00fa}
.gray{color:#606060}
.gray-background{background:#7d7d7d}
.green{color:#006000}
.green-background{background:#007d00}
.lime{color:#00bf00}
.lime-background{background:#00fa00}
.maroon{color:#600000}
.maroon-background{background:#7d0000}
.navy{color:#000060}
.navy-background{background:#00007d}
.olive{color:#606000}
.olive-background{background:#7d7d00}
.purple{color:#600060}
.purple-background{background:#7d007d}
.red{color:#bf0000}
.red-background{background:#fa0000}
.silver{color:#909090}
.silver-background{background:#bcbcbc}
.teal{color:#006060}
.teal-background{background:#007d7d}
.white{color:#bfbfbf}
.white-background{background:#fafafa}
.yellow{color:#bfbf00}
.yellow-background{background:#fafa00}
span.icon>.fa{cursor:default}
a span.icon>.fa{cursor:inherit}
.admonitionblock td.icon [class^="fa icon-"]{font-size:2.5em;text-shadow:1px 1px 2px rgba(0,0,0,.5);cursor:default}
.admonitionblock td.icon .icon-note::before{content:"\f05a";color:#19407c}
.admonitionblock td.icon .icon-tip::before{content:"\f0eb";text-shadow:1px 1px 2px rgba(155,155,0,.8);color:#111}
.admonitionblock td.icon .icon-warning::before{content:"\f071";color:#bf6900}
.admonitionblock td.icon .icon-caution::before{content:"\f06d";color:#bf3400}
.admonitionblock td.icon .icon-important::before{content:"\f06a";color:#bf0000}
.conum[data-value]{display:inline-block;color:#fff!important;background:rgba(0,0,0,.8);border-radius:50%;text-align:center;font-size:.75em;width:1.67em;height:1.67em;line-height:1.67em;font-family:"Open Sans","DejaVu Sans",sans-serif;font-style:normal;font-weight:bold}
.conum[data-value] *{color:#fff!important}
.conum[data-value]+b{display:none}
.conum[data-value]::after{content:attr(data-value)}
pre .conum[data-value]{position:relative;top:-.125em}
b.conum *{color:inherit!important}
.conum:not([data-value]):empty{display:none}
dt,th.tableblock,td.content,div.footnote{text-rendering:optimizeLegibility}
h1,h2,p,td.content,span.alt,summary{letter-spacing:-.01em}
p strong,td.content strong,div.footnote strong{letter-spacing:-.005em}
p,blockquote,dt,td.content,td.hdlist1,span.alt,summary{font-size:1.0625rem}
p{margin-bottom:1.25rem}
.sidebarblock p,.sidebarblock dt,.sidebarblock td.content,p.tableblock{font-size:1em}
.exampleblock>.content{background:#fffef7;border-color:#e0e0dc;box-shadow:0 1px 4px #e0e0dc}
.print-only{display:none!important}
@page{margin:1.25cm .75cm}
@media print{*{box-shadow:none!important;text-shadow:none!important}
html{font-size:80%}
a{color:inherit!important;text-decoration:underline!important}
a.bare,a[href^="#"],a[href^="mailto:"]{text-decoration:none!important}
a[href^="http:"]:not(.bare)::after,a[href^="https:"]:not(.bare)::after{content:"(" attr(href) ")";display:inline-block;font-size:.875em;padding-left:.25em}
abbr[title]{border-bottom:1px dotted}
abbr[title]::after{content:" (" attr(title) ")"}
pre,blockquote,tr,img,object,svg{page-break-inside:avoid}
thead{display:table-header-group}
svg{max-width:100%}
p,blockquote,dt,td.content{font-size:1em;orphans:3;widows:3}
h2,h3,#toctitle,.sidebarblock>.content>.title{page-break-after:avoid}
#header,#content,#footnotes,#footer{max-width:none}
#toc,.sidebarblock,.exampleblock>.content{background:none!important}
#toc{border-bottom:1px solid #dddddf!important;padding-bottom:0!important}
body.book #header{text-align:center}
body.book #header>h1:first-child{border:0!important;margin:2.5em 0 1em}
body.book #header .details{border:0!important;display:block;padding:0!important}
body.book #header .details span:first-child{margin-left:0!important}
body.book #header .details br{display:block}
body.book #header .details br+span::before{content:none!important}
body.book #toc{border:0!important;text-align:left!important;padding:0!important;margin:0!important}
body.book #toc,body.book #preamble,body.book h1.sect0,body.book .sect1>h2{page-break-before:always}
.listingblock code[data-lang]::before{display:block}
#footer{padding:0 .9375em}
.hide-on-print{display:none!important}
.print-only{display:block!important}
.hide-for-print{display:none!important}
.show-for-print{display:inherit!important}}
@media amzn-kf8,print{#header>h1:first-child{margin-top:1.25rem}
.sect1{padding:0!important}
.sect1+.sect1{border:0}
#footer{background:none}
#footer-text{color:rgba(0,0,0,.6);font-size:.9em}}
@media amzn-kf8{#header,#content,#footnotes,#footer{padding:0}}
</style>
<style>
/*! Asciidoctor Tabs | Copyright (c) 2018-present Dan Allen | MIT License */
.tabs {
    margin-bottom: 1.25em;
}

.tablist > ul {
    display: flex;
    flex-wrap: wrap;
    list-style: none;
    margin: 0;
    padding: 0;
}

.tablist > ul li {
    align-items: center;
    background-color: #fff;
    cursor: pointer;
    display: flex;
    font-weight: bold;
    line-height: 1.5;
    padding: 0.25em 1em;
    position: relative;
}

.tablist > ul li:focus-visible {
    outline: none;
}

.tablist.ulist,
.tablist.ulist > ul li {
    margin: 0;
}

.tablist.ulist > ul li + li {
    margin-left: 0.25em;
}

.tabs .tablist li::after {
    content: "";
    display: block;
    height: 1px;
    position: absolute;
    bottom: -1px;
    left: 0;
    right: 0;
}

.tabs.is-loading .tablist li:not(:first-child),
.tabs:not(.is-loading) .tablist li:not(.is-selected) {
    background-color: #f5f5f5;
}

.tabs.is-loading .tablist li:first-child::after,
.tabs:not(.is-loading) .tablist li.is-selected::after {
    background-color: #fff;
}

/*
.tabs:not(.is-loading) .tablist li,
.tabs:not(.is-loading) .tablist li::after {
  transition: background-color 200ms ease-in-out;
}
*/

.tablist > ul p {
    line-height: inherit;
    margin: 0;
}

.tabpanel {
    background-color: #fff;
    padding: 1.25em;
}

.tablist > ul li,
.tabpanel {
    border: 1px solid #dcdcdc;
}

.tablist > ul li {
    border-bottom: 0;
}

.tabs.is-loading .tabpanel + .tabpanel,
.tabs:not(.is-loading) .tabpanel.is-hidden {
    display: none;
}

.tabpanel > :first-child {
    margin-top: 0;
}

/* #content is a signature of the Asciidoctor standalone HTML output */
#content .tabpanel > :last-child,
#content .tabpanel > :last-child > :last-child,
#content .tabpanel > :last-child > :last-child > li:last-child > :last-child {
    margin-bottom: 0;
}

.tablecontainer {
    overflow-x: auto;
}

#content .tablecontainer {
    margin-bottom: 1.25em;
}

#content .tablecontainer > table.tableblock {
    margin-bottom: 0;
}
</style>
</head>
<body class="article">
<div id="header">
<h1>Все лекции по сетям</h1>
</div>
<div id="content">
<div class="sect1">
<h2 id="_коммутация_каналов_и_пакетная_коммутация">Коммутация каналов и пакетная коммутация</h2>
<div class="sectionbody">
<div class="paragraph">
<p>В компьютерной сети все данные передаются небольшими порциями, называемыми пакетами. Такой способ передачи данных придумал Леонард Клейнрок в 1961 году и называл его пакетная коммутация. Есть два способа организации передачи информации:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>коммутация каналов</p>
</li>
<li>
<p>пакетная коммутация</p>
</li>
</ul>
</div>
<div class="sect2">
<h3 id="_коммутация_каналов">Коммутация каналов</h3>
<div class="paragraph">
<p>Коммутация каналов применяется обычно в телефонии. Перед тем, как передать данные от одного абонента к другому, необходимо установить соединение (т.е. позвонить). Как только соединение будет успешно установлено, можете начинать передавать данные (говорить в трубку).</p>
</div>
<div class="imageblock">
<div class="content">
<img src="basics/packet_and_channel_switching/images/channel_switching.jpeg" alt="Ручной телефонный коммутатор" width="телефонистка за работой.">
</div>
<div class="title">Figure 1. Ручной телефонный коммутатор, телефонистка за работой.</div>
</div>
<div class="paragraph">
<p>Этот способ хорошо зарекомендовал себя в телефонных сетях, где конечными точками сети являются люди. Однако, если конечными узлами сети будут компьютеры, то канальная коммутация имеет несколько явных недостатков:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p><strong>Невозможность обмениваться данными с несколькими абонентами.</strong> Установив канал связи с одним абонентом вы можете обмениваться данными только с ним. Если нужно отправить или получить данные от другого абонента, нужно разорвать все имеющиеся каналы и установить новый.</p>
</li>
<li>
<p><strong>Простой ресурсов в случае молчания в сети.</strong> Когда абоненты установили канал связи и не передают данные, то ресурсы сети просто простаивают. В то же время, никакой другой абонент не может им передать свои данные.</p>
</li>
<li>
<p><strong>Время на установку соединения.</strong> Каждый раз, когда один абонент хочет передать данные другому абоненту, необходимо установить соединение. Что требует определенного времени и ресурсов сети.</p>
</li>
<li>
<p>Недостатком канальной коммутации является полоса пропускания и аналоговая природа этой полосы. Таким образом, что большой объем дискретных сигналов через нее не передать.</p>
</li>
</ol>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
Пакетная передача данных выросла из телеграфа именно поэтому все каналы должны быть установлены заранее.
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="_коммутация_пакетов">Коммутация пакетов</h3>
<div class="paragraph">
<p>В пакетной коммутации считается, что все каналы связи уже установлены, и данные просто передаются от одного узла к другому. Перед отправкой данные разбиваются на отдельные фрагменты, называемые пакетами. Каждый пакет состоит из двух частей:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>заголовок</p>
</li>
<li>
<p>данные</p>
</li>
</ul>
</div>
<div class="imageblock">
<div class="content">
<img src="basics/packet_and_channel_switching/images/data_packets.png" alt="Данные разбиваются на пакеты.">
</div>
<div class="title">Figure 2. Данные разбиваются на пакеты.</div>
</div>
<div class="paragraph">
<p>Заголовок пакета всегда содержит в себе информацию о получателе и другую информацию, необходимую для успешной доставки пакета конечному адресату.</p>
</div>
<div class="paragraph">
<p>Хорошей аналогией сетевого пакета является обыкновенное письмо в конверте. Само письмо - это данные. А информация на конверте - это заголовок. Информации на конверте должно быть достаточно, чтобы доставить письмо адресату и чтобы адресат знал, от кого оно пришло.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
Все сети передачи данных растут из телеграфа, а телеграф растет из почтового сообщения. Именно поэтому и в русской и в английской терминологии все соответсвует почтовому сообщению и телефграной передачи данных.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Сравнение сетей с коммутацией каналов и пакетов (<a href="https://evileg.com/ru/post/37/" class="bare">https://evileg.com/ru/post/37/</a>)</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Коммутация каналов</th>
<th class="tableblock halign-left valign-top">Коммутация пакетов</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Необходимо предварительно устанавливать соединение</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Отсутствует этап установления соединения</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Адрес требуется только на этапе установления соединения</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Адрес и другая служебная информация передаются с каждым пакетом</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Сеть может отказать абоненту в установлении соединения</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Сеть всегда готова принять данные от абонента</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Гарантированная пропускная способность (полоса пропускания) для взаимодействующих абонентов</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Пропускная способность сети для абонентов неизвестна, задержки передачи носят случайный характер</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Трафик реального времени передается с минимальными задержками</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Ресурсы сети используются эффективно при передаче пульсирующего трафика</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Высокая надежность передачи аналоговых данных</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Возможные потери данных из-за переполнения буферов</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Нерациональное использование пропускной способности каналов, снижающее общую эффективность сети</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Автоматическое динамическое распределение пропускной способности физического канала между абонентами</p></td>
</tr>
</tbody>
</table>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_каналы_передачи_данных">Каналы передачи данных</h2>
<div class="sectionbody">
<div class="paragraph">
<p>По способу передачи данных каналы делятся на три типа:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Симплексный канал (Simplex) - позволяет передавать данные только в одном направлении. Примером такого канала может служить теле- и радиовещание, GPS и ГЛОНАСС.</p>
</li>
</ol>
</div>
<div class="imageblock">
<div class="content">
<img src="basics/data%20channels/images/simplex.jpeg" alt="Симплексный канал.">
</div>
<div class="title">Figure 3. Симплексный канал.</div>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Полудуплекс (Half duplex) - канал, который позволяет передавать данные в обе стороны, но только в одном направлении в один момент времени. Другими словами, вы не можете одновременно передавать и получать данные в этом канале. Примером использования такого канала является обычная рация.</p>
</li>
</ol>
</div>
<div class="imageblock">
<div class="content">
<img src="basics/data%20channels/images/half-duplex.jpeg" alt="Полудуплексный канал.">
</div>
<div class="title">Figure 4. Полудуплексный канал.</div>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Полный дуплекс (Full-duplex) - позволяет передавать данные в обе стороны и одновременно.</p>
</li>
</ol>
</div>
<div class="imageblock">
<div class="content">
<img src="basics/data%20channels/images/duplex.jpeg" alt="Полнодуплексный канал.">
</div>
<div class="title">Figure 5. Полнодуплексный канал.</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_модель_isoosi">Модель ISO/OSI</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Передача данных в компьютерной сети довольно сложная задача. И как при решении сложных задач, она была разбита на простые, независимые подзадачи. В конце 70-х годов была предложена модель OSI (Open Systems Interconnection), которая предлагала разбить передачу данных в компьютерной сети на 7 уровней. В начале 80-х годов эта модель стала основной в рабочей группе ISO (International Organization for Standardization, Международная организация по стандартизации).</p>
</div>
<div class="paragraph">
<p>С тех пор эта модель называется ISO/OSI (но в простой речи говорят только OSI) и в основном она используется для объяснения работы сети.</p>
</div>
<div class="paragraph">
<p>Модель OSI разбивает процесс передачи данных в компьютерной сети на 7 независимых уровней. Обычно эти уровни располагаются снизу вверх, как показано на рисунке.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="basics/iso_osi/images/iso_osi_model.png" alt="7 уровней модели ISO/OSI.">
</div>
<div class="title">Figure 6. 7 уровней модели ISO/OSI.</div>
</div>
<div class="paragraph">
<p>Каждый уровень в модели OSI является независимым, т.е. он ничего не знает о работе других уровней. Например, сетевой уровень ничего не знает о работе канального и транспортного уровня.</p>
</div>
<div class="paragraph">
<p>Данные в этой модели могут двигаться строго вниз или строго вверх. Т.е. во время отправки данные с транспортного уровня передаются сетевому, а затем канальному. А во время получения данные с канального уровня передаются сетевому, затем транспортному и так далее. Данные не гуляют между уровнями в хаотическом порядке.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="basics/iso_osi/images/iso_osi_model2.png" alt="Движение данных в модели ISO/OSI.">
</div>
<div class="title">Figure 7. Движение данных в модели ISO/OSI.</div>
</div>
<div class="sect2">
<h3 id="_физический_уровень">Физический уровень</h3>
<div class="paragraph">
<p>Физический уровень отвечает за способы передачи или приема бит. На этом уровне описываются способы подключения (проводное соединение, беспроводное соединение), параметры сигналов, такие как амплитуда, частота, фаза, используемая модуляция. Решаются вопросы, связанные с синхронизацией, избавлением от помех, скоростью передачи данных и так далее.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="basics/iso_osi/images/iso_osi_1_level.png" alt="Физический уровень модели ISO/OSI.">
</div>
<div class="title">Figure 8. Физический уровень модели ISO/OSI.</div>
</div>
</div>
<div class="sect2">
<h3 id="_канальный_уровень">Канальный уровень</h3>
<div class="paragraph">
<p>Канальный уровень отвечает за доставку кадров (frame) между устройствами, подключенными к одному сетевому сегменту. Заголовок кадра содержит аппаратные адреса отправителя и получателя, что позволяет определить, какое устройство отправило кадр и какое устройство должно получить и обработать его.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="basics/iso_osi/images/iso_osi_2_level.png" alt="Канальный уровень модели ISO/OSI.">
</div>
<div class="title">Figure 9. Канальный уровень модели ISO/OSI.</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
Хост - это любой компьютер (ПК, ноутбук, телефон, планшет) подключенный к сети.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>По сути, канальный уровень позволяет создать сегмент сети с несколькими хостами и обмениваться между ними кадрами и проверку их целостности (контрольная сумма).</p>
</div>
<div class="imageblock">
<div class="content">
<img src="basics/iso_osi/images/iso_osi_2_level_2.png" alt="Обмен кадрами на канальном уровне.">
</div>
<div class="title">Figure 10. Обмен кадрами на канальном уровне.</div>
</div>
</div>
<div class="sect2">
<h3 id="_сетевой_уровень">Сетевой уровень</h3>
<div class="paragraph">
<p>Сетевой уровень отвечает за доставку данных между хостами, находящимися в разных сетевых сегментах. Другими словами - есть несколько сетевых сегментов, которые соединены между собой. Сетевой уровень занимается тем, что доставляет пакет от одного хоста к другому, даже если они в разных сегментах.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="basics/iso_osi/images/iso_osi_3_level.png" alt="Сетевой уровень модели ISO/OSI.">
</div>
<div class="title">Figure 11. Сетевой уровень модели ISO/OSI.</div>
</div>
</div>
<div class="sect2">
<h3 id="_транспортный_уровень">Транспортный уровень</h3>
<div class="paragraph">
<p>Транспортный уровень занимается доставкой данных от одного приложения до другого. Как известно, на хостах помимо ОС (операционной системы) работают различные приложения. Когда пакет пришел на хост, транспортный уровень доставляет его нужному приложению.</p>
</div>
<div class="paragraph">
<p>Например, вы запустили Telegram и смотрите видео на RuTube. Когда на ваш хост приходит очередной пакет, именно транспортный уровень определяет, какому приложению необходимо передать полученные данные.</p>
</div>
<div class="paragraph">
<p>Помимо доставки данных от одного приложения до другого, транспортный уровень заботится о скорости и надежности доставки данных.</p>
</div>
</div>
<div class="sect2">
<h3 id="_сеансовый_уровень">Сеансовый уровень</h3>
<div class="paragraph">
<p>Сеансовый уровень отвечает за поддержание сеанса связи, позволяя приложениям взаимодействовать между собой длительное время.</p>
</div>
</div>
<div class="sect2">
<h3 id="_уровень_представления">Уровень представления</h3>
<div class="paragraph">
<p>Как понятно из названия, этот уровень отвечает за представление данных. Например, если данные должны быть сжаты или закодированы перед отправкой или переданы в определенной кодировке. Тоже касается и обработки полученных данных.</p>
</div>
</div>
<div class="sect2">
<h3 id="_уровень_приложения">Уровень приложения</h3>
<div class="paragraph">
<p>Обеспечивает взаимодействие сети и пользовательских приложений. Именно на этом уровне располагаются популярные Интернет службы: HTTP (веб), SMTP (электронная почта) и многие другие. Когда вы, как программист, будете писать сетевое приложение, это как раз и будет реализация 7-го уровня модели ISO/OSI.</p>
</div>
</div>
<div class="sect2">
<h3 id="_сетевой_юмор">Сетевой юмор</h3>
<div class="paragraph">
<p>Сетевые инженеры вовсе не скучные люди и так же как и все любят повеселиться. Поэтому, помимо 7-и уровней в модели ISO/OSI есть еще несколько уровней:
●	политический
●	религиозный
●	финансовый
●	и другие</p>
</div>
<div class="paragraph">
<p>Подробней об этом можно почитать в Wiki - <a href="https://en.wikipedia.org/wiki/Layer_8" class="bare">https://en.wikipedia.org/wiki/Layer_8</a></p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_сетевые_стандарты">Сетевые стандарты</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Есть два основные стандарта, которые содержат информацию о работе компьютерной сети:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>IEEE 802.*</p>
</li>
<li>
<p>RFC</p>
</li>
</ol>
</div>
<div class="sect2">
<h3 id="_стандарты_ieee_802">Стандарты IEEE 802.*</h3>
<div class="paragraph">
<p>IEEE (Институт инженеров электротехники и электроники) -  некоммерческая инженерная ассоциация из США, разрабатывающая широко применяемые в мире стандарты по радиоэлектронике, электротехнике и аппаратному обеспечению вычислительных систем и сетей.</p>
</div>
<div class="paragraph">
<p>В частности, стандарты IEEE 802.* касаются локальных вычислительных сетей (LAN) и сетей мегаполисов (MAN).</p>
</div>
<div class="paragraph">
<p>Давайте познакомимся с несколькими из них. Например, стандарт IEEE 802.11 - это целый набор стандартов связи для коммуникации в <strong>беспроводной</strong> локальной сетевой зоне. В жизни это называется <strong>Wi-Fi</strong>. Если вы посмотрите на любой Wi-Fi роутер или Wi-Fi сетевой адаптер в магазине, то вы сразу увидите упоминания этих стандартов прямо в названии. На рисунке видно упоминание двух стандартов IEEE 802.11n и IEEE 802.11ac.</p>
</div>
<div class="paragraph">
<p>IEEE 802.11n - осуществляет передачу данных по частотам 2.4 ГГц и 5 ГГц при скорости для одного канала до 150 МБит/сек. А IEEE 802.11ac предполагает передачу данных по частотам 5 ГГц при скорости до 867 Мбит/сек для одного канала (<a href="https://mcsindex.com/" class="bare">https://mcsindex.com/</a>)</p>
</div>
<div class="paragraph">
<p>Это очень удобно, если вы собираетесь сделать компьютерную сеть дома или, скажем,  на работе. При покупке оборудования вы сможете сразу убедиться, что оно совместимо друг с другом.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="basics/network_standarts_ieee_rfc/images/wifi_router.png" alt="Поддержка стандартов IEEE 802.11 у сетевого роутера.">
</div>
<div class="title">Figure 12. Поддержка стандартов IEEE 802.11 у сетевого роутера.</div>
</div>
<div class="paragraph">
<p>На сегодняшний день только стандартов Wi-Fi (IEEE 802.11) существует несколько десятков (<a href="https://ru.wikipedia.org/wiki/IEEE_802.11" class="bare">https://ru.wikipedia.org/wiki/IEEE_802.11</a>) и они продолжают постоянно добавляться.</p>
</div>
<div class="paragraph">
<p>А вот, например, семейство стандартов IEEE 802.3 описывает проводную технологию передачи данных CSMA/CD, в простонародье Ethernet. Этот стандарт вы скорее всего  (более 90%) можете встретить у себя дома. К вам в квартиру от провайдера приходит кабель (витая пара или оптоволокно), который вы включаете в ваш роутер.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="basics/network_standarts_ieee_rfc/images/cabels.jpeg" alt="Витая пара (слева) и оптоволоконный кабель (справа).">
</div>
<div class="title">Figure 13. Витая пара (слева) и оптоволоконный кабель (справа).</div>
</div>
<div class="paragraph">
<p>Существует более 50 различных стандартов в семействе 802.3 (<a href="https://ru.wikipedia.org/wiki/IEEE_802.3" class="bare">https://ru.wikipedia.org/wiki/IEEE_802.3</a>).</p>
</div>
<div class="paragraph">
<p>Не нужно пугаться большому количеству стандартов 802.11 и 802.3, многие из них считаются устаревшими, а некоторые уже даже и не встретишь в живой природе..</p>
</div>
<div class="paragraph">
<p>Все стандарты IEEE 802.* описывают технологии канального уровня. Как видно на рисунке, технология полностью описывает работу физического и канального уровня. Английскую часть рисунка я взял прямо из стандарта 802.3-2012.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="basics/network_standarts_ieee_rfc/images/802.png" alt="Технологии канального уровня.">
</div>
<div class="title">Figure 14. Технологии канального уровня.</div>
</div>
<div class="paragraph">
<p>На физическом уровне технология описывает способы соединения конечных устройств, модуляцию сигнала и другие характеристики. А на канальном уровне описывается формат аппаратных адресов, максимальный и минимальный размер передаваемого пакета, интерпретацию определенных полей в заголовке.</p>
</div>
</div>
<div class="sect2">
<h3 id="_rfc">RFC</h3>
<div class="paragraph">
<p>RFC (Request For Comments) - нумерованные документы, которые содержат программные технические спецификации сетевых протоколов широко применяемых в сети Интернет.</p>
</div>
<div class="paragraph">
<p>Сетевой протокол - это некоторый свод правил/соглашений, который позволяет всем участникам взаимодействия понимать друг друга.</p>
</div>
<div class="paragraph">
<p>В RFC описаны все популярные открытые сетевые протоколы: TCP (<a href="https://datatracker.ietf.org/doc/html/rfc9293">9293</a>), IP (<a href="https://datatracker.ietf.org/doc/html/rfc791">791</a>), SMTP (протокол доставки электронной почты, <a href="https://datatracker.ietf.org/doc/html/rfc5321">5321</a>), HTTP (веб, <a href="https://datatracker.ietf.org/doc/html/rfc2616">2616</a>) и многие другие.</p>
</div>
<div class="paragraph">
<p>Если вам понадобится разобраться в тонкостях работы того или иного протокола, рекомендую почитать его RFC.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_ethernet_csmacd">Ethernet (CSMA/CD)</h2>
<div class="sectionbody">
<div class="paragraph">
<p>И так, предположим, мы хотим собрать свою первую сеть состоящую из 3-х хостов. Как это сделать? С помощью чего мы их соединим, как будет работать сетевая карта, каким способом мы будем кодировать биты, каким разъемом подключать, как мы определим, кому из 3-х хостов мы отправили данные и так далее.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="ieee802/ethernet/csma_cd/images/3_hosts.png" alt="3 хоста.">
</div>
<div class="title">Figure 15. 3 хоста.</div>
</div>
<div class="paragraph">
<p>Чтобы объединить 3 хоста в одну сеть, нужно определиться с технологией канального уровня. В стандартах IEEE 802.* можно найти описание различных технологий. Мы выберем Ethernet, как наиболее распространенный. Есть два основных стандарта по Ethernet:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>802.3 - проводной Ethernet</p>
</li>
<li>
<p>802.11 - беспроводной Ethernet, мы его еще называем Wi-Fi.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Ethernet был придуман в 1973 году инженером Робертом Меткалфом (<a href="https://ethernethistory.typepad.com/papers/ethernetbobmemo.pdf" class="bare">https://ethernethistory.typepad.com/papers/ethernetbobmemo.pdf</a>). В то время Роберт работал в компании Xerox.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
На сегодняшний день только стандартов Wi-Fi (IEEE 802.11) существует несколько десятков (<a href="https://ru.wikipedia.org/wiki/IEEE_802.11" class="bare">https://ru.wikipedia.org/wiki/IEEE_802.11</a>) и они продолжают постоянно добавляться.
</td>
</tr>
</table>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
Еще больше истории про создание Ethernet и о самом создателе можно почитать в статье на Хабре "Роберт Меткалф: папа EtherNet, отличный инженер и фиговый предсказатель (но за слова ответил)" (<a href="https://habr.com/ru/companies/edison/articles/277827/" class="bare">https://habr.com/ru/companies/edison/articles/277827/</a>).
</td>
</tr>
</table>
</div>
<div class="sect2">
<h3 id="_физический_уровень_ethernet">Физический уровень Ethernet</h3>
<div class="paragraph">
<p>C 1983 году технология Ethernet была описана в стандартах IEEE 802.3. Рабочее название Ethernet известно как CSMA/CD (Carrier Sense Multiple Access with Collision Detection — множественный доступ с прослушиванием несущей и обнаружением коллизий). В этой аббревиатуре скрывается идея работы технологии. Для понятности, давайте разберем эту аббревиатуру в неправильном порядке:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>MA (Multiple Access)</strong> - множественный доступ означает, что любой хост в сети Ethernet может отправить данные в сеть когда захочет. Помните, в начале курса мы говорили о пакетной коммутации. Она предполагает, что все каналы передачи данных уже установлены. Вот MA как раз и есть реализация этой идеи.</p>
</li>
<li>
<p><strong>CS (Carrier Sense)</strong> - прослушиванием несущей, означает не отправлять данные в сеть, если кто-то другой уже передает что-то.</p>
</li>
<li>
<p><strong>CD (Collision Detection)</strong> - определение коллизий. Если все-таки два и более хоста начали одновременно передавать данные в сеть, это называется коллизия. В этом случае полученные во время коллизии данные отбрасываются и хосты начинают передачу последнего пакета снова. Стоит отметить, что коллизия может случиться только в том, случае если используется полудуплексное соединение (half-duplex). Если у вас полнодуплексное соединение (full-duplex), то коллизия не произойдет, так как для отправки и приема данных используются разные каналы.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Итого, алгоритм работы сети Ethernet следующий:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Каждый хост в сети Ethernet может передавать данные в любой момент времени.</p>
</li>
<li>
<p>Перед передачей данных сетевая карта проверяет несущую. Если никто в настоящий момент не передает данные, сетевая карта начинает передавать данные.</p>
</li>
<li>
<p>Если во время передачи данных сетевая карта определяет, что еще кто-то вместе с ней передает данные в сеть, то генерируется специальный JAM сигнал, сообщающий всем участникам сети, что произошла коллизия и текущий кадр с данными считать недействительным.</p>
</li>
<li>
<p>Возврат на второй пункт.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>Первая версия Ethernet стандарта IEEE 802.3 появилась в 1983 году и он предполагал передачу данных на скорости всего 10 Мбит/сек (примерно 1,25 Мбайт в секунду) с помощью коаксиального кабеля. А современные стандарты предполагают передачу данных на скорости 50 Гбит/сек.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_канальный_уровень_ethernet">Канальный уровень Ethernet</h2>
<div class="sectionbody">
<div class="paragraph">
<p>На рисунке вы можете видеть Ethernet пакет на канальном уровне. Картинка прямо из стандарта IEEE, поэтому все поля подписаны на английском. 1 октет = 8 битам = 1 байт.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="ieee802/ethernet/llc/images/ethernet_packet.png" alt="Формат Ethernet пакета и кадра.">
</div>
<div class="title">Figure 16. Формат Ethernet пакета и кадра.</div>
</div>
<div class="sect2">
<h3 id="_преамбула_и_sfd">Преамбула и SFD</h3>
<div class="paragraph">
<p>Преамбула и SFD (Start Frame Delimiter) вместе занимают 8 байт (7 + 1) и необходимы сетевой карте, чтобы подготовиться к получению Ethernet кадра (frame).</p>
</div>
</div>
<div class="sect2">
<h3 id="_mac_адреса">MAC адреса</h3>
<div class="paragraph">
<p>Сразу за SFD начинается Ethernet кадр. Кадр состоит из двух частей:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Заголовок.</p>
</li>
<li>
<p>Данные.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>Заголовок Ethernet кадра состоит из:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Адрес назначения (Destination Address).</p>
</li>
<li>
<p>Адрес источника (Source Address).</p>
</li>
<li>
<p>Поля Длина/Тип (Length/Type).</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>По 6 байт (48 бит) выделяется на аппаратный адрес назначения и отправителя. Обычно этот аппаратный адрес называется MAC адрес (или адрес сетевой карты или физический адрес) и записывается в виде байт в шестнадцатеричном формате разделенных двоеточием. Например D0:0D:56:77:33:C4.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="ieee802/ethernet/llc/images/mac_windows.png" alt="MAC адрес в ОС Windows.">
</div>
<div class="title">Figure 17. MAC адрес в ОС Windows.</div>
</div>
<div class="paragraph">
<p>Этот адрес есть у каждой сетевой карты. Вы можете самостоятельно посмотреть его у себя. Если у вас Windows, то откройте консоль (cmd.exe) и выполните команду “ipconfig /all” В результате работы команды будут перечислены все ваши локальные сетевые устройства и их параметры. Нужный вам параметр называется “Физический адрес”.</p>
</div>
<div class="paragraph">
<p>Если у вас MacOS или Linux, то в командной строке выполните команду ifconfig, как изображено на рисунке.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="ieee802/ethernet/llc/images/mac_linux.png" alt="MAC адрес в ОС Linux.">
</div>
<div class="title">Figure 18. MAC адрес в ОС Linux.</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
В современных Linux дистрибутивах команда ifconfig считается устаревшей. Вместо неё принято использовать <strong>ip link</strong> из пакета iproute2.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Каждый раз, когда ваша сетевая карта получает Ethernet пакет, она проверяет MAC адрес назначения. И если он совпадает с ее, то этот пакет дальше обрабатывается. Если нет, то пакет отбрасывается.</p>
</div>
<div class="paragraph">
<p>MAC адреса делятся на 3 типа:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>Unicast</strong> - персональный MAC адрес. Такой адрес есть у каждой сетевой карты. Он всегда прошивается прямо на заводе, при этом его можно временно изменить через драйвер.</p>
</li>
<li>
<p><strong>Multicast</strong> - групповым MAC адрес считается, если младший бит старшего байта установлен в 1 (т.е. 01:00:00:00:00:00). Этот специальный адрес сетевая карта может себе присвоить в случае, когда ожидается рассылка пакетов сразу группе хостов.</p>
</li>
<li>
<p><strong>Broadcast</strong> - широковещательный MAC адрес, записывается как все биты установленные 1 или в шестнадцатеричном формате FF:FF:FF:FF:FF:FF. Такой адрес в поле получателя означает, что пакет должен быть обработан всеми хостами, которые получили данный пакет.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Чтобы MAC адреса случайно не пересекались, за каждым производителем сетевого оборудования закреплен определенный диапазон MAC адресов, которые он может использоваться. Номер диапазона - это три старших байта адреса. Размер диапазона - оставшиеся 3 байта или примерно 16 млн. адресов (256*256*256). Все эти диапазоны можно найти в специальном OUI файле, который публично доступен по адресу <a href="https://standards-oui.ieee.org/" class="bare">https://standards-oui.ieee.org/</a>.</p>
</div>
<div class="paragraph">
<p>Например, MAC адрес моей сетевой карты 80:e6:50:08:b1:6a. В файле <a href="https://standards-oui.ieee.org/" class="bare">https://standards-oui.ieee.org/</a> легко можно найти диапазон 80-E6-50, который соответсвует Apple, Inc. И действиетльно, эта сетевая карта принадлжеит моему MacBook.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="ieee802/ethernet/llc/images/apple_mac_range.png" alt="Диапазон MAC адресов компании Apple.">
</div>
<div class="title">Figure 19. Диапазон MAC адресов компании Apple.</div>
</div>
</div>
<div class="sect2">
<h3 id="_длинатип">Длина/Тип</h3>
<div class="paragraph">
<p>Поле Длина/Тип (Length/Type) имеет две взаимоисключающих трактовки:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Если значение поля равно или менее 1500 (0x05DC), то значение трактуется как длина Ethernet кадра.</p>
</li>
<li>
<p>Если значение поля равно или более 1536, то значение трактуется как идентификатор вложенного протокола. К примеру, если внутри Ethernet кадра будет лежать IP протокол, то значение поля будет 0x0800, а если ARP протокол, то 0x0806.</p>
</li>
</ol>
</div>
</div>
<div class="sect2">
<h3 id="_данные_ethernet_пакета">Данные Ethernet пакета</h3>
<div class="paragraph">
<p>После Ethernet заголовка следуют сами данные (MAC client data). Размер этих данных от 46 до 1500 байт. Т.е. Ethernet кадр не может быть больше 1514 байт (1500 байт данных + 14 байт Ethernet заголовок).</p>
</div>
<div class="paragraph">
<p>Минимальный размер данных в Ethernet кадре составляет 46 байт. Это ограничение сделано для того, чтобы в момент определения коллизии можно было однозначно понять, какой именно пакет вызвал коллизию.</p>
</div>
<div class="paragraph">
<p>Почему бы не сделать пакеты побольше? Зачем это ограничение в 1500 байт? Максимальный размер в 1500 байт полезной нагрузки в пакете обеспечивает хорошую скорость для передачи данных реального времени и не слишком сильно нагружает сеть заголовками.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="ieee802/ethernet/llc/images/packet_normal_size.png" alt="Нормальный размер пакетов.">
</div>
<div class="title">Figure 20. Нормальный размер пакетов.</div>
</div>
<div class="paragraph">
<p>Чем больше максимальный размер пакета, тем больше будет задержка при отправке второго пакета.</p>
</div>
<div class="paragraph">
<p>Предположим, у вас на компьютере работает два приложения. Одно скачивает файл из сети, а по второму вы разговариваете по видео-связи с друзьями. Если максимальный размер пакета сделать очень большими, как на рисунке ниже, то пока ваша сетевая карта будет принимать пакет с данными скачиваемого файла, пакет с видео и звуковой дорожкой от ваших друзей будет ожидать где-то в буфере на прием. Вы это заметите, так как видео и звук будет замораживаться на время и разговор превратиться в мучение, а не в радость.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="ieee802/ethernet/llc/images/packet_big_size.png" alt="Слишком большой максимальный размер пакетов.">
</div>
<div class="title">Figure 21. Слишком большой максимальный размер пакетов.</div>
</div>
<div class="paragraph">
<p>Если пакет сделать очень маленьким, то возрастет нагрузка на передаваемые данные. Предположим, скорость передачи данных у нас 10 Мбит/сек. Т.е. мы можем передать 10 000 000 бит в секунду. Вспомним формат Ethernet пакета:
●	7 байт преамбула
●	1 байт SFD
●	14 байт заголовок Ethernet кадра
●	1500 байт данных
●	4 байта FCS</p>
</div>
<div class="paragraph">
<p>Итого получается 1526 байт = 26 байт служебной информации + 1500 байт данных.</p>
</div>
<div class="paragraph">
<p>Добавим к этому расстояние между передаваемыми пакетами. В Ethernet вы не можете передать два пакета строго друг за другом, между ними должно быть расстояние. Это расстояние называется межпакетным интервалом (interpacket gap).</p>
</div>
<div class="imageblock">
<div class="content">
<img src="ieee802/ethernet/llc/images/interpacket_gap.png" alt="Межпакетный интервал (gap).">
</div>
<div class="title">Figure 22. Межпакетный интервал (gap)</div>
</div>
<div class="paragraph">
<p>Для 10 Мбит/сек размер gap равен примерно 47 битам (почти 6 байт) (<a href="https://en.wikipedia.org/wiki/Interpacket_gap" class="bare">https://en.wikipedia.org/wiki/Interpacket_gap</a>).</p>
</div>
<div class="paragraph">
<p>Получается, что для передачи <strong>1500</strong> байт данных, мы дополнительно передаем 26 служебных байт + 6 байт gap. Итого получается 1532 байта (1500 байт данных + 26 байт служебной информации + 6 байт gap).</p>
</div>
<div class="paragraph">
<p>1532 байта данных это 12 256 бит (1532 * 8). При скорости <strong>10 Мбит/сек</strong>, за одну секунду мы успеем передать <strong>815</strong> пакетов.</p>
</div>
<div class="paragraph">
<p>В каждом пакете 1500 байт данных, получается, что за секунду мы передадим <strong>1 223 890</strong> байт полезных данных.</p>
</div>
<div class="paragraph">
<p>Предположим, мы уменьшим максимальный размер пакета до <strong>1000</strong> байт. Что получится?</p>
</div>
<div class="paragraph">
<p>1000 байт данных + 26 байт служебной информации + 6 байт gap = 1032 байта или 8 256 бит. При 10 Мбит/сек за одну секунду мы успеем передать 1211 пакетов. В каждом 1000 байт данных, получается, что за секунду мы передадим <strong>1 211 240</strong> байт полезной нагрузки, что на 12 649 байт меньше (это примерно 1%).</p>
</div>
<div class="paragraph">
<p>Вроде немного, при этом разница в количестве пакетов около 50%, <strong>815</strong> против <strong>1211</strong>. А это означает - на 50% больше прерываний на сетевом интерфейсе при обработке и отправке пакетов, на 50% больше раз обрабатывать заголовок, и так далее.</p>
</div>
</div>
<div class="sect2">
<h3 id="_frame_check_sequence">Frame Check Sequence</h3>
<div class="paragraph">
<p>Заканчивается Ethernet пакет полем Frame Check Sequence (FCS). Это поле содержит CRC32. CRC (Cyclic redundancy check) - алгоритм нахождения контрольной суммы, предназначенный для проверки целостности данных.</p>
</div>
<div class="paragraph">
<p>При отправке каждого Ethernet пакет сетевая карта считает его CRC32 и записывает в FCS. Во время получения Ethernet пакета, сетевая карта пересчитывает CRC32 для этого пакета и сверяет со значением в поле FCS. В случае, если эти значения не совпадают, пакет отбрасывается.</p>
</div>
<div class="paragraph">
<p>Это такой способ удостовериться, что принятый пакет не был случайно искажен во время передачи. И данные пришли именно те, которые были отправлены.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_смотрим_ethernet_кадр_в_wireshark">Смотрим Ethernet кадр в Wireshark</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Давайте на практике посмотрим на Ethernet кадр. Wireshark и другие снифферы могут показать только Ethernet кадр. Посмотреть Ethernet пакет(вместе с полями Преамбула, SFD и FCS) не получится. Так как эти поля предназначаются только для сетевой карты.</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Запустите Wireshark.</p>
</li>
<li>
<p>Выберите (дважды кликните) нужный интерфейс для захвата пакетов. У меня это “Беспроводная сеть”.</p>
</li>
<li>
<p>Wireshark начнет захватывать и отображать пакеты в реальном времени.</p>
</li>
<li>
<p>Нажмите стоп в левом верхнем углу.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>У вас должен получиться экран похожий на мой</p>
</div>
<div class="imageblock">
<div class="content">
<img src="ieee802/ethernet/llc/images/wireshark.png" alt="Смотрим Ethernet кадр в Wireshark.">
</div>
<div class="title">Figure 23. Смотрим Ethernet кадр в Wireshark.</div>
</div>
<div class="paragraph">
<p>Вся рабочая область Wireshark разбита на 3 части.</p>
</div>
<div class="paragraph">
<p>Верхняя часть отображает список захваченных пакетов и короткую информацию о них (время захвата, IP адреса и другую информацию). Вы можете повыбирать (кликнув мышкой) пакеты.</p>
</div>
<div class="paragraph">
<p>В левой нижней части экрана отображается структура выбранного вами пакета. Раскройте пункт, который называется Ethernet II. В раскрытом пункте вы увидите поля:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Destination</p>
</li>
<li>
<p>Source</p>
</li>
<li>
<p>Type</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Это как раз и есть те самые: Адрес назначения (Destination Address), Адрес источника (Source Address), Поля Длина/Тип (Length/Type). Какой бы пакет вы не выбрали, в начале у вас всегда будет Ethernet заголовок и первым полем будет Destination.</p>
</div>
<div class="paragraph">
<p>В правом нижнем поле отображается шестнадцатеричное представление пакета. Так называемый hex-dump. Когда вы выделяете поле на левом экране, то нужный байт, которые соответствуют этому полю, подсвечиваются в правом поле.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="ieee802/ethernet/llc/images/wireshark_hex.png" alt="Wireshark подсвечивает байты при выборе поля.">
</div>
<div class="title">Figure 24. Wireshark подсвечивает байты при выборе поля.</div>
</div>
<div class="paragraph">
<p>На рисунке я выбрал поле Source (Адрес источника), его размер 6 байт и Wireshark мне подсветил эти 6 байт в правом поле.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_топологии">Топологии</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_полносвязная_ячеистая">Полносвязная (ячеистая)</h3>
<div class="paragraph">
<p>Если мы попробуем собрать компьютерную сеть из 3, 4 хостов вооружившись только сетевой картой и проводом, то все, что мы сможем собрать:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Полносвязная сеть</p>
</li>
<li>
<p>Общая шина</p>
</li>
</ul>
</div>
<div class="imageblock">
<div class="content">
<img src="ieee802/ethernet/topology/images/fully_connected.png" alt="Полносвязная компьютерная сеть.">
</div>
<div class="title">Figure 25. Полносвязная компьютерная сеть.</div>
</div>
<div class="paragraph">
<p>Если мы будем использовать полнодуплексное соединение (full-duplex), то в такой сети у нас не будет коллизий и скорость передачи данных для всех хостов будет постоянной.</p>
</div>
<div class="paragraph">
<p>Проблема полносвязной сети заключается в количестве сетевых карт, необходимых для подключения. Для каждого хоста нам потребуется N-1 сетевая карта. Если у вас всего 3 хоста, то вставить в один компьютер 2 сетевые карты не очень сложно. Но если ваша сеть будет насчитывать 10 хостов, то вставить 9 сетевых карт уже проблематично.</p>
</div>
</div>
<div class="sect2">
<h3 id="_общая_шина">Общая шина</h3>
<div class="paragraph">
<p>Использование топологии общая шина более практичное, чем полносвязная сеть. Организации сети на базе технологии Ethernet по топологии общая шина описано в стандартах IEEE 802.3 (самый первый стандарт, он же 10BASE5) и IEEE 802.3a (он же 10BASE2). Передача данных осуществляется по полуплексному каналу (half-duplex).</p>
</div>
<div class="imageblock">
<div class="content">
<img src="ieee802/ethernet/topology/images/bus.png" alt="Общая шина.">
</div>
<div class="title">Figure 26. Общая шина.</div>
</div>
<div class="paragraph">
<p>Большим недостатком такой топологии является ее ненадежность. На рисунке 25 показан стандартный BNC T-коннектор. С одной стороны (слева) подключается Хост 1, с другой стороны (справа) подключается Хост 3, а ваш (например, Хост 2) подключается по центру. И таким образом сеть может организовываться дальше. И проблема тут как раз в этих подключениях. Довольно часто, по неаккуратности (пинали ногами или шваброй, во время уборки) коннекторы разъединялись, что приводило к отключению всей сети.</p>
</div>
<div class="paragraph">
<p>Предположим, у нас есть, как на рисунке. Вы, владелец хоста 3 неаккуратно пнули ногой кабель, что привело к отсоединению коннектора и выходу из строя всей сети</p>
</div>
<div class="imageblock">
<div class="content">
<img src="ieee802/ethernet/topology/images/bnc.jpeg" alt="10BASE2 кабель с BNC T-коннектором.">
</div>
<div class="title">Figure 27. 10BASE2 кабель с BNC T-коннектором.</div>
</div>
</div>
<div class="sect2">
<h3 id="_звезда">Звезда</h3>
<div class="paragraph">
<p>Для решения проблемы, когда один пользователь может намеренно или случайно сломать часть сети, придумали топологию звезда.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="ieee802/ethernet/topology/images/star.png" alt="Организация сети по топологии звезда.">
</div>
<div class="title">Figure 28. Организация сети по топологии звезда.</div>
</div>
<div class="paragraph">
<p>Для организации такой топологии одних сетевых карт и проводов будет недостаточно. Потребуется сетевое оборудование - концентратор (он же репитер или хаб) или коммутатор.</p>
</div>
<div class="paragraph">
<p>На сегодняшний день это самая распространенная топология. Выход из строя одной рабочей станции не отражается на работе всей сети в целом. В отличие от общей шины, в топологии звезда более лёгкий поиск неисправностей и обрывов в сети.</p>
</div>
<div class="paragraph">
<p>Другими достоинствами такой топологии являются:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>высокая производительность сети (при условии правильного проектирования);</p>
</li>
<li>
<p>гибкие возможности администрирования;</p>
</li>
<li>
<p>низкая стоимость;</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Простота установки и масштабируемость сделали топологию звезды единственной общей топологией.</p>
</div>
<div class="paragraph">
<p>Хороший пример такой топологии - домашняя Wi-Fi сеть. Обычно домой устанавливается Wi-Fi роутер, к которому подключаются все устройства - ноутбуки, телевизор, телефоны и так далее.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_практика_в_miminet">Практика в Miminet</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Далеко не у всех есть возможность дома или на работе собирать произвольные сети. Поэтому, для образовательных целей мы сделал веб-эмулятор Miminet (<a href="https://miminet.ru/" class="bare">https://miminet.ru/</a>).</p>
</div>
<div class="paragraph">
<p>Веб-эмулятор позволяет вам нарисовать компьютерную сеть, задать ей настройки и посмотреть, как она будет работать.</p>
</div>
<div class="paragraph">
<p>В рамках этого курса я буду часто приводить различные примеры работы сети с сылкой на Miminet.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_концентратор_репитор_хаб">Концентратор (репитор, хаб)</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Чтобы организовать компьютерную сеть с топологией звезда, нам нужно сетевое оборудование. Простейшим сетевым оборудованием является хаб.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="hub/images/hub.png" alt="Хаб">
</div>
<div class="title">Figure 29. Хаб</div>
</div>
<div class="paragraph">
<p>Хаб работает на физическом уровне модели ISO/OSI и представляет собой небольшую коробку с портами для подключения (рисунок 27, справа).</p>
</div>
<div class="paragraph">
<p>Получив сигнал на любой из подключенных портов, хаб передает его во все остальные подключенные порты. Таким образом, если мы построим сеть их 3-х хостов, как изображено на рисунке ниже и отправим пакет от хоста 1 к хосту 2, то хост 3 также получит этот пакет. Так как хаб, получив пакет от хоста 1 отправит его во все свои остальные активные порты.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="hub/images/hub_example.png" alt="Сеть из 3-х хостов с использованием хаба (https://miminet.ru/web_network?guid=c4627fb9-a1da-4919-b97e-adce598a3464)">
</div>
<div class="title">Figure 30. Сеть из 3-х хостов с использованием хаба (<a href="https://miminet.ru/web_network?guid=c4627fb9-a1da-4919-b97e-adce598a3464" class="bare">https://miminet.ru/web_network?guid=c4627fb9-a1da-4919-b97e-adce598a3464</a>)</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
На сервисе miminet.ru вы можете самостоятельно воссоздать такую сеть и убедиться, что она работает так, как и описано. Или можете просто открыть сеть по ссылке и запустить анимацию.
</td>
</tr>
</table>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
Здесь и далее на рисунках сети вы будете видеть рядом с хостами  подпись вида 10.0.0.2/24. Это так записаны IP адрес/маска хоста. Что это такое мы разберем чуть ниже. А пока это можно интерпретировать как уникальный идентификатор хоста.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Давайте попробуем усложнить схему. Соберем сеть из нескольких хабов и узлов. Как показано на рисунке. С помощью команды ping отправим пакет от хоста 1 к хосту 2 и посмотрим что произойдет.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="hub/images/hub_example2.png" alt="Большая сеть из хабов (https://miminet.ru/web_network?guid=f23fbe16-031b-46ea-8de5-41d5550cc7bc)">
</div>
<div class="title">Figure 31. Большая сеть из хабов (<a href="https://miminet.ru/web_network?guid=f23fbe16-031b-46ea-8de5-41d5550cc7bc" class="bare">https://miminet.ru/web_network?guid=f23fbe16-031b-46ea-8de5-41d5550cc7bc</a>))</div>
</div>
<div class="paragraph">
<p>Запустив такую сеть мы увидим, что все пакеты, которыми будут обмениваться хост 1 (host_1) и хост 2 (host_2) будут доставлены и на хост 3 и на хост 4. Так как хаб работает на физическом уровне и все что он делает - пересылает полученные пакеты во все свои активные порты.</p>
</div>
<div class="paragraph">
<p>Основная проблема такой сети заключается в том, что скорость передачи данных в сети падает с ростом количества узлов.</p>
</div>
<div class="paragraph">
<p>Допустим, у нас есть сеть из 3-х хостов и скорость передачи данных 10 Мбит/сек. В такой сети, для 3-х хостов, средняя скорость передачи данных для каждого узла будет около 3 Мбит/сек.</p>
</div>
<div class="paragraph">
<p>Если хост 3 захочет отправить данные в сети, он должен будет убедиться, что хост 1 и хост 2 ничего не отправляют. Если в сети будет 10 хостов, то вероятность, что все 9 хостов на текущий момент ничего не отправляют сеть еще ниже. А значит, ниже вероятность того, что наш хост сможет отправить пакет сейчас.</p>
</div>
<div class="paragraph">
<p>На моей практике, сеть из 40-50 хостов на хабах работает ощутимо медленно.</p>
</div>
<div class="paragraph">
<p>Помимо проблемы со скоростью и коллизий, сеть на хабах небезопасна, так как позволяет прослушивать чужие пакеты.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_домен_коллизий">Домен коллизий</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Коллизия - это столкновение сигналов (пакетов) в сети. Происходит, когда два и более хоста одновременно отправляют данные в сеть.</p>
</div>
<div class="paragraph">
<p>Происходить коллизия может только в том случае, если в сети используется полудуплексное (half-duplex) подключение. Т.е. для приема и передачи пакета используется один и тот же физический канал.</p>
</div>
<div class="paragraph">
<p>Домен коллизий - это такой сегмент сети, в котором может произойти коллизия.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_коммутатор_свитч">Коммутатор (свитч)</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Для решения проблемы с масштабируемостью и производительностью сети был предложен свитч.</p>
</div>
<div class="paragraph">
<p>Свитч (он же коммутатор) - активное сетевое оборудование, которое работает на втором уровне модели ISO/OSI. Т.е он уже может работать с Ethernet кадрами. Выглядит свитч так же как и хаб, небольшая коробка с портами.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="L2/switch/images/switch.png" alt="Свитч.">
</div>
<div class="title">Figure 32. Свитч.</div>
</div>
<div class="paragraph">
<p>Свитч - это поумневший хаб. Он пытается отправлять Ethernet пакеты в тот порт, куда подключен хост назначения.</p>
</div>
<div class="paragraph">
<p>Для примера снова будем использовать сеть из трех хостов, только сеть будет построена через свитч, как на рисунке ниже. Также, допустим, что хост 1 (host_1) подключен в порт 1 на свитче, хост 2 в порт 2, а хост 3 в порт 3.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="L2/switch/images/switch_example.png" alt="Сеть из 3-х хостов со свитчем. (https://miminet.ru/web_network?guid=6cfb1dc5-9c80-4083-a87b-ff96a51ad0bd)">
</div>
<div class="title">Figure 33. Сеть из 3-х хостов со свитчем. (<a href="https://miminet.ru/web_network?guid=6cfb1dc5-9c80-4083-a87b-ff96a51ad0bd" class="bare">https://miminet.ru/web_network?guid=6cfb1dc5-9c80-4083-a87b-ff96a51ad0bd</a>).</div>
</div>
<div class="paragraph">
<p>На канальном уровне все хосты используют MAC адрес (он же физический адрес). И он должен быть уникальный в рамках одного сегмента сети. Если вдруг в сети будет два хоста с одинаковым MAC адресом, то мы не можем однозначно сказать, какому хосту предназначаются данные. Допустим, в нашей сети хосты имеют следующие MAC адреса:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>host_1 &#8594; 00:00:00:00:00:01</p>
</li>
<li>
<p>host_2 &#8594; 00:00:00:00:00:02</p>
</li>
<li>
<p>host_3 &#8594; 00:00:00:00:00:03</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Во время работы, свитч запоминает MAC адреса отправителей в специальной таблице под названием таблица коммутации. Обратите внимание, свитч не запоминает MAC адреса получателя, только отправителя.</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">MAC адрес</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">Порт</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>Таблица коммутации состоит из двух колонок:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>MAC адрес</p>
</li>
<li>
<p>Номер порта, к которому подключен хост с данным MAC адресом.</p>
</li>
</ul>
</div>
<div class="sect2">
<h3 id="_алгоритм_работы_свитча">Алгоритм работы свитча</h3>
<div class="paragraph">
<p>Пусть в нашем случае, хост 1 отправит пакет хосту 2. Алгоритм работы свитча следующий:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Изначально, как только свитч включают, его таблица коммутации пустая.</p>
</li>
<li>
<p>Когда на свитч приходит пакет, он записывает в таблицу MAC адрес отправителя и номер порта, который принял этот кадр из сети. Т.е в нашем случае на порт 1 приходит Ethernet кадр с MAC адресом отправителя 00:00:00:00:00:01 и в таблицу коммутации добавляется запись:</p>
<div class="openblock">
<div class="content">
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">MAC адрес</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">Порт</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">00:00:00:00:00:01</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">1</p></td>
</tr>
</tbody>
</table>
</div>
</div>
</li>
<li>
<p>Дальше свитч пытается отправить пакет в тот порт, куда подключен получатель. Для этого он достает из Ethernet пакета MAC адрес получателя (00:00:00:00:00:02) и ищет его в своей таблице коммутации. В нашем случае, такого адреса в таблице коммутации нет. В этом случае свитч работает как хаб, отправляет пакет во все остальные подключенные порты. Т.е. в порт 2 и 3.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>А теперь, пусть хост 2 отправит пакет хосту 1:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Когда на свитч придет пакет от хоста 2, он добавит запись в свою таблицу коммутации:</p>
<div class="openblock">
<div class="content">
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">MAC адрес</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">Порт</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">00:00:00:00:00:01</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">1</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">00:00:00:00:00:02</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">2</p></td>
</tr>
</tbody>
</table>
</div>
</div>
</li>
<li>
<p>Свитч снова пытается отправить пакет в тот порт, куда подключен получатель. В нашем случае, MAC адрес получателя будет 00:00:00:00:00:01. Свитч ищет его в таблице коммутации и находит. Запись гласит, что хост с MAC адресом 00:00:00:00:00:01 подключен к первому порте. Именно туда свитч и отправит пакет.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>Как не сложно догадаться, если хост 1 отправит пакет хосту 3, то свитч отправит этот пакет в порт 2 и 3. Так как информации про MAC адрес 00:00:00:00:00:03 в таблице коммутации нет.</p>
</div>
</div>
<div class="sect2">
<h3 id="_режим_работы_коммутатора">Режим работы коммутатора</h3>
<div class="paragraph">
<p>Коммутаторы могут работать в двух режимах:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Store-and-Forward - комммутатор помещает полученный кадр в буфер перед обработкой.</p>
</li>
<li>
<p>Cut-through - коммутатор проводит обработку пакета налету.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_часто_задаваемые_вопросы">Часто задаваемые вопросы</h3>
<div class="paragraph">
<p><strong>Вопрос 1</strong>: Может ли в таблице коммутации на одном порте быть несколько MAC адресов?</p>
</div>
<div class="paragraph">
<p><strong>Ответ</strong>: Да, конечно. Например, если в порт свитча мы подключили другой свитч или хаб с несколькими хостами, как показано на рисунке. В этом случае, на порте свитча, куда подключен хаб, может быть записаны MAC адреса хоста 2 и хоста 3.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="L2/switch/images/qa1.png" alt="В свитч подключен хаб (https://miminet.ru/web_network?guid=d5eb566d-402e-442f-a98a-d5341568a5c9)">
</div>
<div class="title">Figure 34. В свитч подключен хаб (<a href="https://miminet.ru/web_network?guid=d5eb566d-402e-442f-a98a-d5341568a5c9" class="bare">https://miminet.ru/web_network?guid=d5eb566d-402e-442f-a98a-d5341568a5c9</a>).</div>
</div>
<div class="paragraph">
<p><strong>Вопрос 2</strong>: Допустим наша текущая таблица коммутации как показано в таблице 5. И свитч получает на порт 2 пакет, где MAC адрес отправителя такой же - 00:00:00:00:00:01. Как поведет себя свитч в данной ситуации?</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">MAC адрес</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">Порт</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">00:00:00:00:00:01</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">1</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p><strong>Ответ</strong>: Как мы говорили раннее, в одном сегменте сети MAC адреса должны быть уникальными. С этой позиции исходит и свитч. Если он получает пакет на порт и выясняется, что MAC адрес отправителя этого пакета уже есть в таблице коммутации, но на другом порте, то такая запись удаляется. А вместо нее свитч добавляет новую, с текущим портом. Т.е. таблица коммутации будет выглядеть как в таблице ниже.</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">MAC адрес</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">Порт</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">00:00:00:00:00:01</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">2</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p><strong>Вопрос 3</strong>: Если какой-нибудь хост в сети будет отправлять пакеты с таким MAC адресом получателя, которого нет в сети, то свитч всегда будет его отправлять по всем портам, как хаб?</p>
</div>
<div class="paragraph">
<p><strong>Ответ</strong>: Да, это так. И администраторы сети не любят таких пользователей.</p>
</div>
<div class="paragraph">
<p><strong>Вопрос 4</strong>: Что произойдет, если в сети будет 2 хоста с одинаковыми MAC адресами?</p>
</div>
<div class="paragraph">
<p><strong>Ответ</strong>: В этом случае, по мере того, как хосты с одинаковыми MAC адресами будут отправлять пакеты в сети, свитч будет переписывать MAC адрес то для одного, то для другого порта. Это приведет к тому, что часть пакетов, которые будет предназначаться для этого MAC адреса будет приходить для одного хоста. А другая часть пакетов придет второму хосту.</p>
</div>
<div class="paragraph">
<p><strong>Вопрос 5</strong>: Что будет, если свитчи или хабы замкнуть в кольцо?</p>
</div>
<div class="paragraph">
<p><strong>Ответ</strong>: Ethernet не любит кольца. Если сеть будет состоять из хабов, то каждый новый пакет будет бесконечно передаваться от одного хаба к другому, как показано на рисунке. И очень быстро все каналы передачи данных будут полностью загружены, что приведет к невозможности отправлять новые пакеты в сеть. Даже если будут использованы свитчи.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="L2/switch/images/qa5.png" alt="Кольцо в Ethernet. (https://miminet.ru/web_network?guid=c81180f8-1c01-484e-bed0-05ea09da3f90)">
</div>
<div class="title">Figure 35. Кольцо в Ethernet. (<a href="https://miminet.ru/web_network?guid=c81180f8-1c01-484e-bed0-05ea09da3f90" class="bare">https://miminet.ru/web_network?guid=c81180f8-1c01-484e-bed0-05ea09da3f90</a>).</div>
</div>
</div>
<div class="sect2">
<h3 id="_домен_коллизии_у_свитча">Домен коллизии у свитча</h3>
<div class="paragraph">
<p>Свитч работает на втором уровне модели OSI и может обрабатывать не просто голый сигнал, а целый Ethernet пакет. Для обработки этот пакет необходимо хранить во внутренней памяти свитча.</p>
</div>
<div class="paragraph">
<p>Обладая оперативной памятью свитч имеет буферы для отправки пакетов. Если на два разных порт, например на порт 1 и 2 одновременно поступят пакеты. То это не вызовет коллизию, как в случае с хабом. Свитч положит эти пакеты к себе в оперативную память, потом решит, в какой порт их необходимо отправить и разместит их в буфере не отправку.</p>
</div>
<div class="paragraph">
<p>Свитч ограничивает домен коллизий до хоста и порта, к которому тот подключен. На рисунке изображены 3 домена коллизий.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="L2/switch/images/switch_collision_domain.png" alt="Домен коллизий при свитче (https://miminet.ru/web_network?guid=d5eb566d-402e-442f-a98a-d5341568a5c9)">
</div>
<div class="title">Figure 36. Домен коллизий при свитче (<a href="https://miminet.ru/web_network?guid=d5eb566d-402e-442f-a98a-d5341568a5c9" class="bare">https://miminet.ru/web_network?guid=d5eb566d-402e-442f-a98a-d5341568a5c9</a>).</div>
</div>
<div class="paragraph">
<p>Если соединения от хоста 1 и хоста 4 полнодуплексные (full-duplex), то там доменов коллизий и вовсе нет. Как мы помним, коллизии могут существовать только в полудуплексных (half-duplex) соединениях.</p>
</div>
</div>
<div class="sect2">
<h3 id="_свитч_у_вас_дома">Свитч у вас дома</h3>
<div class="paragraph">
<p>У многих из вас дома или на работе установлен Wi-Fi роутер, похожий на тот, что изображен на рисунке. Посмотрите на него внимательно. Порты для подключения по проводу работают как у коммутатора. Порты коммутатора на рисунке обозначены желтым цветом.</p>
</div>
<div class="paragraph">
<p>Синий порт - это порт роутера (WAN).</p>
</div>
<div class="imageblock">
<div class="content">
<img src="L2/switch/images/switch_at_home.jpeg" alt="Wi-Fi роутер">
</div>
<div class="title">Figure 37. Wi-Fi роутер.</div>
</div>
</div>
<div class="sect2">
<h3 id="_масштабируемость_технологии_канального_уровня">Масштабируемость технологии канального уровня</h3>
<div class="paragraph">
<p>Свитч действительно решил ряд проблем с масштабируемостью в Ethernet - избавился  от коллизий и оптимизировал передачу пакетов. На сколько большую сеть можно построить теперь?</p>
</div>
<div class="paragraph">
<p>В начале 2000-х годов в России были популярны домашние сети. Когда группа энтузиастов устанавливала где-то в квартире сетевое оборудование и объединяли свои компьютеры в сеть. А затем уже предлагали жителям дома подключиться к их домашней сети. Таким образом, появлялись домашние сети.</p>
</div>
<div class="paragraph">
<p>Как показала практика, даже использование свитчей не позволяло строить слишком большие сегменты сети. Примерно 100 хостов. Главной проблемой становились широковещательные пакеты. Время от времени, по разным причинам хост отправляет в сеть широковещательные пакеты, которые должны быть доставлены всем хостам в сети. Когда у вас 30-40 хостов, это терпимо. Но, когда хостов становится 100+, производительность сети начинает страдать.</p>
</div>
<div class="paragraph">
<p>С другой стороны, мир не ограничен технологией проводного Ethernet. Есть разные стандарты проводного Ethernet (IEEE 802.3 - <a href="https://ru.wikipedia.org/wiki/IEEE_802.3" class="bare">https://ru.wikipedia.org/wiki/IEEE_802.3</a>), беспроводной Ethernet (802.11), подключение по телефонной линии с использованием модема, а еще есть 3G, LTE и многие другие способы организации обмена данными между хостами. Как быть в этом случае?</p>
</div>
<div class="paragraph">
<p>Оказывается, вместо того, чтобы стремиться создавать один большой сегмент сети, намного проще создавать небольшие сегменты сети и объединять их. Хороший пример - это ваша домашняя сеть. С одной стороны домашние устройства, подключенные по Wi-Fi, с другой, со стороны провайдера - провод. Это два разных сегмента сети.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="L2/switch/images/2_segments.png" alt="Объединение сегментов сети.">
</div>
<div class="title">Figure 38. Объединение сегментов сети.</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_широковещательный_домен">Широковещательный домен</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Широковещательный домен - это группа доменов коллизий, соединенных с помощью устройств второго уровня (свитча). Иными словами, это участок компьютерной сети, в котором все узлы могут передавать данные друг другу с помощью широковещательного пакета (младший бит старшего байта MAC адреса назначения имеет значение 1) на канальном уровне сетевой модели OSI.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="ieee802/ethernet/broadcast/images/broadcast_domain.png" alt="Широковещательный домен">
</div>
<div class="title">Figure 39. Широковещательный домен.</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_что_такое_интернет_глобальная_сеть">Что такое Интернет (глобальная сеть)</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Интернет - это множество различных сетей, объединенных между собой.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="misc/internet/images/internet.png" alt="Интернет.">
</div>
<div class="title">Figure 40. Интернет.</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_сетевой_уровень_2">Сетевой уровень</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Технологии канального уровня позволяют нам создать сегмент сети и обмениваться в нем данными между хостами. Для идентификации хостов используются MAC адреса. Для объединения сегментов сетей используется сетевой уровень модели OSI.</p>
</div>
<div class="paragraph">
<p>Напомню, что сетевой уровень отвечает за доставку данных между хостами. При этом не важно, находятся эти хосты в одном сетевом сегменте, в соседних или между ними 10 000 км.</p>
</div>
<div class="paragraph">
<p>Если вы вдруг попытаетесь решить эту задачу на канальном уровне, то у вас возникнут большие проблемы. В частности, на какой адрес отправлять пакет? В Ethernet сетях MAC адрес размером в 6 байт (48 бит), а в других технологиях канального уровня он может быть меньше или больше.</p>
</div>
<div class="paragraph">
<p>Поэтому, для решения проблемы объединения сетей необходимо подняться выше канального уровня, т.е. на сетевой.</p>
</div>
<div class="paragraph">
<p>Сетевой уровень - это первый полностью программный уровень в модели OSI. Другими словами, он полностью не зависит от оборудования. Один и тот же сетевой уровень может успешно работать на проводном Ethernet, на Wi-FI, в 3G сетях и так далее.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_ip_адреса">IP адреса</h2>
<div class="sectionbody">
<div class="paragraph">
<p>В глобальной сети Интернет на сетевом уровне работает протокол IP (Internet Protocol), который описан в <a href="https://www.rfc-editor.org/rfc/rfc793">RFC 791</a>. А для адресации хостов используются IP адреса.</p>
</div>
<div class="paragraph">
<p>IP адрес представляет собой поле в 4 байта (32 бита) и обычно записывается как 4 десятичных числа разделенных точкой. Например:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>192.168.1.1</p>
</li>
<li>
<p>172.2.5.66</p>
</li>
<li>
<p>12.153.45.3</p>
</li>
<li>
<p>и так далее.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Каждое число соответствует 8 битам поля адреса, как показано на рисунке ниже.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="tcp_ip/ip_addr/images/ip_address.png" alt="Формат IP адреса. (https://www.expressvpn.com/ru/what-is-my-ip)">
</div>
<div class="title">Figure 41. Формат IP адреса. (<a href="https://www.expressvpn.com/ru/what-is-my-ip" class="bare">https://www.expressvpn.com/ru/what-is-my-ip</a>)</div>
</div>
<div class="paragraph">
<p>Поэтому, ни одно число в IP адресе не может быть более 255.</p>
</div>
<div class="paragraph">
<p>Если ваш компьютер  или ноутбук подключен к сети, то вы можете посмотреть ваш IP адрес. В ОС Windows  в командной  строке выполните команду ipconfig или ipconfig /all. В появившемся результате найдите свое сетевое подключение (у меня это Беспроводная сеть) и найдите строку “IPv4 адрес”. У меня это 192.168.0.107, как показано на рисунке ниже.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="tcp_ip/ip_addr/images/ip_windows.png" alt="IP адрес в Windows.">
</div>
<div class="title">Figure 42. IP адрес в Windows.</div>
</div>
<div class="paragraph">
<p>Если у вас MacOS или Linux, в консоли выполните команду ifconfig. На рисунке ниже представлен вывод команды ifconfig под MacOS. К сожалению, поиск нужного интерфейса может занять время, у меня он называется en0. А сам IP адрес указан в поле inet.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="tcp_ip/ip_addr/images/ip_macos.png" alt="IP адрес в MacOS.">
</div>
<div class="title">Figure 43. IP адрес в MacOS.</div>
</div>
<div class="paragraph">
<p>IP адрес - это уникальный глобальный идентификатор в рамках всей сети Интернет. Когда ваш хост хочет отправить пакет для какого-нибудь хоста, он отправляет его определенный IP адрес.</p>
</div>
<div class="paragraph">
<p>Давайте разберем на примере, как это происходит. Сделаем небольшую сеть, как показано на рисунке ниже, из 2-х хостов и 1 свитча. И назначим IP адреса:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>хост 1 - 10.0.0.1</p>
</li>
<li>
<p>хост 2 - 10.0.0.2</p>
</li>
</ul>
</div>
<div class="imageblock">
<div class="content">
<img src="tcp_ip/ip_addr/images/2_hosts.png" alt="Сеть из двух хостов. (https://miminet.ru/web_network?guid=d9012b77-fd52-48b0-b618-a3c3f55caf15)">
</div>
<div class="title">Figure 44. Сеть из двух хостов. (<a href="https://miminet.ru/web_network?guid=d9012b77-fd52-48b0-b618-a3c3f55caf15" class="bare">https://miminet.ru/web_network?guid=d9012b77-fd52-48b0-b618-a3c3f55caf15</a>)</div>
</div>
<div class="paragraph">
<p>Для отправки IP пакета воспользуемся утилитой ping. Эта утилита отправляет на указанный IP адрес специальный ICMP запрос, получив который хост должен отправить ICMP ответ. Если мы попробуем отправить пакет от хоста 1 на хост 2, то у хоста 1 возникнут проблемы с MAC адресом получателя.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="tcp_ip/ip_addr/images/mac_unknown.png" alt="Какой MAC адрес получателя?">
</div>
<div class="title">Figure 45. Какой MAC адрес получателя?</div>
</div>
<div class="paragraph">
<p>На сетевом уровне протоколом IP будет установлен:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>IP адрес отправителя (это наш IP адрес, мы его знаем)</p>
</li>
<li>
<p>IP адрес получателя, его мы указали аргументом для команды ping - это 10.0.0.2.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Далее пакет спускается на канальный уровень, где необходимо заполнить MAC адреса:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>MAC адрес отправителя мы знаем - это наш MAC</p>
</li>
<li>
<p>А вот какой ставить MAC адрес получателя?</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Мы не можем оставить это поле пустым, иначе, как хост поймет, что на канальном уровне пакет пришел для него, а не для кого-то другого. Задачу сопоставления MAC адреса по IP адресу решает ARP.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_протокол_arp">Протокол ARP</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Протокол ARP решает задачу сопоставления MAC адреса по IP адресу. ARP (Address Resolution Protocol) описан в <a href="https://datatracker.ietf.org/doc/html/rfc826">RFC 826</a>, в его задачу входит разрешение (т.е. узнать) MAC адрес по определенному IP адресу.</p>
</div>
<div class="paragraph">
<p>В иерархии протоколов, ARP инкапсулируется в Ethernet и работает в формате запрос-ответ, как изображено на рисунке. В ARP-запросе указывается искомый IP адрес, чей MAC адрес требуется найти. В ARP-ответе должен прийти искомый MAC адрес.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="tcp_ip/arp/protocol/images/arp_schema.png" alt="Схема работы ARP.">
</div>
<div class="title">Figure 46. Схема работы ARP.</div>
</div>
<div class="paragraph">
<p>ARP имеет следующий формат (рисунок ниже). Из множества полей наибольший интерес представляет:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>Sender hardware address (SHA)</strong> - MAC адрес отправителя.</p>
</li>
<li>
<p><strong>SPA</strong> - IP адрес отправителя</p>
</li>
<li>
<p><strong>THA</strong> - MAC адрес назначения</p>
</li>
<li>
<p><strong>TPA</strong> - IP адрес назначения</p>
</li>
</ul>
</div>
<div class="imageblock">
<div class="content">
<img src="tcp_ip/arp/protocol/images/arp_protocol.png" alt="Формат ARP.">
</div>
<div class="title">Figure 47. Формат ARP.</div>
</div>
<div class="paragraph">
<p>В нашем примере:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>поле SHA будет установлено в 00:00:00:00:00:01</p>
</li>
<li>
<p>поле SPA - 10.0.0.0.1</p>
</li>
<li>
<p>поле THA - 00:00:00:00:00:00 (т.е. пустое, так как именно MAC адрес мы и не знаем)</p>
</li>
<li>
<p>поле TPA - 10.0.0.0.2</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Так как хост отправителя не знает какому MAC адресу нужно отправить запрос, то на канальном уровне ARP-запрос имеет широковещательный адрес, т.е. в поле MAC адрес назначения устанавливается FF:FF:FF:FF:FF:FF. Таким образом, ARP-запрос обрабатывается всеми хостами, которые его получат.</p>
</div>
<div class="paragraph">
<p>Получив ARP-запрос хост сравнивает IP адрес назначения (TPA) со своим. Если у него нет такого IP адреса, то запрос игнорируется. Если у хоста оказался IP адрес назначения, он отправляет ARP-ответ, в котором указывает свой MAC адрес. В нашем примере ARP ответ будет выглядеть вот так:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>поле SHA будет установлено в 00:00:00:00:00:02</p>
</li>
<li>
<p>поле SPA - 10.0.0.0.2</p>
</li>
<li>
<p>поле THA - 00:00:00:00:00:01</p>
</li>
<li>
<p>поле TPA - 10.0.0.0.1</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Обратите внимание, что поля источника содержат информацию об отправителе. Если это ARP запрос, то в полях SHA и SPA будет отправитель ARP-запроса (00:00:00:00:00:01 и 10.0.0.1 соответственно). А если это ARP-ответ, то в полях SHA и SPA будет информация об отправителе ARP-ответа (00:00:00:00:00:02 и 10.0.0.2 соответственно).</p>
</div>
<div class="paragraph">
<p>Так как в ARP-запросе есть информация про MAC адрес отправителя, ARP-ответ уже не широковещательный, а отправляется на конкретный MAC адрес.</p>
</div>
<div class="paragraph">
<p>Запустим сеть по адресу <a href="https://miminet.ru/web_network?guid=d9012b77-fd52-48b0-b618-a3c3f55caf15" class="bare">https://miminet.ru/web_network?guid=d9012b77-fd52-48b0-b618-a3c3f55caf15</a> и посмотрим за ее работой. Первым делом мы видим, что хост 1 отправляет ARP-запрос (ARP-request), после получает ARP-ответ (ARP-response) и только потом уже отправляет ICMP пакеты.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="tcp_ip/arp/protocol/images/arp_example.png" alt="ARP запрос и ARP ответ.(https://miminet.ru/web_network?guid=d9012b77-fd52-48b0-b618-a3c3f55caf15).">
</div>
<div class="title">Figure 48. ARP запрос и ARP ответ. (<a href="https://miminet.ru/web_network?guid=d9012b77-fd52-48b0-b618-a3c3f55caf15" class="bare">https://miminet.ru/web_network?guid=d9012b77-fd52-48b0-b618-a3c3f55caf15</a>)</div>
</div>
<div class="paragraph">
<p>Таким образом ARP решает проблему связки сетевого и канального уровня. Возможно вы обратили внимание, что мы не изобразили место ARP в модели ISO/OSI. Это все потому, что непонятно, к какому уровню его отнести. С одной стороны он работает с IP адреса, т.е. знает про сетевой уровень. С другой стороны он работает с MAC адресами. Чтобы не вести бесконечные споры, ARP по модели ISO/OSI называют протокол уровня 2,5.</p>
</div>
<div class="sect2">
<h3 id="_arp_кэш">ARP кэш</h3>
<div class="paragraph">
<p>Отправлять ARP-запросы каждый раз, когда хост хочет отправить пакет в сеть не эффективно. Поэтому, у хостов есть специальная область памяти, куда они сохраняют ARP-ответы. Эта область памяти называется ARP кэш.</p>
</div>
<div class="paragraph">
<p>ARP кэш представляет собой таблицу из 3-х колонок, как на рисунке:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>IP адрес</p>
</li>
<li>
<p>MAC адрес</p>
</li>
<li>
<p>Тип записи</p>
</li>
</ul>
</div>
<div class="imageblock">
<div class="content">
<img src="tcp_ip/arp/protocol/images/arp_cache_windows.png" alt="ARP-кэш (Windows).">
</div>
<div class="title">Figure 49. ARP-кэш (Windows).</div>
</div>
<div class="paragraph">
<p>Вы можете посмотреть свой ARP-кэш при помощи команды <em>arp -a</em>. Она одинаково работает под Windows, Linux и MacOS.</p>
</div>
<div class="paragraph">
<p>Каждому IP адресу соответствует определенный MAC адрес. Как только хост через ARP протокол определил MAC адрес другого хоста, он заносит эту информацию к себе в ARP-кэш. Таким образом, при отправке последующих пакетов он сможет их отправлять сразу, без предварительного разрешения MAC адреса.</p>
</div>
<div class="paragraph">
<p>Третье поле в ARP-кэше, тип записи, бывает двух типов:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>динамический</p>
</li>
<li>
<p>статический</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Динамический тип означает, что запись была добавлена через работу ARP протокола и она должна быть удалена через определенное время. У каждой ОС есть свои временные промежутки, через которые запись в ARP-кэше динамическим типом будет удалена. Например, у ОС Windows это 30-45 секунд, при условии, что хост не будет пользоваться конкретной записью из ARP-кэша (<a href="https://learn.microsoft.com/en-us/troubleshoot/windows-server/networking/address-resolution-protocol-arp-caching-behavior" class="bare">https://learn.microsoft.com/en-us/troubleshoot/windows-server/networking/address-resolution-protocol-arp-caching-behavior</a>).</p>
</div>
<div class="paragraph">
<p>Статический тип означает, что запись была добавлена не через ARP протокол и должна быть в ARP-кэше до выключения ОС.</p>
</div>
<div class="paragraph">
<p>Каждый раз, когда ОС отправляет пакет в сеть, для правильного заполнения поля MAC адрес отправителя, она:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Ищет нужный IP адрес в ARP-кэш</p>
</li>
<li>
<p>Если нужного IP адреса нет в ARP-кэш, отправляет ARP-запрос</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>Для примера создайте в miminet сеть как на рисунке ниже:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>2 хоста соединим друг с другом</p>
</li>
<li>
<p>на хосте 1 установим IP адрес в 192.168.1.1 и маску в 24</p>
</li>
<li>
<p>на хосте 2 установим IP адрес в 192.168.1.2 и маску в 24</p>
</li>
<li>
<p>на хосте 1 выполните команду ping (1 пакет) и в качестве IP адреса назначения укажите 192.168.1.2</p>
</li>
<li>
<p>запустите эмуляцию</p>
</li>
<li>
<p>когда эмуляция закончится, запустите анимацию и посмотрите на пакеты. Первым делом вы увидите ARP-запрос и ARP-ответ, чтобы хост 1 мог узнать MAC адрес назначения.</p>
</li>
</ul>
</div>
<div class="imageblock">
<div class="content">
<img src="tcp_ip/arp/protocol/images/arp_example2.png" alt="Сеть из двух хостов" width="узнаем MAC адрес. (https://miminet.ru/web_network?guid=519a0153-a32a-4fb0-858e-b21d6ba3cca1).">
</div>
<div class="title">Figure 50. Сеть из двух хостов, узнаем MAC адрес. (<a href="https://miminet.ru/web_network?guid=519a0153-a32a-4fb0-858e-b21d6ba3cca1" class="bare">https://miminet.ru/web_network?guid=519a0153-a32a-4fb0-858e-b21d6ba3cca1</a>).</div>
</div>
<div class="paragraph">
<p>А теперь:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>добавьте на хосте 1 команду “Добавить запись в ARP-кэш”, как указано на рисунке 48а. В качестве IP адреса укажите 192.168.1.2, а MAC адрес поставьте 00:11:22:33:44:55 (или любой другой, где multicast бит равен 0, так как это будет  широковещательный адрес,и не 00:00:00:00:00:02, так как адрес хоста 2).</p>
</li>
<li>
<p>запустите эмуляцию</p>
</li>
<li>
<p>запустите анимацию и посмотрите, больше нет никаких ARP-запросов. Вместо этого хост 1 сразу отправляет ICMP пакет, так как MAC адрес для IP адреса 192.168.1.2 уже есть в ARP-кэш. Но, так как MAC адрес неверный, то хост 2 получив такой пакет отбрасывает его и никакого ICMP-ответа не генерируется, как это было до этого.</p>
</li>
</ul>
</div>
<div class="imageblock">
<div class="content">
<img src="tcp_ip/arp/protocol/images/arp_example3.png" alt="Добавление неверной записи в ARP-кэш. (https://miminet.ru/web_network?guid=1260c13a-0c6e-4859-9800-919ce1be576f).">
</div>
<div class="title">Figure 51. Добавление неверной записи в ARP-кэш.(<a href="https://miminet.ru/web_network?guid=1260c13a-0c6e-4859-9800-919ce1be576f" class="bare">https://miminet.ru/web_network?guid=1260c13a-0c6e-4859-9800-919ce1be576f</a>).</div>
</div>
</div>
<div class="sect2">
<h3 id="_беспричинный_arp_запрос">Беспричинный ARP-запрос</h3>
<div class="paragraph">
<p>Когда ОС назначает себе IP адрес, она хочет убедиться, что такого же IP адреса нет в ее сети. Ведь IP адреса должны быть уникальными. Для этого она отправляет ARP-запрос в сеть, в котором указывает в качестве IP адреса назначения свой IP адрес.</p>
</div>
<div class="paragraph">
<p>Если в сети уже есть хост с таким же IP адресом, то наш хост получит ARP-ответ. Таким образом он поймет, что в сети уже существует хост с таким IP и назначать его себе нельзя. Если у вас Windows, то вы увидите подобное сообщение, как на рисунке ниже.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="tcp_ip/arp/protocol/images/garp.png" alt="Windows обнаружил конфликт IP адресов.(https://windows-school.ru/blog/obnaruzhila_konflikt_ip_adresov/2021-12-14-826).">
</div>
<div class="title">Figure 52. Windows обнаружил конфликт IP адресов.(<a href="https://windows-school.ru/blog/obnaruzhila_konflikt_ip_adresov/2021-12-14-826" class="bare">https://windows-school.ru/blog/obnaruzhila_konflikt_ip_adresov/2021-12-14-826</a>).</div>
</div>
</div>
<div class="sect2">
<h3 id="_часто_задаваемые_вопросы_по_arp">Часто задаваемые вопросы по ARP</h3>
<div class="paragraph">
<p><strong>Вопрос 1</strong>: Что будет, если на ARP-запрос никто не ответит?</p>
</div>
<div class="paragraph">
<p><strong>Ответ</strong>: Отправив ARP-запрос, хост ожидает некоторый таймаут (примерно 1-3 секунды). Если за время таймаута хост не получил ARP-ответ, то он снова отправляет ARP-запрос. И так он делает 3 раза. После 3-й попытки хост сообщает протоколам более верхнего уровня о невозможности отправить пакет в сеть.</p>
</div>
<div class="paragraph">
<p><strong>Вопрос 2</strong>: Что будет, если хост получит 2 ARP-ответа сразу?</p>
</div>
<div class="paragraph">
<p><strong>Ответ</strong>: Обычно такое поведение зависит от реализации ARP-протокола. Некоторые ОС принимают только первый ARP-ответ, другие ОС могут принять ARP-ответ второй и даже в случае, когда хост не отправлял ARP-запрос.</p>
</div>
<div class="paragraph">
<p><strong>Вопрос 3</strong>: Если находясь в сети мой хост будет отправлять ARP-ответы в ответ на беспричинный ARP-запрос, тогда никто больше кроме меня не сможет назначить себе IP адрес?</p>
</div>
<div class="paragraph">
<p><strong>Ответ</strong>: Да, такое поведение сложно отследить и администраторы очень не любят таких людей.</p>
</div>
<div class="paragraph">
<p><strong>Вопрос 4</strong>: Если мой хост подделает ARP-ответ на ARP-запрос другого хоста и мой ARP-ответ придет первым на хост отправителя, это означает, что пакет, который предназначается для другого хоста придет ко мне?</p>
</div>
<div class="paragraph">
<p><strong>Ответ</strong>: Да, это называется атака ARP-spoofing.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_отправка_пакета_в_другой_сегмент_сети">Отправка пакета в другой сегмент сети</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Давайте рассмотрим ситуацию, как показано на рисунке ниже. У нас есть сеть из 3-х хостов, два их которых находятся в одном сегменте сети, а третий хост в другом. Оба сегмента сети соединяет маршрутизатор.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="tcp_ip/ip_networks/images/2_segments.png" alt="Хосты в разных сегментах сети. (https://miminet.ru/web_network?guid=8682ffde-135e-4e16-acd5-030d24dc4d59).">
</div>
<div class="title">Figure 53. Хосты в разных сегментах сети. (<a href="https://miminet.ru/web_network?guid=8682ffde-135e-4e16-acd5-030d24dc4d59" class="bare">https://miminet.ru/web_network?guid=8682ffde-135e-4e16-acd5-030d24dc4d59</a>)</div>
</div>
<div class="paragraph">
<p>Если хост 1 c IP адресом 10.0.0.1 захочет отправить пакет хосту 2 с IP адресом 10.0.0.2, то:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>хост 1 проверит, есть ли хост 2 в ARP-кэше</p>
</li>
<li>
<p>если нет, то отправит в сеть ARP-запрос</p>
</li>
<li>
<p>подождет ARP-ответ от хоста 2</p>
</li>
<li>
<p>отправит желаемый пакет хосту 2</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Это мы уже знаем. А еще мы говорили, что сетевой уровень и IP протокол в частности должен уметь доставлять пакеты от одного хоста к другому даже если хост назначения находится в другой сети. Если хост 1 захочет отправить пакет хосту 3 с IP адресом 172.16.0.3, что он должен сделать?</p>
</div>
<div class="paragraph">
<p>Глядя на схему не сложно догадаться, что хост 1 должен отправить пакет на маршрутизатор А, а тот в свою очередь отправит пакет на хост 3. Но хост 1 не видит этой схемы, у него нет информации о топологии сети и настройках всех хостов. Как он должен догадаться, что в этом случае он должен отправлять пакет на маршрутизатор А?</p>
</div>
<div class="paragraph">
<p>Для решения этой проблемы давайте заведем на хостах еще одну таблицу и назовем ее “Таблица маршрутизации”. Эта таблица будет состоять из 2-х полей:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>IP адрес назначения</p>
</li>
<li>
<p>IP адрес маршрутизатора</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Если IP адрес назначения находится в нашем сегменте сети, то в качестве IP адреса маршрутизатора будем выступать мы сами. А если IP адрес назначения будет находиться в другой сети, то IP адрес маршрутизатора будет IP адрес маршрутизатор.</p>
</div>
<div class="paragraph">
<p>Обновим нашу схему, как показано на рисунке ниже. Добавим 2 IP адреса для маршрутизатора А. Один для связи с одним сегментом сети, второй для связи со вторым сегментом сети. Т.е. IP 10.0.0.100 для связи с хостом 1 и хостом 2, а 172.16.0.100 для связи с хостом 3.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="tcp_ip/ip_networks/images/2_segments2.png" alt="Хосты в разных сегментах сети. (https://miminet.ru/web_network?guid=f536f79f-e533-4905-abcc-1846a8a407fb).">
</div>
<div class="title">Figure 54. Хосты в разных сегментах сети.(<a href="https://miminet.ru/web_network?guid=f536f79f-e533-4905-abcc-1846a8a407fb" class="bare">https://miminet.ru/web_network?guid=f536f79f-e533-4905-abcc-1846a8a407fb</a>)</div>
</div>
<div class="paragraph">
<p>Тогда таблица маршрутизации для хоста 1 будет выглядеть как на таблице.</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">IP адрес назначения</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">IP адрес маршрутизатора</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">10.0.0.2</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">10.0.0.1</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">172.16.0.3</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">10.0.0.100</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">10.0.0.100</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">10.0.0.1</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>Каждый раз, когда хост 1 будет отправлять пакет, он будет заглядывать в таблицу вмаршрутизации.</p>
</div>
<div class="paragraph">
<p>Если хост 1 захочет отправить пакет хосту 2 (чей IP 10.0.0.2), то:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>хост 1 ищет в таблице маршрутизации IP адрес 10.0.0.2. Этому адресу соответствует IP адрес маршрутизатора 10.0.0.1</p>
</li>
<li>
<p>та как IP адрес маршрутизатора совпадает с IP адресом самого хоста, значит он сам знает как доставить пакет по адресу 10.0.0.2 и передает этот пакет на канальный уровень</p>
</li>
<li>
<p>а дальше мы уже знаем: смотрим ARP-кэш, ARP-запрос, ARP-ответ и отправка пакета.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>А если хост 1 хочет  отправить пакет хосту 3 с IP адресом 172.16.0.3, то:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>хост 1 ищет в таблице маршрутизации IP адрес 172.16.0.3. Этому адресу соответствует IP адрес маршрутизатора 10.0.0.100</p>
</li>
<li>
<p>IP адрес маршрутизатора не совпадает с IP адресом хоста, значит, нужно отправить пакет маршрутизатору с IP адреса 10.0.0.100 и пусть он дальше доставляет пакет</p>
</li>
<li>
<p>передаем пакет на канальный уровень с указанием, что MAC адрес назначения будет MAC адрес хоста с IP адресом 10.0.0.100 (это маршрутзатор). Очень важный момент, хоть IP адрес назначения в данном случае 172.16.0.3, но на канальном уровне мы доставляем пакет на маршрутизатор, как показано на рисунке ниже.</p>
</li>
</ul>
</div>
<div class="imageblock">
<div class="content">
<img src="tcp_ip/ip_networks/images/arp2router.png" alt="Доставка пакета на сетевом уровне на хост 3" width="но на канальном уровне на маршрутизатор А.">
</div>
<div class="title">Figure 55. Доставка пакета на сетевом уровне на хост 3, но на канальном уровне на маршрутизатор А.</div>
</div>
<div class="ulist">
<ul>
<li>
<p>и теперь начинается знакомый нам процесс, хост 1 смотрит в ARP-кэш в поисках MAC адреса для IP 10.0.0.100 (router_A).</p>
</li>
<li>
<p>если его там нет, то отправляет ARP-запрос, после получения ARP-ответа отправляет пакет в сеть</p>
</li>
<li>
<p>маршрутизатор А получив пакет смотрит уже в свою таблицу маршрутизации и так же как и хост 1 пытается понять куда дальше отправлять пакет.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Таким образом, используя таблицу маршрутизации хост может понять, как отправлять пакет - самому или на маршрутизатор.</p>
</div>
<div class="paragraph">
<p>Важно запомнить, что таблица маршрутизации находится на каждом хосте, который подключен к сети Интернет. А не только на маршрутизаторе. Без таблицы маршрутизации хост не поймет, когда он может сам доставить пакет, а когда нужно передать его на маршрутизатор.</p>
</div>
<div class="sect2">
<h3 id="_ip_сети">IP сети</h3>
<div class="paragraph">
<p>Давайте добавим в наш пример еще несколько хостов, как на рисунке ниже.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="tcp_ip/ip_networks/images/5_hosts.png" alt="Сеть из 5 хостов, 2х свитчей и 1 маршрутизатора. (https://miminet.ru/web_network?guid=7714de3c-1b74-4e3e-a33e-665662d71713).">
</div>
<div class="title">Figure 56. Сеть из 5 хостов, 2-х свитчей и 1 маршрутизатора. (<a href="https://miminet.ru/web_network?guid=7714de3c-1b74-4e3e-a33e-665662d71713" class="bare">https://miminet.ru/web_network?guid=7714de3c-1b74-4e3e-a33e-665662d71713</a>).</div>
</div>
<div class="paragraph">
<p>Получается, что для такой сети таблица маршрутизации на хосте 1 должна стать как в таблице ниже</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">IP адрес назначения</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">IP адрес маршрутизатора</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">10.0.0.2</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">10.0.0.1</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">10.0.0.5</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">10.0.0.1</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">10.0.0.100</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">10.0.0.1</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">172.16.0.3</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">10.0.0.100</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">172.16.0.4</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">10.0.0.100</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>Т.е. мы добавили в сеть два хоста и теперь хост 1 должен о них как-то узнать и добавить их в свою таблицу маршрутизации. А если мы добавим еще 100 хостов, что тогда? Владельцы всех хостов должны как-то обмениваться информацией о том, кто и куда подключен и своим IP адресом?!</p>
</div>
<div class="paragraph">
<p>Описанный выше способ доставки пакетов из одной сети в другую хоть и рабочий, но не эффективный. Большую сеть так не построить. Для решения этой проблемы предлагается ввести понятие IP сеть. IP сеть - это множество IP адресов. Очень важно обратить внимание, что множество IP адресов, а не хостов.</p>
</div>
</div>
<div class="sect2">
<h3 id="_классовая_адресация_сетей">Классовая адресация сетей</h3>
<div class="paragraph">
<p>Исторически, весь диапазон IP адресов (т.е все 4 байта) разбили на 5 классов сетей (A, B, C, D, E). Это означало, что одна часть IP адреса теперь указывает на класс сети, а остальная часть идентифицирует хост.</p>
</div>
<div class="paragraph">
<p><strong>Сети класса А</strong> лежат в диапазоне от 0.0.0.0 до 127.255.255.255. Для идентификатора сети используется 1 байт, а остальные 3 байта для идентификации хоста.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="tcp_ip/ip_networks/images/class_a.png" alt="Сеть класса А.">
</div>
<div class="title">Figure 57. Сеть класса А.</div>
</div>
<div class="paragraph">
<p>В одной сети класса А может находиться до 16 777 215 (256 * 256 * 256) хостов. Правда, таких сетей не много, всего 128. Вот пример некоторых сетей класса А:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>8.0.0.0	- 8.255.255.255</p>
</li>
<li>
<p>10.0.0.0 - 10.255.255.255</p>
</li>
<li>
<p>104.0.0.0 - 104.255.255.255</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><strong>Сети класса B</strong> лежат в диапазоне от 128.0.0.0 до 191.255.255.255. Для идентификатора сети используется первые два байта, а остальные 2 байта для идентификации хоста.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="tcp_ip/ip_networks/images/class_b.png" alt="Сеть класса B.">
</div>
<div class="title">Figure 58. Сеть класса B.</div>
</div>
<div class="paragraph">
<p>В одной сети класса B может находиться до 65 535 (256 * 256) хостов. Вот пример некоторых сетей класса B:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>169.254.0.0 - 169.254.255.255</p>
</li>
<li>
<p>172.16.0.0 - 172.16.255.255</p>
</li>
<li>
<p>190.56.0.0 - 190.56.255.255</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><strong>Сети класса C</strong> лежат в диапазоне от 192.0.0.0 до 223.255.255.255. Для идентификатора сети используется первые 3 байта, а оставшийся бай для идентификации хоста.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="tcp_ip/ip_networks/images/class_c.png" alt="Сеть класса C.">
</div>
<div class="title">Figure 59. Сеть класса C.</div>
</div>
<div class="paragraph">
<p>В одной сети класса C может находиться всего 255 хостов. Вот пример некоторых сетей класса С:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>192.168.1.0 - 192.168.1.255</p>
</li>
<li>
<p>204.16.6.0 - 204.16.6.255</p>
</li>
<li>
<p>220.215.65.0 - 220.215.65.255</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><strong>Сеть класса D</strong> от 224.0.0.0 до 239.255.255.255. Класс D - это одна сеть и ее адреса используется для групповых адресов. Часто, IP адреса из этого класса назначают себе принтеры, сканеры, маршрутизаторы и другие устройства работающие по сети. Дальше по курсу мы подробно об этом поговорим. А пока просто запомним, что это групповые адреса.</p>
</div>
<div class="paragraph">
<p><strong>Сеть класса E</strong> от 240.0.0.0 до 255.255.255.255. Класс E - зарезервирована "для использования в будущем" (<a href="https://www.iana.org/assignments/ipv4-address-space/ipv4-address-space.txt" class="bare">https://www.iana.org/assignments/ipv4-address-space/ipv4-address-space.txt</a>). Ее можно было бы начать использовать, но многие реализации TCP/IP не умеют или не хотят работать с IP из этого блока. Переписать все реализации TCP/IP в мире - это слишком большая проблема, а в свете активно внедряемого IPv6, задача становится еще менее реалистичной. Поэтому, эта сеть не используется и вряд ли когда-либо будет использоваться в глобальной сети в будущем.</p>
</div>
<div class="paragraph">
<p>Благодаря классовой адресации любой хост теперь мог четко ответить на вопрос, IP адрес, на который я хочу отправить пакет находится в моей сети или нет?</p>
</div>
<div class="paragraph">
<p>Вернемся к нашей сети (для удобства я ее повторил).</p>
</div>
<div class="imageblock">
<div class="content">
<img src="tcp_ip/ip_networks/images/5_hosts.png" alt="Сеть из 5 хостов, 2х свитчей и 1 маршрутизатора. (https://miminet.ru/web_network?guid=7714de3c-1b74-4e3e-a33e-665662d71713).">
</div>
<div class="title">Figure 60. Сеть из 5 хостов, 2-х свитчей и 1 маршрутизатора. (<a href="https://miminet.ru/web_network?guid=7714de3c-1b74-4e3e-a33e-665662d71713" class="bare">https://miminet.ru/web_network?guid=7714de3c-1b74-4e3e-a33e-665662d71713</a>).</div>
</div>
<div class="paragraph">
<p>Используя классовую адресацию наша таблица маршрутизации на хосте 1 будет выглядеть как в таблице ниже.</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">IP адрес назначения</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">IP адрес маршрутизатора</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">10.0.0.0</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">10.0.0.1</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">172.16.0.0</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">10.0.0.100</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>Если адрес назначения находится в сети 10.0.0.0 (напомню, это класс A и адреса в этой сети лежат в диапазоне от 10.0.0.0 до 10.255.255.255), то адрес маршрутизатора 10.0.0.1, т.е. мы сами будем доставлять пакет на этот хост.</p>
</div>
<div class="paragraph">
<p>А если адрес назначения находится в сети 172.16.0.0 (это класс B и адреса для этой сети лежат в диапазоне от 172.16.0.0 до 172.16.255.255), то адрес маршрутизатора 10.0.0.100.</p>
</div>
<div class="paragraph">
<p>Таким образом, даже если завтра мы добавим 1000 новых хостов в обе сети, то для хоста 1 ничего менять не придется. Он так же успешно сможет доставлять пакеты как внутри своей IP сети, так и для сети 172.16.0.0. И никаких новых записей в таблицу маршрутизации вводить не придется.</p>
</div>
<div class="paragraph">
<p>Проблема классовой адресации заключалась в ее негибкости. Если вам нужна сеть из 4000 IP адресов, что делать? Получать 16 сетей класса C или брать одну класса B? А если вам нужна сеть из 40 000 IP адресов? Хорошо, для 40 000 адресов возьмем одну сеть класса B. Как известно, сеть класса B содержит 65535 адресов, а нам нужно только 40 000. куда девать остальные 25 535, а это более 50% от того, что мы будем использовать?</p>
</div>
<div class="paragraph">
<p>Итог - классовая маршрутизация классная, решает возникшие проблемы, но не эффективная.</p>
</div>
<div class="paragraph">
<p>Зачем, что в профессиональном общении довольно часто можно услышать использование терминов из классовой адресации, что-то типа “Возьми себе сеть класса C и играйся там”. Теперь понятно, что под этим понимается.</p>
</div>
</div>
<div class="sect2">
<h3 id="_бесклассовая_адресация_сетей">Бесклассовая адресация сетей</h3>
<div class="paragraph">
<p>Бесклассовая адресация  (англ. Classless Inter-Domain Routing, англ. CIDR) - метод IP-адресации, позволяющий гибко управлять пространством IP-адресов. Бесклассовая адресация предлагает вместо жестко закрепленных правил адресации сети использовать маску подсети. Цель маски подсети сказать, какие биты в IP адресе указывают на идентификатор сети, а какие биты указывают на идентификатор хоста.</p>
</div>
<div class="paragraph">
<p>Для примера давайте рассмотрим уже знакомую нам IP сеть класса B 172.16.0.0. В этой сети первые 2 байта IP адреса указывают на идентификатор сети, а следующие два байта указывают на идентификатор хоста.</p>
</div>
<div class="paragraph">
<p>А теперь давайте запишем точно такую же сеть в бесклассовой адресации. Помимо IP адреса нам понадобится еще маска подсети (маска, маска сети, маска подсети - это все одно и тоже). Адрес сети будет прежний, 172.16.0.0, а маска подсети будет 255.255.0.0.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="tcp_ip/ip_networks/images/subnet_mask.png" alt="Запись IP сети с использованием маски.">
</div>
<div class="title">Figure 61. Запись IP сети с использованием маски.</div>
</div>
<div class="paragraph">
<p>Там, где бит у маски подсети установлен в 1, означает, что соответствующий бит в IP адресе указывает на идентификатор сети. А там, где бит у маски подсети  установлен в 0, означает, что соответствующий бит в IP адресе указывает на идентификатор хоста. Так как в нашей сети первые два байта (16 бит) указывают на идентификатор сети, то и первые 16 бит маски подсети должны быть установлены в 1. В десятичной записи 8 бит установленных в 1 дают число 255. Поэтому первые два байта нашей маски 255.255.</p>
</div>
<div class="paragraph">
<p>С идентификатором хоста делаем так же. В нашей сети для идентификации хоста выделены вторые 2 байта. Значит это место в маске мы заполняем 0.</p>
</div>
<div class="paragraph">
<p>Таким образом, сеть класса B 172.16.0.0 можно записать в бесклассовой адресации как 172.16.0.0/255.255.0.0. Обычно маска подсети записывается через слеш (/) после IP адреса сети.</p>
</div>
<div class="paragraph">
<p><strong>Как это работает?!</strong> Чтобы определить, попадает ли IP адрес в сеть 172.16.0.0 c маской 255.255.0.0 мы делаем следующее:
1.	Берем IP адрес, например, 172.16.0.3
2.	Делаем операцию “побитовое И” с маской подсети
3.	Полученный результат сравниваем с адресом сети
4.	Если результат равен адресу сети, значит IP адрес принадлежит этой сети
5.	Если нет, то и нет.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="tcp_ip/ip_networks/images/bitwise_and.png" alt="Определение принадлежности IP адреса к заданной IP сети.">
</div>
<div class="title">Figure 62. Определение принадлежности IP адреса к заданной IP сети.</div>
</div>
<div class="paragraph">
<p>В нашем случае, IP адрес 172.16.0.3 принадлежит сети 172.16.0.0/255.255.0.0, так как после применения маски подсети мы получили адрес сети 172.16.0.0.</p>
</div>
<div class="paragraph">
<p>Если мы возьмем IP адрес 172.16.126.254 и тоже применим к нему маску 255.255.0.0, то в результат получим 172.16.0.0. Что будет указывать на то, что и этот IP адрес принадлежит сети 172.16.0.0.</p>
</div>
<div class="paragraph">
<p>По сути, там где у маски подсети стоит бит в 1 означает, что соответствующий бит в IP адресе останется таким, каким и был. А там, где у маски подсети стоит бит 0 означает, что соответствующий бит в IP адресе обнулится. Был он 1 или 0, неважно, он станет 0.</p>
</div>
<div class="paragraph">
<p>А теперь давайте возьмем IP адрес 172.13.0.3 и применим маску 255.255.0.0. В итоге получится 172.13.0.0, что не равно 172.16.0.0. Значит, IP адрес 172.13.0.3 не принадлежит сети 172.16.0.0.</p>
</div>
<div class="paragraph">
<p>Таким образом, с помощью маски можно задавать IP сеть. Единственное ограничение, что количество хостов в сети должно быть кратно степени 2: 2, 4, 8, 16 и так далее. Но на практике этого вполне достаточно.</p>
</div>
</div>
<div class="sect2">
<h3 id="_способы_записи_ip_сети">Способы записи IP сети</h3>
<div class="paragraph">
<p>Обычно, маску подсети записывают через слеш от адреса сети. Например, 10.0.0.0/255.0.0.0 или 172.16.0.0/255.255.0.0.</p>
</div>
<div class="paragraph">
<p>Когда только предложили использовать маску подсети для обозначения IP сети, то она могла быть любой. Даже вот такой 255.255.0.255. Особенность такой маски в том, что она позволяет задать множество IP адресов с так называемыми дырками. Для примера, возьмем вот такую сеть 192.168.0.2/255.255.0.255. В эту сеть будут входить следующие IP адреса:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>192.168.0.2</p>
</li>
<li>
<p>192.168.1.2</p>
</li>
<li>
<p>192.168.2.2</p>
</li>
<li>
<p>192.168.3.2</p>
</li>
<li>
<p>…</p>
</li>
<li>
<p>192.168.255.2</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Хоть в теории это очень гибко, на практике сетевые администраторы использовали только маски, которые давали бы непрерывный диапазон. Например:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>192.168.2.0/255.255.255.0</p>
</li>
<li>
<p>169.254.143.128/255.255.255.128.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Поэтому, со временем ввели правило, которое гласило, что маска подсети не может содержать подпоследовательность в битах 01. Т.е. уже не получится сделать маску 255.255.0.255, так как после 0 последовали бы 1, а так делать нельзя.</p>
</div>
<div class="paragraph">
<p>А раз нельзя делать подпоследовательность 01, значит мы можем просто сказать количество единичных бит в маске и она будет однозначно понята всеми. Друигми словами, маску 255.255.255.0 теперь можно записать как 24, а маску 255.0.0.0 как 8. И получается, что сеть 192.168.1.0/255.255.255.0 теперь можно записать как 192.168.1.0/24, а сеть 172.16.0.0/255.255.0.0 как 172.16.0.0/16.</p>
</div>
<div class="paragraph">
<p>Теперь становится понятно, что означает /24 на примерах. На рисунке 60 хост 1 имеет IP 10.0.0.1 и маску 24 означает, что хост 1 имеет IP 10.0.0.1, который принадлежит IP сети 10.0.0.0/24 (а это 10.0.0.0 - 10.0.0.255)</p>
</div>
<div class="imageblock">
<div class="content">
<img src="tcp_ip/ip_networks/images/5_hosts.png" alt="Сеть из 5 хостов, 2х свитчей и 1 маршрутизатора. (https://miminet.ru/web_network?guid=7714de3c-1b74-4e3e-a33e-665662d71713).">
</div>
<div class="title">Figure 63. Сеть из 5 хостов, 2-х свитчей и 1 маршрутизатора. (<a href="https://miminet.ru/web_network?guid=7714de3c-1b74-4e3e-a33e-665662d71713" class="bare">https://miminet.ru/web_network?guid=7714de3c-1b74-4e3e-a33e-665662d71713</a>).</div>
</div>
</div>
<div class="sect2">
<h3 id="_широковещательный_адрес_в_ip_сети">Широковещательный адрес в IP сети</h3>
<div class="paragraph">
<p>В каждой IP сети есть два особых адреса, это самый первый и самый последний. Например, возьмем IP сеть 192.168.1.0/24.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Самый первый адрес в этой сети это 192.168.1.0, его называют адресом сети. Это тот самый адрес, который будет получаться, если взять любой адрес из этой сети и наложить на него маску (выполнить побитовое И). Например, возьмем 192.168.1.25/24, как показано на рисунке, в результате мы получим 192.168.1.0</p>
</li>
</ul>
</div>
<div class="imageblock">
<div class="content">
<img src="tcp_ip/ip_networks/images/network_addr.png" alt="Определение адреса сети по IP адресу и маски.">
</div>
<div class="title">Figure 64. Определение адреса сети по IP адресу и маски.</div>
</div>
<div class="ulist">
<ul>
<li>
<p>Самый последний адрес в этой сети это 192.168.1.255, он является широковещательным адресом для этой сети. Это означает, что все хосты в этой IP сети будут принимать и обрабатывать пакет, если такой IP адрес будет указан в качестве назначения. Другими словами, если хост хочет отправить пакет всем хостам в своей IP сети, он может отправить его на широковещательный адрес. Кстати говоря, самый последний адрес в сети это такой адрес, в котором биты отведенные под идентификацию хоста установлены в 1.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Устанавливать себе в качестве IP адреса широковещательный адрес сети не стоит. Может быть ОС и позволит вам это сделать, но тогда ваш хост не сможет ни с кем обмениваться данными. Протоколы реализуются таким образом, чтобы не генерировать ответы, если адрес отправителя широковещательный. Например, если вы отправите ARP или другой IP пакет в сеть, где IP адрес отправителя будет широковещательным, вам никто не ответит. Это такая защита от наводнения сети пакетами (flooding).</p>
</div>
<div class="paragraph">
<p>Давайте на минуту представим, если бы так происходило. Тогда, отправив на любой хост IP пакет с широковещательным IP адресом отправителя, этот хост должен будет ему ответить. Отвечать он будет на широковещательный адрес, т.е. на сетевом уровне будет стоять широковещательный адрес и на канальном уровне будет стоять широковещательный адрес (FF:FF:FF:FF:FF:FF). Такой пакет будет доставлен всем хостам в данной сети. Хотя очевидно, что никакого смысла в этом не будет.</p>
</div>
<div class="paragraph">
<p>А вот устанавливать себе адрес сети (первый адрес) можно. Хотя в сложившейся сетевой практике так не поступают.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="tcp_ip/ip_networks/images/broadcast_addr.png" alt="Первый и последний адрес сети. (https://miminet.ru/web_network?guid=076f1ae4-1a6d-42fd-b8f5-9c09cdc4f930)">
</div>
<div class="title">Figure 65. Первый и последний адрес сети. (<a href="https://miminet.ru/web_network?guid=076f1ae4-1a6d-42fd-b8f5-9c09cdc4f930" class="bare">https://miminet.ru/web_network?guid=076f1ae4-1a6d-42fd-b8f5-9c09cdc4f930</a>).</div>
</div>
<div class="paragraph">
<p>Для примера сделаем сеть из 3-х хостов и возьмем IP сеть 192.168.1.0/24 как показано на рисунке:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Хосту 1 назначим первый IP адрес, т.е. адрес сети, 192.168.1.0/24</p>
</li>
<li>
<p>Хосту 2 назначим обычный IP адрес, пусть это будет 192.168.1.50/24</p>
</li>
<li>
<p>А хосту 3 назначим широковещательный IP адрес для этой сети, т.е. 192.168.1.255/24</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>А теперь на хосте 1 выполним поочередно две команды:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Команду ping на широковещательный адрес - ping -c 1 -b 192.168.1.255. Команда ping отправляет специальный ICMP-запрос, получив который, хост должен отправить ICMP-ответ. Мы добавим в команду ping опцию -c 1 (отправить только 1 пакет) и -b (разрешить отправку на широковещательный адрес).</p>
</li>
<li>
<p>Команду ping на IP адрес 192.168.1.50, т.е. на хост 2.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>Первым делом мы видим ICMP-запрос на широковещательный адрес. Оба хоста (2 и 3) получают этот пакет. На широковещательный запрос ICMP-ответ не отправляется. Однако, мы видим, что хост 3 пытается отправить ICMP-ответ, так как он интерпретирует этот адрес не как широковещательный, а как свой. Это проявляется в отправке ARP-запросов. На эти ARP-запросы никто не отвечает. Это связано с тем, что IP адрес отправителя широковещательный. Как мы говорили, на такие пакеты хосты не отвечают.</p>
</div>
<div class="paragraph">
<p>После этого мы видим, как хост 1 отправляет ARP-запрос, а после получения ARP-ответа от хоста 2, обменивается с ним ICMP-запросом и ICMP-ответом.</p>
</div>
<div class="paragraph">
<p>Итого, как я и сказал. Первый адрес сети является нормальным адресом и может быть использован в сети. Хотя, сложившаяся сетевая практика такова, что этот адрес стараются не использовать, для удобства администрирования. А вот последний адрес сети является широковещательным и его не нужно использовать в качестве адреса хоста.</p>
</div>
</div>
<div class="sect2">
<h3 id="_специальная_маска_32">Специальная маска /32</h3>
<div class="paragraph">
<p>Маска делит IP адрес на две части, одна часть - идентификатор сети, вторая часть - идентификатор хоста. Например, 192.168.1.0/24:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>первые три байта: 192.168.1 - идентификатор сети</p>
</li>
<li>
<p>последний байт - идентификатор хоста</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>А если мы запишем 192.168.1.25/32 - получается, что все 4 байта это адрес сети? Маска /32 означает конкретный IP адрес.</p>
</div>
</div>
<div class="sect2">
<h3 id="_интересная_маска_31">Интересная маска /31</h3>
<div class="paragraph">
<p>Еще есть интересная маска /31. Встречается она довольно редко. Маска /31 говорит, что для адресации хоста мы выделяем только последний бит. Для примера рассмотрим сеть 172.16.12.0/31, как на рисунке.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="tcp_ip/ip_networks/images/mask_31.png" alt="Маска /31.">
</div>
<div class="title">Figure 66. Маска /31.</div>
</div>
<div class="paragraph">
<p>Получается, что в этой сети всего два IP адреса:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>172.16.12.0</p>
</li>
<li>
<p>172.16.12.1</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Первый желательно не использовать, а второй широковещательный. Даже если мы будем использовать первый адрес (адрес сети), то второй все равно широковещательный. Получается IP сеть из 1 рабочего хоста. На первый взгляд, смысла в этом никакого. И в обычных сетях такую маску не встретить.</p>
</div>
<div class="paragraph">
<p>Однако, некоторое современное сетевое оборудование может поддерживать такие маски для построения сетей "точка-точка" из группы маршрутизаторов. Например, для построения сложных сетей в ЦОД (Центр обработки данных). Поддержка которой включается на оборудовании отдельно.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_обратная_петля_loopback">Обратная петля (Loopback)</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Из всех IP сетей можно выделить особенную IP сеть под названием обратная петля (Loopback). Обратная петля, это IP сеть 127.0.0.0/8 для локального использования на каждом отдельном хосте. Каждый хост в сети Интернет создает себе специальный виртуальный сетевой интерфейс и назначает ему не просто IP адрес 127.0.0.1 с маской 255.0.0.0, а целую сеть 127.0.0.0/8</p>
</div>
<div class="imageblock">
<div class="content">
<img src="tcp_ip/loopback/images/loopback.png" alt="Отправка пакета на интерфейс обратная петля.">
</div>
<div class="title">Figure 67. Отправка пакета на интерфейс обратная петля.</div>
</div>
<div class="paragraph">
<p>Все, что будет отправлено на обратную петлю прилетит обратно, как показано на рисунке выше.</p>
</div>
<div class="paragraph">
<p>Обычно этот интерфейс используется для локальной разработки сетевых приложений. Представьте, у вас нет подключения по сети, т.е. ваш сетевой интерфейс не подключен и у вашего хоста нет IP адреса. Или даже у вас нет сетевой карты. А вам нужно разрабатывать сетевое приложение, т.е. запустить сервер, клиент и отлаживать их взаимодействие. На какой IP адрес тогда обращаться для доступа к серверу и на какой IP сервер должен будет отвечать клиенту? Или на вашем хосте имеются уже рабочие приложения, которые обмениваются друг с другом данными используя сетевое подключение.</p>
</div>
<div class="paragraph">
<p>Чтобы все работало без привязки к тому, есть ли у вас сетевое подключение или нет, обычно используют сетевой интерфейс обратная петля.</p>
</div>
<div class="paragraph">
<p>Если у вас Linux или MacOS, то наберите в консоли ifconfig.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="tcp_ip/loopback/images/lo_linux.png" alt="Интерфейс lo - обратная петля под ОС Linux.">
</div>
<div class="title">Figure 68. Интерфейс lo - обратная петля под ОС Linux.</div>
</div>
<div class="paragraph">
<p>Под Windows он тоже есть, но не выводится командой ipconfig. Чтобы убедиться в его наличии, в консоли запустите команду ping 127.0.0.1. Вы должны увидеть вывод как на рисунке.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="tcp_ip/loopback/images/lo_ping.png" alt="Вывод команды ping 127.0.0.1 под ОС Windows.">
</div>
<div class="title">Figure 69. ИВывод команды ping 127.0.0.1 под ОС Windows.</div>
</div>
<div class="paragraph">
<p>Вы можете вместо 127.0.0.1 написать 127.123.127.54 или любой другой IP адрес из IP сети 127.0.0.0/8. Все будет работать, как под ОС Windows, так и под ОС Linux.</p>
</div>
<div class="paragraph">
<p>Пакета с IP адресом отправителя или получателя из IP сети 127.0.0.0/8 в физической сети быть не может.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_маршрут_по_умолчанию">Маршрут по умолчанию</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Давайте вернемся к нашей сети из 5 хостов и двух сетей, как на рисунке ниже.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="tcp_ip/routing/default_route/images/5_hosts.png" alt="Сеть из 5 хостов, 2х свитчей и 1 маршрутизатора. (https://miminet.ru/web_network?guid=7714de3c-1b74-4e3e-a33e-665662d71713).">
</div>
<div class="title">Figure 70. Сеть из 5 хостов, 2-х свитчей и 1 маршрутизатора. (<a href="https://miminet.ru/web_network?guid=7714de3c-1b74-4e3e-a33e-665662d71713" class="bare">https://miminet.ru/web_network?guid=7714de3c-1b74-4e3e-a33e-665662d71713</a>).</div>
</div>
<div class="paragraph">
<p>Раньше, используя классовую адресацию, наша таблица маршрутизации на хосте 1 выглядела как в таблице ниже.</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">IP адрес назначения</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">IP адрес маршрутизатора</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">10.0.0.0</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">10.0.0.1</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">172.16.0.0</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">10.0.0.100</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>Но теперь мы знаем про бесклассовую адресацию и давайте перепишем таблицу маршрутизации для хоста 1. Выглядеть она будет как в таблице.</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">IP адрес назначения</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">IP адрес маршрутизатора</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">10.0.0.0/24</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">10.0.0.1</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">172.16.0.0/24</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">10.0.0.100</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>А теперь давайте добавим еще один сегмент сети и новую IP сеть, как на рисунке ниже.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="tcp_ip/routing/default_route/images/3_segments.png" alt="3 сегмента сети и 3 IP сети. (https://miminet.ru/web_network?guid=6547afac-26fc-474e-8e4e-9446992ab96c)">
</div>
<div class="title">Figure 71. 3 сегмента сети и 3 IP сети. (<a href="https://miminet.ru/web_network?guid=6547afac-26fc-474e-8e4e-9446992ab96c" class="bare">https://miminet.ru/web_network?guid=6547afac-26fc-474e-8e4e-9446992ab96c</a>).</div>
</div>
<div class="paragraph">
<p>Теперь, чтобы хост 1 смог отправить пакет на хост 4 (в сеть 192.168.1.0/24) ему нужно добавить еще одну запись в свою таблицу маршрутизации.</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">IP адрес назначения</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">IP адрес маршрутизатора</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">10.0.0.0/24</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">10.0.0.1</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">172.16.0.0/24</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">10.0.0.100</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">192.168.1.0/24</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">10.0.0.100</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>Получается, что каждый раз при появлении новой IP сети мы (хост 1) должны будем добавлять ее в свою таблицу маршрутизации. Это не очень удобно, так как будет тормозить масштабирование сети. Каждый раз при появлении новой сети нам нужно будет добавлять ее к себе в таблицу маршрутизации.</p>
</div>
<div class="paragraph">
<p>Если эти новые IP сети будут появляться за маршрутизатором 1, то для нас это будет означать, что при добавлении нового маршрута в свою таблицу, в качестве IP адреса маршрутизатора, мы всегда будем ставить 10.0.0.100</p>
</div>
<div class="paragraph">
<p>Раз так, может быть мы тогда для всех неизвестных нам IP сетей сразу поставим маршрутизатор 10.0.0.100? Ведь какая разница, добавится там 192.168.1.0/24 или какая-нибудь еще IP сеть, все равно адрес маршрутизатора 10.0.0.100.</p>
</div>
<div class="paragraph">
<p>Получается, нам нужно добавить в таблицу маршрутизации такую запись, которая бы означала “для всех остальных IP сетей кроме моей идти на маршрутизатор”. В нашем случае это “для всех остальных IP сетей кроме 10.0.0.0/24 идти на 10.0.0.100”.</p>
</div>
<div class="paragraph">
<p>Инженеры решили этот вопрос вот так:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Запись  “для всех остальных IP сетей кроме моей идти на маршрутизатор” выглядит как 0.0.0.0/0. Т.е. нулевая сеть с маской 0. Получается, что в эту сеть попадает абсолютно любой IP адрес. Для любого IP адреса применив маску 0 получим 0.0.0.0.</p>
</li>
<li>
<p>Введем порядок просмотра записи в таблице маршрутизации. Она просматривается от большей маски к меньшей. Т.е. первой будет просматриваться запись с маской 32, потом с 31, потом с 30 и так далее до 0.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>Получается, что теперь таблица маршрутизации для хоста 1 будет выглядеть вот как в таблице.</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">IP адрес назначения</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">IP адрес маршрутизатора</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">10.0.0.0/24</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">10.0.0.1</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">0.0.0.0/24</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">10.0.0.100</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>Если хост 1 будет отправлять пакет на хост 2 (10.0.0.2), то его IP адрес попадет в первую запись (10.0.0.0/24). Так как маска 24 больше 0, то сначала мы будем смотреть ее.  А если IP адрес назначения будет из других сетей, например 172.16.0.0/24, 192.168.1.0/24 и так далее, то он не попадет под запись 10.0.0.0/24, но будет попадать во вторую запись. Таким образом, для всех не наших сетей мы будем отправлять пакет на маршрутизатор.</p>
</div>
<div class="paragraph">
<p>Вот такая запись (0.0.0.0/0) и называется маршрутом по умолчанию или Default gateway.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_таблица_маршрутизации">Таблица маршрутизации</h2>
<div class="sectionbody">
<div class="paragraph">
<p>У каждого узла, который подключен к глобальной сети Интернет, должна быть своя таблица маршрутизации. Именно благодаря таблице маршрутизации хост может принимать решения, когда он сам может доставлять пакеты по сети, а когда ему нужно отправить пакет на маршрутизатор.</p>
</div>
<div class="paragraph">
<p>Вы можете посмотреть свою таблицу маршрутизации. Если у вас ОС Windows, то в командной строке наберите “route print”. Результатом работы команды будет вывод вашей текущей таблицы маршрутизации, подобно тому, как на рисунке ниже.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="tcp_ip/routing/route_table/images/route_table.png" alt="Таблица маршрутизации под Windows.">
</div>
<div class="title">Figure 72. Таблица маршрутизации под Windows.</div>
</div>
<div class="paragraph">
<p>Так как у меня стоит много разных виртуальных интерфейсов, то таблица маршрутизации состоит из более чем 2-х записей. Но все они уже должны быть вам понятны.</p>
</div>
<div class="paragraph">
<p>Самая первая запись - сетевой адрес 0.0.0.0, маска подсети 0.0.0.0 и адрес шлюза 192.168.0.1. Это и есть маршрут по умолчанию. Но мы уже знаем, что хоть эта запись стоит и первой, просматривается она в последнюю очередь.</p>
</div>
<div class="paragraph">
<p>IP адрес моего сетевого интерфейса 192.168.0.107. И в таблице на 5 строке можно увидеть запись - сетевой адрес 192.168.0.0, маска подсети 255.255.255.0 и адрес шлюза 192.168.0.107 (т.е. я сам). Это маршрут до хостов в моей сети.</p>
</div>
<div class="paragraph">
<p>Метрика в таблице маршрутизации нужна для приоритета. Если в таблице будет два одинаковых маршрута, то метрика позволит выбрать более приоритетный. Чем ниже метрика, тем приоритетней маршрут. Например, для отказоустойчивости вы хотите сделать два маршрута по умолчанию. Чтобы всегда работал только один, а второй начал работать только при неработоспособности первого, можно воспользоваться метрикой.</p>
</div>
<div class="paragraph">
<p>А если у вас Linux или MacOS, наберите в терминале <em>netstat -nr</em>. Вот так выглядит таблица маршрутизации у моего Linux сервера.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="tcp_ip/routing/route_table/images/route_table_linux.png" alt="Таблица маршрутизации под Linux">
</div>
<div class="title">Figure 73. Таблица маршрутизации под Linux</div>
</div>
<div class="paragraph">
<p>Как и в случае с Windows, на первом месте стоит маршрут по умолчанию - сеть назначения (Destination) 0.0.0.0 с маской (Genmask) 0.0.0.0 и маршрутизатором 10.129.0.1.</p>
</div>
<div class="paragraph">
<p>На рисунке 71 можно еще увидеть вывод команды ifconfig. Как видно, IP адрес у моего Linux сервера 10.129.0.21 с маской 255.255.255.0, и в таблице маршрутизации второй записью мы видим - сеть назначения 10.129.0.0 с маской 255.255.255.0 использовать маршрутизатор 0.0.0.0. Как можно сделать вывод, если в таблице маршрутизации Linux в поле маршрутизатор (Gateway) стоит 0.0.0.0, значит хост сам знает как общаться с этой сетью.</p>
</div>
<div class="sect2">
<h3 id="_один_сетевой_сегмент_и_разные_ip_сети">Один сетевой сегмент и разные IP сети</h3>
<div class="paragraph">
<p>Давайте рассмотрим еще один интересный пример. Сделаем сеть из 3-х хостов и 1 свитча. Два хоста будут находиться в одной IP сети, а третий в другой, как на рисунке.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="tcp_ip/routing/route_table/images/1_segment_2_net.png" alt="Два хоста в разных IP сетях. (https://miminet.ru/web_network?guid=adfb3817-4161-4c82-9578-1934e70f8a41).">
</div>
<div class="title">Figure 74. Два хоста в разных IP сетях. (<a href="https://miminet.ru/web_network?guid=adfb3817-4161-4c82-9578-1934e70f8a41" class="bare">https://miminet.ru/web_network?guid=adfb3817-4161-4c82-9578-1934e70f8a41</a>).</div>
</div>
<div class="paragraph">
<p>И так, сделаем сеть из 3 хостов объединенных одним свитчем:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Хост 1 и хост 2 будут находиться в одной IP сети - 192.168.1.0/24</p>
</li>
<li>
<p>А хост 3 настроим для другой IP сети - 192.168.0.0/24</p>
</li>
<li>
<p>У хоста 1 будет IP адрес 192.168.1.1/24</p>
</li>
<li>
<p>У хоста 2 - 192.168.1.2/24</p>
</li>
<li>
<p>У хоста 3 - 192.168.0.3/24</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Таблица маршрутизации для хоста 1 будет выглядеть как в таблице ниже.</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">IP сеть назначения</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">IP адрес маршрутизатора</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">192.168.1.0/24</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">192.168.1.1</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>Эта запись добавляется автоматически, как только мы сконфигурировали IP настройки для этого хоста. Во время настройки IP адреса и маски хоста автоматически добавляется подобная запись в таблицу маршрутизации. Раз наш хост из этой сети, значит он сам может общаться со всеми хостами в этой сети.</p>
</div>
<div class="paragraph">
<p>Если мы отправим ICMP-запрос на хост 2, то мы получим от него ICMP-ответ. Так как мы с ним одной сети и соединены свитчем. ICMP-запрос можно отправить командой ping и указав в качестве аргумента IP адрес. В нашем случае ping -c 1 192.168.1.2.</p>
</div>
<div class="paragraph">
<p>А теперь посмотрите на хост 3. Он хоть и подключен к тому же свитчу, что и хост 2, но его IP адрес лежит в другой IP сети. И получается, что на физическом и на канальном уровне мы можем обмениваться пакетами. А на сетевом уровне эти хосты друг про друга ничего не знают.</p>
</div>
<div class="paragraph">
<p>Чтобы хост 1 и 3 смогли обмениваться данными им нужно добавить в свою таблицу маршрутизации маршрут. Для хоста 1 это маршрут до сети 192.168.0.0/24, а для хоста 3 это маршрут до сети 192.168.1.0/24.</p>
</div>
<div class="paragraph">
<p>После добавления таких маршрутов хост 1 и хост 3 смогут обмениваться данными.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_default_free_zone_dfz">Default Free Zone (DFZ)</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Маршрут по умолчанию очень удобная запись, но на самом деле она не совсем решает проблему, а лишь перекладывает ее. Рано или поздно должен появиться маршрутизатор, который знает маршруты до всех сетей.</p>
</div>
<div class="paragraph">
<p>Default free Zone (DFZ) - это такой набор маршрутизаторов, которые вместе содержат все маршруты до всех сетей. Давайте построим сеть, как показано на рисунке ниже.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="tcp_ip/routing/dfz/images/dfz.png" alt="Маршрута по умолчанию недостаточно. (https://miminet.ru/web_network?guid=bcbdb588-21a0-4c28-b84f-f03edf06ae29)">
</div>
<div class="title">Figure 75. Маршрута по умолчанию недостаточно. (<a href="https://miminet.ru/web_network?guid=bcbdb588-21a0-4c28-b84f-f03edf06ae29" class="bare">https://miminet.ru/web_network?guid=bcbdb588-21a0-4c28-b84f-f03edf06ae29</a>).</div>
</div>
<div class="paragraph">
<p>Нам понадобится 2 хоста и 3 маршрутизатора:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Хост 1 и маршрутизатор 1 в IP сети 10.0.0.0/24</p>
</li>
<li>
<p>Маршрутизатор 1 и маршрутизатор 2 в IP сети 192.168.1.0/24</p>
</li>
<li>
<p>Маршрутизатор 2 и маршрутизатор 3 в IP сети 172.16.12.0/24</p>
</li>
<li>
<p>Ну и маршрутизатор 3 и хост 2 в IP сети 169.254.1.0/24</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>И пропишем маршруты по умолчанию:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>хост 1 на маршрутизатор 1</p>
</li>
<li>
<p>маршрутизатор 1 на маршрутизатор 2</p>
</li>
<li>
<p>хост 2 на маршрутизатор 3</p>
</li>
<li>
<p>маршрутизатор 3 на маршрутизатор 2</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Это пример сети, когда мы не можем обойтись только маршрутами по умолчанию.  Если мы на маршрутизаторе 2 сделаем маршрут по умолчанию на маршрутизатор 3, то пакет от хоста 1 до хоста 2 сможет дойти. Но вот обратно нет, так как маршрутизатор 2 ничего не знает про сеть 10.0.0.0/24, а маршрут по умолчанию указывает на маршрутизатор 3.</p>
</div>
<div class="paragraph">
<p>А если мы на маршрутизаторе 2 сделаем маршрут по умолчанию на маршрутизатор 1, то картина будет обратной. От хоста 2 до хоста 1 пакеты будут доходить, а вот обратно нет.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="tcp_ip/routing/dfz/images/dfz2.png" alt="Default Free Zone (https://miminet.ru/web_network?guid=8de49b2d-563c-4519-9119-41be6939dd7b).">
</div>
<div class="title">Figure 76. Default Free Zone (<a href="https://miminet.ru/web_network?guid=8de49b2d-563c-4519-9119-41be6939dd7b" class="bare">https://miminet.ru/web_network?guid=8de49b2d-563c-4519-9119-41be6939dd7b</a>).</div>
</div>
<div class="paragraph">
<p>Чтобы такая сеть работала нам нужно:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Либо на маршрутизаторе 2 добавить в таблицу маршрутизации информацию про обе IP сети: 10.0.0.0/24 и 169.254.1.0/24 (как сделано на рисунке).</p>
</li>
<li>
<p>Либо на маршрутизаторе 2 добавить в таблицу маршрутизации маршрут по умолчанию и информацию про одну из двух IP сетей. Например, в качестве маршрута по умолчанию выбрать маршрутизатор 1 и добавить информацию про IP сеть 169.254.1.0/24.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>В первом случае в DFZ будет только маршрутизатор 2, так как он сам будет знать про все маршруты. А его таблица маршрутизации будет как в таблице</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">IP сеть назначения</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">IP адрес маршрутизатора</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">192.168.1.0/24</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">192.168.1.102 (сам маршрутизатор 2)</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">172.16.12.0/24</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">172.16.12.102  (сам маршрутизатор 2)</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">10.0.0.0/24</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">192.168.1.101  (на маршрутизатор 1)</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">169.254.1.0/24</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">172.16.12.103  (на маршрутизатор 3)</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>Во втором случае в DFZ будет маршрутизатор 2 и 1. Так как вместе они будут иметь маршруты до всех сетей.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_ip_протокол">IP протокол</h2>
<div class="sectionbody">
<div class="paragraph">
<p>На сетевом уровне работает протокол IP (Internet protocol), который описан в <a href="https://datatracker.ietf.org/doc/html/rfc791">RFC 791</a>. IP протокол был придуман в далеком 1981 году, является частью стека протоколов TCP/IP и ответственный за доставку данных от одного хоста к другому. А IP адреса это только часть протокола. На рисунке ниже можно увидеть заголовок IP пакета. Source Address и Destination Address - это IP адреса.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="tcp_ip/ipv4/images/ip_header.png" alt="Заголовок IP пакета из RFC 791 (https://datatracker.ietf.org/doc/html/rfc791).">
</div>
<div class="title">Figure 77. Заголовок IP пакета из RFC 791 (<a href="https://datatracker.ietf.org/doc/html/rfc791" class="bare">https://datatracker.ietf.org/doc/html/rfc791</a>).</div>
</div>
<div class="paragraph">
<p>Разберем некоторые поля из IP заголовка.</p>
</div>
<div class="sect2">
<h3 id="_версия_ip_протокола">Версия IP протокола</h3>
<div class="paragraph">
<p>Самое первое поле в IP заголовке называется Version. Оно указывает на текущую версию протокола. Сейчас используется 4 версия протокола, поэтому иногда можно встретить вот такую запись IPv4.</p>
</div>
<div class="paragraph">
<p>Есть еще 6-я версия протокола (IPv6). Основное отличие IPv4 от IPv6 - размер IP адреса. В IPv4 размер IP адреса 4 байта (32 бита), а в IPv6 целых 16 байт (128 бит).</p>
</div>
<div class="paragraph">
<p>Это поле указывает на версию IP протокола. Когда внутри Ethernet пакета передается IPv4, то в поле тип/длина указывается 0x0800, как на рисунке ниже.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="tcp_ip/ipv4/images/ethernet_header.png" alt="Внутри Ethernet кадра передается IPv4.">
</div>
<div class="title">Figure 78. Внутри Ethernet кадра передается IPv4.</div>
</div>
<div class="paragraph">
<p>А если бы мы передавали IPv6, то в поле тип/длина было бы 0x08DD. Таким образом, еще в заголовке Ethernet кадра мы можем понять, какой тип IP протокола лежит внутри и смотреть на поле Version в заголовке IP нет особого смысла.</p>
</div>
</div>
<div class="sect2">
<h3 id="_время_жизни_пакета_time_to_live_ttl">Время жизни пакета (Time To Live - TTL)</h3>
<div class="paragraph">
<p>Поле Time To Live (TTL) определяет время жизни пакета в сети. Как видно из заголовка, это поле размером 1 байт (8 бит). Измеряется оно в хопах. Хоп - это переход пакета через маршрутизатор. Т.е. каждый раз, когда маршрутизатор пересылает пакет, он уменьшает это поле на 1. Если поле TTL становится 0, то маршрутизатор отбрасывает такой пакет и генерирует для отправителя этого пакета специальное ICMP сообщение “time to live exceeded in transit”. Таким образом, отправитель будет знать по какой причине и какой маршрутизатор отбросил этот пакет. Это защита от вечно зацикленного пакета.</p>
</div>
<div class="paragraph">
<p>Сделаем сеть как показано на рисунке ниже.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="tcp_ip/ipv4/images/3_routers.png" alt="Кольцо из 3-х маршрутизаторов. (https://miminet.ru/web_network?guid=7509b963-d190-4aad-8d90-9be42f302bbb)">
</div>
<div class="title">Figure 79. Кольцо из 3-х маршрутизаторов. (<a href="https://miminet.ru/web_network?guid=7509b963-d190-4aad-8d90-9be42f302bbb" class="bare">https://miminet.ru/web_network?guid=7509b963-d190-4aad-8d90-9be42f302bbb</a>)</div>
</div>
<div class="paragraph">
<p>Нам понадобится 1 хост и 3 маршрутизатора:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Хост 1 и маршрутизатор будут в IP сети 10.0.0.0/24. В качестве маршрутизатора по умолчанию для хоста 1 будем использовать маршрутизатор 1.</p>
</li>
<li>
<p>Маршрутизатор 1 и 2 будут в сети 172.16.12.0/24. В качестве маршрутизатора по умолчанию для маршрутизатора 1 будет маршрутизатор 2.</p>
</li>
<li>
<p>Маршрутизатор 2 и 3 будут в сети 192.168.1.0/24. В качестве маршрутизатора по умолчанию для маршрутизатора 2 будет маршрутизатор 3.</p>
</li>
<li>
<p>А сеть между маршрутизаторами 3 и 1 будет 169.254.1.0/24. В качестве маршрутизатора по умолчанию для маршрутизатора 3 будет маршрутизатор 1.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>По умолчанию маршрутизатор 1 будет отправлять пакет на маршрутизатор 2, тот на маршрутизатор 3, а тот в свою очередь на маршрутизатор 1. Т.е. пакет будет летать по кругу.</p>
</div>
<div class="paragraph">
<p>Теперь на хосте 1 выполним команду <em>ping -c 1 -t 5 12.34.45.67</em> и посмотрим за работой сети. Флаг -t для команды пинг означает установить поле TTL в IP пакете. В данном случае я установил это поле в 5. Это означает, что через 5 маршрутизаторов поле TTL станет 0 и пакет будет отброшен.</p>
</div>
<div class="paragraph">
<p>В качестве IP адреса получателя в команде ping я выбрал 12.34.45.67, чтобы все маршрутизаторы отправляли этот пакет на маршрутизатор по умолчанию.</p>
</div>
<div class="paragraph">
<p>Запустим анимацию сети мы увидим, что пакет прошел по кругу и, когда он оказался второй раз на маршрутизаторе 2, он был отброшен. Вместо ICMP-запроса с маршрутизатора 2 вышел ICMP- time to live exceeded, который в итоге был доставлен хосту 1.</p>
</div>
<div class="paragraph">
<p>Таким образом, поле TTL в IP протоколе защищает сеть от вечно циркулирующих IP пакетов.</p>
</div>
</div>
<div class="sect2">
<h3 id="_фрагментация">Фрагментация</h3>
<div class="paragraph">
<p>В заголовке IP пакета есть поле Total Length (длина). Это поле сообщает длину IP пакета в байтах. Длина поля 2 байта (16 бит). Это означает, что максимальная длина одного IP пакета может быть 65 536 байт.</p>
</div>
<div class="paragraph">
<p>С другой стороны, есть ограничения физического уровня на передачу максимального размера кадра. В Ethernet это 1500 байт.</p>
</div>
<div class="paragraph">
<p>И как передать пакет длиной в 65535 байт, если максимальный размер пакета 1500 байт? Ответ - фрагментация пакета. Т.е. перед отправкой пакет разбивается на фрагменты, так, чтобы помещаться в пакет более низкого уровня и отправляются в сеть.</p>
</div>
<div class="paragraph">
<p>Чтобы принимающий хост смог все эти фрагменты правильно собрать используются следующие поля:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Identification (идентификатор)</p>
</li>
<li>
<p>Flags (флаги)</p>
</li>
<li>
<p>Fragment Offset (смещение фрагмента)</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Фрагментация выглядит как на рисунке ниже.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="tcp_ip/ipv4/images/ip_fragment.png" alt="Фрагментация IP пакета.">
</div>
<div class="title">Figure 80. Фрагментация IP пакета.</div>
</div>
<div class="paragraph">
<p>Алгоритм следующий:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Берем данные для передачи, и нарезаем их на порции, которые смогут поместиться в один пакет. Напомню, что в Ethernet мы можем передать до 1500 байт данных. Размер заголовка IP 20 байт, соответственно, 1500 - 20 = 1480, в одном пакете мы можем передать до 1480 байт данных.</p>
</li>
<li>
<p>Для каждой такой порции формируем IP пакет, в котором указываем:</p>
<div class="olist loweralpha">
<ol class="loweralpha">
<li>
<p>Идентификатор пакета, например, 12. Он нам нужен для идентификации пакета. Представим ситуацию, на хост приходит два фрагмента IP пакета. Как понять, что это два фрагмента от одного IP пакета, а не от разных? Именно для этого и используется поле идентификатор. Значение этого поля будет одинаковым для всех фрагментов нашего пакета.</p>
</li>
<li>
<p>Флаг More Fragments (MF). Если это не последний фрагмент, то флаг выставляется в 1. Если это последний фрагмент, то флаг выставляется в 0. Этот флаг нужен, чтобы сообщить принимающему хосту, что все, фрагменты закончились, можешь обрабатывать пакет.</p>
</li>
<li>
<p>Offset (смещение). Указывает на смещение в байтах относительно начала данных. У первого фрагмента это будет 0.</p>
</li>
</ol>
</div>
</li>
<li>
<p>Передаем в сеть.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>Получив все эти фрагменты удаленный хост может собрать все обратно и отдать на дальнейшую обработку.</p>
</div>
<div class="paragraph">
<p>Всех этих данных достаточно, чтобы собрать пакет, даже если фрагменты придут в неправильном порядке.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
Если внимательно посмотреть на IP заголовок, то можно заметить, что поле Fragment Offset имеет размер 13 бит. Максимальное число, которое мы сможем записать с помощью 13 бит - это 8191. А максимальный размер IP пакет 65 5236 байт. Как тогда с помощью Fragment Offset указать на смещение 12000 или 30000 байт? Все дело в том, что поле Fragment Offset указывает на количество 8 битных слов (64 бита). Т.е. значение поля Fragment Offset в 1 указывает на смещение на 8 байт, а значение Fragment Offset в 100 будет указывать на смещение в 800 байт.
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="_ihl">IHL</h3>
<div class="paragraph">
<p>IHL (Internet Header Length) - длина IP заголовка. Если посмотреть на формат IP заголовка, то можно увидеть в конце поле Options (опции). Они могут быть, а могут и не быть, от этого длина заголовка будет разной. Чтобы при обработке пакета понять, сколько байт занимает длина IP заголовка используется поле IHL. IP заголовок всегда должен быть кратен 4 байтам (32 бита), поэтому поле IHL указывает количество 32-битных слов в заголовке. Если опций нет, то поле IHL равно 5 (5 * 4 = 20 байт).</p>
</div>
</div>
<div class="sect2">
<h3 id="_type_of_service">Type Of Service</h3>
<div class="paragraph">
<p>Поле указывает на тип сервиса. Задумка была такой, чтобы пакеты с разным типом обслуживания обрабатывать с разным приоритетом. Например, если идет интерактивный трафик то, его лучше обрабатывать быстрей остальных. Но по факту, маршрутизаторы по большей части игнорируют это поле.</p>
</div>
</div>
<div class="sect2">
<h3 id="_header_checksum">Header Checksum</h3>
<div class="paragraph">
<p>Контрольная сумма заголовка, считается как CRC32.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_nat_network_address_translation">NAT (Network Address Translation)</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_частные_ip_сети">Частные IP сети</h3>
<div class="paragraph">
<p>Когда мы говорили про IP адреса, возможно у кого-то из вас возникал вопрос. IP адрес длиной 32 бита, значит всего IP адресов может быть чуть больше 4 млрд. И мы говорили о том, что IP адрес это уникальный идентификатор хоста в Интернет. Что, сейчас в сети меньше 4 млрд. хостов? Не верю. И будете абсолютно правы!</p>
</div>
<div class="paragraph">
<p>Создатели TCP/IP, Боб Кан и Винтон Серф, не ожидали, что сеть будет развиваться так быстро. И уже в 90-х годах пришлось задуматься над тем, как решать проблему нехватки IP адресов.</p>
</div>
<div class="paragraph">
<p>Так появился NAT (Network Address Translation или по-русски преобразование сетевых адресов) - механизм, позволяющий на лету изменять IP адрес отправителя.</p>
</div>
<div class="paragraph">
<p>Для начала, из всего диапазона IP выделили несколько IP сетей, так называемые частные IP сети или их еще называют серые IP сети:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>10.0.0.0/8</p>
</li>
<li>
<p>172.16.0.0/12</p>
</li>
<li>
<p>192.168.0.0/16</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Эти сети описаны в <a href="https://datatracker.ietf.org/doc/html/rfc1918">RFC 1918</a>. IP адреса из этих сетей не могут быть использованы в сети Интернете. Вместо этого, эти сети могут использовать в частных нуждах: дома, в офисе, в кафе и ресторанах, на даче, в гостиницах и так далее.</p>
</div>
<div class="paragraph">
<p>Посмотрите IP на своем устройстве (ноутбук или ПК). С большой вероятностью у вас будет IP адрес из частной сети, как у меня.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="tcp_ip/nat/basic/images/ip_addr_windows.png" alt="Серый IP адрес.">
</div>
<div class="title">Figure 81. Серый IP адрес.</div>
</div>
<div class="paragraph">
<p>Чтобы хост с IP адресом из частной сети мог обмениваться данными с хостами в сети Интернет, его IP адрес будет подменяться на IP адрес маршрутизатора. Такая функция подмены IP адреса и называется NAT.</p>
</div>
</div>
<div class="sect2">
<h3 id="_nat">NAT</h3>
<div class="paragraph">
<p>Давайте сделаем сеть как показано на рисунке ниже. Нам понадобится 2 хоста, 1 маршрутизатор и 1 сервер.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="tcp_ip/nat/basic/images/nat.png" alt="NAT. (https://miminet.ru/web_network?guid=6166e87e-571c-4495-a712-f2416af71dfd)">
</div>
<div class="title">Figure 82. NAT. (<a href="https://miminet.ru/web_network?guid=6166e87e-571c-4495-a712-f2416af71dfd" class="bare">https://miminet.ru/web_network?guid=6166e87e-571c-4495-a712-f2416af71dfd</a>)</div>
</div>
<div class="paragraph">
<p>Оба хоста будут находиться в частной сети, пусть это будет 192.168.1.0/24, а внешний интерфейс маршрутизатора и сервер будут находиться в нормальной (белой) IP сети 212.220.12.0/24. На NAT маршрутизаторе включим маскарадинг на внешний интерфейс и с обоих хостов выполним команду ping на сервер.</p>
</div>
<div class="paragraph">
<p>Если запустить анимацию сети, то можно будет увидеть, что когда пакет проходит через маршрутизатор, то его IP отправителя меняется на IP адрес маршрутизатора. Т.е. со стороны сервера выглядит так, словно ICMP-запрос ему отправляет хост с IP адресом 212.220.12.254. И он ничего не знает про то, что на самом деле пакет был от хоста 1 или 2, с IP адресами из серых сетей.</p>
</div>
<div class="paragraph">
<p>Когда пакет возвращается, NAT маршрутизатор помнит о подмене IP адреса, возвращает исходный IP адрес и отправляет пакет обратно в серую сеть.</p>
</div>
<div class="paragraph">
<p>Таким образом, NAT прячет исходные IP адреса хостов и позволяет большому количеству хостов с серыми IP адресами обмениваться данными с серверами в Интернете.</p>
</div>
<div class="paragraph">
<p>Отсюда и высказывание “хост спрятан за NAT”.</p>
</div>
</div>
<div class="sect2">
<h3 id="_домашний_маршрутизатор">Домашний маршрутизатор</h3>
<div class="paragraph">
<p>Обычно домашние маршрутизаторы сразу идут с включенной функцией NAT. Для этого у них есть специальный порт, куда должен входить провод от провайдера. Все пакеты, которые выходят из этого порта предварительно проходят через NAT.</p>
</div>
</div>
<div class="sect2">
<h3 id="_myip_ru">myip.ru</h3>
<div class="paragraph">
<p>Если у вас дома, на работе или в кафе используется частный IP адрес, то вы можете зайти на сайт <a href="https://myip.ru/" class="bare">https://myip.ru/</a> и посмотреть, с какого белого IP адреса вы выходите в Интернет. У меня это 91.122.144.178</p>
</div>
<div class="imageblock">
<div class="content">
<img src="tcp_ip/nat/basic/images/myipru.png" alt="myip.ru.">
</div>
<div class="title">Figure 83. myip.ru.</div>
</div>
</div>
<div class="sect2">
<h3 id="_два_и_более_одинаковых_серых_адреса">Два и более одинаковых серых адреса</h3>
<div class="paragraph">
<p>Благодаря использованию NAT, теперь разные хосты могут иметь одинаковые IP адреса, как на рисунке ниже.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="tcp_ip/nat/basic/images/2_same_ip.png" alt="Одинаковые IP за NAT. (https://miminet.ru/web_network?guid=19e7c6b6-9541-4602-8c78-d0c64c069b41).">
</div>
<div class="title">Figure 84. Одинаковые IP за NAT. (<a href="https://miminet.ru/web_network?guid=19e7c6b6-9541-4602-8c78-d0c64c069b41" class="bare">https://miminet.ru/web_network?guid=19e7c6b6-9541-4602-8c78-d0c64c069b41</a>).</div>
</div>
<div class="paragraph">
<p>Хост 1 и 2 имеют одинаковые IP адреса, но находятся за разными маршрутизаторами. Хост 1 за маршрутизатором 1, а хост 2 за маршрутизатором 2. В итоге, каждый из них выходит в сеть с разными IP адресами. Хост 1 с IP адреса 172.16.0.1, а хост 2 с IP адреса 172.16.1.1</p>
</div>
</div>
<div class="sect2">
<h3 id="_nat_цепочка">NAT цепочка</h3>
<div class="paragraph">
<p>Маршрутизаторы с функцией NAT могут располагаться в цепочку и тогда IP адрес отправителя в исходном пакете будет изменен несколько раз, как на рисунке.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="tcp_ip/nat/basic/images/nat_chain.png" alt="NAT цепочка. (https://miminet.ru/web_network?guid=4e882fd3-975c-46af-b2f3-8e088cd1b911).">
</div>
<div class="title">Figure 85. NAT цепочка. (<a href="https://miminet.ru/web_network?guid=4e882fd3-975c-46af-b2f3-8e088cd1b911" class="bare">https://miminet.ru/web_network?guid=4e882fd3-975c-46af-b2f3-8e088cd1b911</a>).</div>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Изначально пакет отправляется с хоста 1 (IP адрес отправителя 192.168.1.1).</p>
</li>
<li>
<p>Проходя через маршрутизатор 1 его IP адрес меняется на 10.0.0.254, так как на нем работает NAT.</p>
</li>
<li>
<p>Проходя через маршрутизатор 2 его IP адрес меняется на 77.88.8.254</p>
</li>
<li>
<p>В итоге, сервер 1 получает ICMP-запрос с IP адресом отправителя 77.88.8.254.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>Во время обратного следования пакета каждый NAT маршрутизатор сделает обратную подмену IP. И хост 1 получит ответ от сервера 1 и о том, что на пути следования пакета его IP адрес менялся, не догадается.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_групповые_адреса_multicast">Групповые адреса (Multicast)</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_что_такое_групповой_ip_адрес">Что такое групповой IP адрес?</h3>
<div class="paragraph">
<p>Групповой адрес - это идентификатор не одного, а сразу нескольких хостов. Используется в случае, когда данные необходимо доставить не одному, а сразу группе хостов. Под групповые адреса в IP выделена сеть 224.0.0.0/4 (от 224.0.0.0 до 239.255.255.255). Рассылка на эти адреса обычно называется мультикастом.</p>
</div>
</div>
<div class="sect2">
<h3 id="_какую_проблему_решает_групповой_ip_адрес">Какую проблему решает групповой IP адрес?</h3>
<div class="paragraph">
<p>Например, вы хотите в своей сети запустить интернет телевидение (IPTV) и у вас есть 3 клиента, которые хотят смотреть один и тот же канал.  Если вы будете использовать обычные IP адреса (Unicast), то для каждого получателя вам придется отправлять отдельный пакет, как показано на рисунке ниже. При этом данные в пакетах будут одинаковые.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="tcp_ip/multicast/images/iptv_unicast.png" alt="Сервер IPTV использует юникаст.">
</div>
<div class="title">Figure 86. Сервер IPTV использует юникаст.</div>
</div>
<div class="paragraph">
<p>Такой способ доставки данных неэффективный. Так как с ростом числа клиентов будет расти и нагрузка на канал передачи данных между сервером и свитчем.</p>
</div>
<div class="paragraph">
<p>Или другая ситуация, у вас в компании открывается новый офис или компьютерный класс. Вам доставили 50 одинаковых компьютеров, на которые нужно установить ПО. Скачивать с сервера 50 раз один и тот же образ будет на много дольше, чем если его скачать всего 1 раз.</p>
</div>
<div class="paragraph">
<p>Для решения подобных задач лучше всего подойдет использование групповых адресов, как на рисунке ниже.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="tcp_ip/multicast/images/iptv_multicast.png" alt="Сервер IPTV использует групповую рассылку.">
</div>
<div class="title">Figure 87. Сервер IPTV использует групповую рассылку.</div>
</div>
<div class="paragraph">
<p>Основной критерий для использования групповой рассылки:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>отправитель посылает только одну копию трафика, независимо от количества получателей.</p>
</li>
<li>
<p>сервер отправителя не планирует получать данные от клиентов, т.е. трафик односторонний.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Для отправки данных на групповой адрес вам достаточно указать его в качестве адреса назначения.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="tcp_ip/multicast/images/icmp_multicast.png" alt="Отправка ICMP-запроса на групповой адрес 224.12.0.2. (https://miminet.ru/web_network?guid=730102eb-672c-47a1-a24b-14438056bec6).">
</div>
<div class="title">Figure 88. Отправка ICMP-запроса на групповой адрес 224.12.0.2. (<a href="https://miminet.ru/web_network?guid=730102eb-672c-47a1-a24b-14438056bec6" class="bare">https://miminet.ru/web_network?guid=730102eb-672c-47a1-a24b-14438056bec6</a>)</div>
</div>
<div class="paragraph">
<p>Такой пакет будет доставлен на все хосты в сегменте сети, но обработан только теми, кто подписался на этот адрес.</p>
</div>
<div class="paragraph">
<p>Когда хост назначает себе групповой адрес, он не указывает маску. В этом нет смысла, так как групповой адрес всегда один.</p>
</div>
</div>
<div class="sect2">
<h3 id="_отображение_группового_ip_адреса_в_mac_адрес">Отображение группового IP адреса в MAC адрес</h3>
<div class="paragraph">
<p>Обратите внимание на пример с рисунка выше. Если вы запустите его, то увидите, что перед отправкой ICMP пакета нет привычных нам ARP пакетов. Почему так?</p>
</div>
<div class="paragraph">
<p>Дело в том, что пакет на групповой IP адрес доставляется сразу нескольким хостам. Записать несколько MAC адресов в Ethernet заголовок мы не можем, там место только для одного адреса. А писать туда широковещательный адрес (FF:FF:FF:FF:FF:FF) тоже неправильно, ведь пакет групповой, а не широковещательный. Поэтому, у групповых пакетов MAC адрес формируется автоматически на основании IP адреса назначения.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="tcp_ip/multicast/images/multicast_l2_addr.png" alt="Формат группового MAC адрес.">
</div>
<div class="title">Figure 89. Формат группового MAC адрес.</div>
</div>
<div class="paragraph">
<p>Давайте разберем, как MAC адрес формируется на основании группового IP адреса. Для примера возьмем групповой IP адрес 224.12.0.2. Напомню, общая длина MAC адреса 48 бит, а длина IP адреса 32 бита.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Первые 3 байта (24 бита) группового MAC адреса всегда 01:00:5E</p>
</li>
<li>
<p>Затем идет бит 0</p>
</li>
<li>
<p>Оставшиеся 23 бита MAC адреса устанавливаются в младшие 23 бита IP адреса.</p>
</li>
</ul>
</div>
<div class="imageblock">
<div class="content">
<img src="tcp_ip/multicast/images/multicast_l2_addr2.png" alt="Отображение группового IP адреса в MAC адрес.">
</div>
<div class="title">Figure 90. Отображение группового IP адреса в MAC адрес.</div>
</div>
<div class="paragraph">
<p>На рисунке показано, как младшие 23 бита IP адреса отображаются в младшие 23 бита MAC адреса.</p>
</div>
<div class="paragraph">
<p>В сети класса D (224.0.0.0 - 239.255.255.255) у всех IP адресов старшие 4 бита всегда одинаковые, а меняются только младшие 28 бит. Т.е. 4 бита для адреса сети и 28 бит для адреса хоста.</p>
</div>
<div class="paragraph">
<p>И вот вопрос, почему у группового IP адреса изменяющиеся 28 бит, а в MAC адрес отображается всего 23 бита? Что делать с оставшимися 5 битами?</p>
</div>
<div class="paragraph">
<p>Ответ простой - 5 бит просто не влезли. Поэтому есть 32 (2 ^ 5) групповых IP адреса, которые дадут одинаковый MAC адрес. Например:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>224.1.1.1</p>
</li>
<li>
<p>224.129.1.1</p>
</li>
<li>
<p>225.1.1.1</p>
</li>
<li>
<p>и так далее.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Когда хост назначает себе один из групповых адресов, то он также конфигурирует сетевой интерфейс на прием пакетов на MAC адрес, который соответствует этому групповому адресу. Т.е., если хост ставит себе IP адрес 224.12.0.2, то он также конфигурирует свой сетевой интерфейс на прием пакетов на MAC адрес 01:00:5E:0C:00:02.</p>
</div>
<div class="paragraph">
<p>Итого, есть 32 групповых IP адреса, которые дадют одинаковый MAC адрес. Получается, что если один хост поставит себе групповой IP адрес 224.1.1.1, то его сетевой интерфейс также будет принимать пакеты, которые предназначаются для, например, 225.1.1.1.</p>
</div>
<div class="paragraph">
<p>В этом случае, пакет действительно будет принят и обработан сетевым интерфейсом. Но когда пакет поднимется выше по стеку, то выяснится несовпадение по IP адресу. И пакет будет отброшен. Так что в целом, все нормально, ненужный пакет не будет по ошибке обработан.</p>
</div>
</div>
<div class="sect2">
<h3 id="_история_про_отображение_23_бит_в_mac_адрес">История про отображение 23 бит в MAC адрес</h3>
<div class="paragraph">
<p>В 90-х годах Стив Диринг (Steve Deering) как раз занимался разработкой группового вещания (мультикаста) в IP протоколе. И он хотел купить у IEEE 16 OUI (Organizational Unique Identifiers) для отображения IP адреса в MAC. Каждый OUI размером 24 бита, т.е. 16 OUI как раз хватило бы, чтобы сделать отображение 1 в 1.</p>
</div>
<div class="paragraph">
<p>Правда, каждый OUI стоил 1000$ и менеджер Стива не хотел платить 16 * 1000 = 16 000$ за какое-то там адресное пространство. Поэтому менеджер купил только 1 OUI (24 бита) и отдал Стиву половину от этого (23 бита) для его исследований.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_ipv6">IPv6</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_нехватка_ipv4">Нехватка IPv4</h3>
<div class="paragraph">
<p>Начать урок по IPv6 лучше всего с вот такой картинки. В 2010 году всего 7 сетей класса A остались свободными. Картинка хоть и старая, но отлично дает понять, как мало адресов IPv4 осталось.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="tcp_ip/ipv6/images/using_ipv4_addr.png" alt="Использование адресного пространства в IPv4 в 2010 году.">
</div>
<div class="title">Figure 91. Использование адресного пространства в IPv4 в 2010 году.</div>
</div>
<div class="paragraph">
<p>Разработчики стека протоколов TCP/IP не ожидали, что за каких-то 20 лет будет израсходовано почти все адресное пространство IPv4, а это 2^32 или 4 294 467 295 IP адреса.</p>
</div>
<div class="paragraph">
<p>Даже невзирая на классные решения по типу NAT, все равно ощущается большая нехватка IP адресов. Например, если вы купите виртуальную машину в облаке и захотите обеспечить ей доступ из сети Интернет, то вам придется отдельно купить белый IP адрес. Например, в Яндекс.Облако стоимость такого IP адреса около 170 рублей в месяц, что составляет более 15% от общей стоимости сервера.</p>
</div>
<div class="paragraph">
<p>Поэтому очень хочется начать использовать IPv6.</p>
</div>
<div class="paragraph">
<p>Хороший вопрос - что случилось с IPv5? Это был экспериментальный протокол реального времени, описанный в <a href="https://www.rfc-editor.org/rfc/rfc1819.txt">RFC 1819</a>. Кому интересно, можете о нем почитать.</p>
</div>
</div>
<div class="sect2">
<h3 id="_адресное_пространство_ipv6">Адресное пространство IPv6</h3>
<div class="paragraph">
<p>Размер адреса в IPv6 равен 128 бит, это на много больше, чем 32 бита в IPv4. Держите в голове, что каждый бит удваивает количество IP адресов и начинаем мы с 4 миллиардов. 128 бит это очень большое число и он позволяет адресовать аж 340 282 366 920 938 463 463 374 607 431 768 211 456 IP адресов.</p>
</div>
<div class="paragraph">
<p>Чтобы попробовать представить себе это число, это 4 294 467 295 адресных пространств IPv4. А в процентном отношении, количество адресов IPv4 занимает лишь 0.00000000000000000000000000126% от IPv6.</p>
</div>
<div class="paragraph">
<p>Внедрение IPv6 это не только решение проблемы нехватки IPv4 адресов, также это:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Отсутствие широковещательных пакетов. В IPv6 нет ARP протокола, он там попросту не нужен.</p>
</li>
<li>
<p>Нет нужды использовать NAT</p>
</li>
<li>
<p>Мобильность - хост может переезжать из одной сети в другую со своим IP адресом.</p>
</li>
<li>
<p>IPsec - встроенный механизм использования протокола IPsec (безопасный IP)</p>
</li>
<li>
<p>Улучшенный заголовок, например, больше нет нужды считать контрольную сумму.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Для записи IPv6 адреса не используются десятичные цифры, вместо этого используют шестнадцатеричные, а сам IP адрес записывается в виде 8 хекстетов (группа из 4-х цифр), например</p>
</div>
<div class="literalblock">
<div class="content">
<pre>2041:1234:140F:1122:AC91:494E:875B:131B</pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_сокращенная_запись_ipv6_адресов">Сокращенная запись IPv6 адресов</h3>
<div class="paragraph">
<p>Постоянно записывать IPv6 адрес может быть не самым легким делом. Например, вам нужно продиктовать адрес по телефону. Поэтому, для IPv6 адресов есть два правила, которые позволяют сократить их запись:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Выбирается самая длинная подпоследовательность хекстетов состоящая из 0 и она просто удаляется. Такое можно делать только один раз. Если такую подпоследовательность удалить два раза, то мы потом не сможем однозначно восстановить оригинальный IPv6 адрес.  Например, есть IPv6 адрес</p>
<div class="literalblock">
<div class="content">
<pre>2001:0DB8:AA10:0001:0000:0000:0000:15FB.</pre>
</div>
</div>
<div class="paragraph">
<p>Применяя это правило, мы можем записать его как</p>
</div>
<div class="literalblock">
<div class="content">
<pre>2001:0DB8:AA10:0001::15FB</pre>
</div>
</div>
</li>
<li>
<p>В каждом хекстете (группе из 4-х цифр) ведущие нули удаляются. Если весь хекстет состоит из нулей, остается только последний 0. Возьмем опять наш IP адрес</p>
<div class="literalblock">
<div class="content">
<pre>2001:0DB8:AA10:0001:0000:0000:0000:15FB</pre>
</div>
</div>
<div class="paragraph">
<p>Применив это правило адрес становится</p>
</div>
<div class="literalblock">
<div class="content">
<pre>2001:DB8:AA10:1:0000:0000:0000:15FB</pre>
</div>
</div>
</li>
</ol>
</div>
<div class="paragraph">
<p>Итого, применив первое и второе правило наш IP адрес можно теперь записать как <strong>2001:DB8:AA10:1::15FB</strong>. Выглядит уже не так страшно.</p>
</div>
<div class="paragraph">
<p>Давайте еще для примера рассмотрим IPv6 адрес</p>
</div>
<div class="literalblock">
<div class="content">
<pre>2001:0DB0:0000:123A:0000:0000:0000:0030</pre>
</div>
</div>
<div class="paragraph">
<p>Для начала используем правило 2 и уберем все лидирующие 0, получим</p>
</div>
<div class="literalblock">
<div class="content">
<pre>2001:DB0:0:123A:0:0:0:30</pre>
</div>
</div>
<div class="paragraph">
<p>А теперь воспользуемся правилом 1, найдем самую длинную подпоследовательность из 0 и уберем ее. В результате получим</p>
</div>
<div class="literalblock">
<div class="content">
<pre>2001:DB0:0:123A::30</pre>
</div>
</div>
<div class="paragraph">
<p>Итого:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Самую длинную подпоследовательность 0 можно удалить, но только 1 раз</p>
</li>
<li>
<p>Хекстет полностью состоящий из 0 можно заменить на 0</p>
</li>
<li>
<p>Лидирующие 0 можно убрать</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_типы_адресов_в_ipv6">Типы адресов в IPv6</h3>
<div class="paragraph">
<p>В IPv6 выделяется несколько типов адресов:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Глобальный юникаст (Global unicast) – это аналог публичных адресов в IPv4. Большая часть всех адресов относятся именно к этому классу. Эти адреса должны быть уникальными в пределах всей глобальной сети Интернет. Это все адреса, у которых первые три бита равны “001”. Другими словами, у которых первый хекстет лежит в диапазоне от 2000 до 3FFF.</p>
</li>
<li>
<p>Локальные адреса (Link-local) – адреса, использующиеся для взаимодействия с другими устройствами в том же широковещательном домене. Отличительной особенностью этих адресов является то, что трафик «с» или «на» эти адреса не маршрутизируется и в принципе не может выйти за пределы той сети, в которой он был создан. Уникальность от этих адресов не требуется – в каждой сети они могут быть одними и теми же. Адреса применяются для разных специальных целей, например, для процедуры обнаружения соседей (аналог ARP в IPv6). Диапазон таких адресов FE80::/10 – что означает все адреса у которых первый хекстет в диапазоне от FE80 до FEBF.</p>
</li>
<li>
<p>Групповые адреса (Multicast) – адреса, использующиеся для мультикастовой рассылки. Все эти адреса находятся в диапазоне FF00::/8, или всё что начинается с FF.</p>
</li>
<li>
<p>Loopback – специальный адрес ::1. Все пакеты, идущие на него, не выходят за пределы устройства, а попадают обратно на уровень IP. Таким образом, этот адрес аналогичен 127.0.0.1 в IPv4.</p>
<div class="ulist">
<ul>
<li>
<p>Если у вас Linux или MacOS, то можно командой</p>
<div class="literalblock">
<div class="content">
<pre>ping6 ::1</pre>
</div>
</div>
<div class="paragraph">
<p>можно проверить, установлен ли на компьютере IPv6.</p>
</div>
</li>
<li>
<p>А если у вас Windows, то в командной строке наберите</p>
<div class="literalblock">
<div class="content">
<pre>ping ::1</pre>
</div>
</div>
</li>
</ul>
</div>
</li>
</ul>
</div>
<div class="imageblock">
<div class="content">
<img src="tcp_ip/ipv6/images/ping_loopback.png" alt="Команда ping на Loopback IPv6 адрес под ОС Windows.">
</div>
<div class="title">Figure 92. Команда ping на Loopback IPv6 адрес под ОС Windows.</div>
</div>
<div class="ulist">
<ul>
<li>
<p>Неопределенный адрес (Unspecified address) – адрес, состоящий из одних нулей. Записывается в сокращенной форме как ::. Такой адрес не может быть назначен интерфейсу, но может использоваться в некоторых пакетах в качестве адреса отправителя. Например, когда устройство ещё не получило IP адрес с помощью автоматической конфигурации, о ней – тоже в одной из следующих статей.</p>
</li>
<li>
<p>Уникальные локальные адреса (Unique local) – аналог приватных адресов в IPv4, то есть они могут маршрутизироваться в пределах нашей внутренней сети, но в интернет их анонсировать нельзя. Для них выделена сеть</p>
<div class="literalblock">
<div class="content">
<pre>FC00::/7</pre>
</div>
</div>
<div class="paragraph">
<p>Вообще, IPv6 подразумевает отказ от приватных адресов в том смысле, в котором они использовались до этого.</p>
</div>
</li>
<li>
<p>Адреса IPv4, отображенные в IPv6 (IPv4 embedded) – это адреса вида</p>
<div class="literalblock">
<div class="content">
<pre>::FFFF:xxxx:xxxx</pre>
</div>
</div>
<div class="paragraph">
<p>где xxxx:xxxx – это некоторый IPv4 адрес, переведенный в шестнадцатеричный вид. Эти адреса используются для устройств, не поддерживающих IPv6 и обеспечивают способ отображения адресного пространства старой версии протокола в адресное пространство новой. Еще эти адреса называются IPv4-mapped. Подробней о них можно почитать в <a href="https://www.rfc-editor.org/rfc/rfc4291.html#section-2.5.5.2">RFC 4291</a></p>
</div>
</li>
</ul>
</div>
<div class="paragraph">
<p>Если у вас включен IPv6 на хосте, то вы можете увидеть ваши IPv6 адреса на сетевых интерфейсах. Для просмотра IPv6 адреса используется та же команда, что и для просмотра IPv4 адреса. Например, у меня на MacOS адрес</p>
</div>
<div class="literalblock">
<div class="content">
<pre>fe80::49c:1c45:94ae:a37b</pre>
</div>
</div>
<div class="paragraph">
<p>как показано на рисунке ниже.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="tcp_ip/ipv6/images/ipv6_macos.png" alt="IPv6 адрес под MacOS.">
</div>
<div class="title">Figure 93. IPv6 адрес под MacOS.</div>
</div>
<div class="paragraph">
<p>Можно пропинговать свой собственный интерфейс, чтобы убедиться, что все работает. Так как IPv6 адрес моего интерфейса fe80::49c:1c45:94ae:a37b, то я воспользуюсь командой ping:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>ping6 -I en0 fe80::49c:1c45:94ae:a37b</pre>
</div>
</div>
<div class="paragraph">
<p>В моем случае, команде ping нужно указать имя интерфейса, с которого пинговать.</p>
</div>
<div class="paragraph">
<p>Чтобы посмотреть свой IPv6 адрес под Windows, как обычно, воспользуйтесь командой ipconfig.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="tcp_ip/ipv6/images/ipv6_windows.png" alt="IPv6 адрес под Windows.">
</div>
<div class="title">Figure 94. IPv6 адрес под Windows.</div>
</div>
</div>
<div class="sect2">
<h3 id="_префикс_в_ipv6">Префикс в IPv6</h3>
<div class="paragraph">
<p>В сетях IPv4 у нас есть:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Маска подсети</p>
</li>
<li>
<p>Адрес сети</p>
</li>
<li>
<p>Адрес хоста</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Как показано на рисунке ниже.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="tcp_ip/ipv6/images/ipnet_iphost_mask.png" alt="Адрес сети" width="адрес хоста и маска подсети в IPv4.">
</div>
<div class="title">Figure 95. Адрес сети, адрес хоста и маска подсети в IPv4.</div>
</div>
<div class="paragraph">
<p>В сетях IPv6 используются чуть другие термины, как показано на рисунке:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Длина префикса</p>
</li>
<li>
<p>IPv6 префикс</p>
</li>
<li>
<p>Адрес хоста</p>
</li>
</ul>
</div>
<div class="imageblock">
<div class="content">
<img src="tcp_ip/ipv6/images/ipv6_prefix.png" alt="Префикс" width="адрес хоста и длина префикса в IPv6.">
</div>
<div class="title">Figure 96. Префикс, адрес хоста и длина префикса в IPv6.</div>
</div>
<div class="paragraph">
<p>В качестве примера IPv6 адреса я использую свой, который у меня установлен под MacOS. В IPv6 длина префикса (в нашем примере это /64) означает количество бит с начала адреса, которые отводятся под префикс. Остальные биты отводятся под адрес хоста (еще его называют адрес интерфейса). Как видно, длина префикса это что-то похожее на маску подсети.</p>
</div>
<div class="paragraph">
<p>Например, на рисунке выше длина префикса /64, значит сам префикс</p>
</div>
<div class="literalblock">
<div class="content">
<pre>FE80:0000:0000:0000</pre>
</div>
</div>
<div class="paragraph">
<p>Когда выделяете префикс в IPv6 адресе убедитесь, что вы его правильно определили. Для удобства, преобразуйте адрес из короткой записи в полную и только после этого определяйте префикс.</p>
</div>
<div class="paragraph">
<p>Кстати, посмотрите на мой IPv6 адрес, он начинается с <strong>FE80</strong> (и под MacOS и под Windows). Помните, мы совсем недавно говорили, что это локальные адреса (Link-local). Используются для взаимодействия с другими устройствами в той же локальной сети. Отличительной особенностью этих адресов является то, что трафик «с» или «на» эти адреса не маршрутизируется и в принципе не может выйти за пределы той сети, в которой он был создан.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_транспортный_уровень_2">Транспортный уровень</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Транспортный уровень обеспечивает доставку данных между приложениями на хостах.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="tcp_ip/transport_level/images/transport_level.png" alt="Транспортный уровень.">
</div>
<div class="title">Figure 97. Транспортный уровень.</div>
</div>
<div class="paragraph">
<p>Технологии канального уровня обеспечивают доставку данных от одного хоста к другому в рамках сетевого сегмента. Сетевой уровень обеспечивает доставку данных между хостами. И не важно, в одном или в разных сегментах сети находятся эти хосты. А транспортный уровень обеспечивает доставку данных между приложениями.</p>
</div>
<div class="paragraph">
<p>Сейчас на хостах одновременно работают десятки различных приложений. И вот на хост пришел пакет. Для какого приложения он предназначен? Этот и другие вопросы решает транспортный уровень.</p>
</div>
<div class="paragraph">
<p>В стеке TCP/IP на транспортном уровне работают два протокола TCP и UDP. Они оба выполняют одни функции, но по-разному.</p>
</div>
<div class="paragraph">
<p>UDP - протокол без гарантии доставки данных. Если пакет с данными потеряется, то UDP ничего не будет с этим делать. Более того, UDP даже не гарантирует, что пакет будет отправлен с хоста.</p>
</div>
<div class="paragraph">
<p>TCP - протокол транспортного уровня с гарантией доставки данных. Это означает, что если во время обмена данными между хостами будет утерян один или более пакетов, то TCP обнаружит это и восстановит эти данные. Помимо надежности доставки данных TCP заботится о скорости передачи данных.</p>
</div>
<div class="sect2">
<h3 id="_порты">Порты</h3>
<div class="paragraph">
<p>Перед знакомством с TCP и UDP протоколами необходимо познакомиться с понятием порт. Это базовое понятие для транспортного уровня. Сейчас на ПК и ноутбуках одновременно работает несколько десятков приложений. IP протокол доставил данные на хост, а какому приложению их передать?</p>
</div>
<div class="paragraph">
<p>Для идентификации приложения на хосте используются порты (ports). Порт - это поле размером 2 байта (16 бит). Соответственно, максимальный номер порта 65 535 (2 ^ 16).</p>
</div>
<div class="paragraph">
<p>Если приложение хочет принимать или отправлять данные по сети, оно обязано открыть порт. Т.е. оно как бы сообщает операционной системе - если придет пакет с данными на такой-то порт, то это ко мне.</p>
</div>
<div class="paragraph">
<p>Например, по умолчанию веб-сервер (http) открывает порт 80. И все данные, которые приходят на этот порт передаются веб-серверу. А для использования безопасного веб-подключения (https) используется 443 порт.</p>
</div>
<div class="paragraph">
<p>Порт уникально идентифицирует приложение на хосте. Один порт не может быть открыт разными приложениями. Но, одно приложение может открыть несколько портов. Если к этому добавить, что IP адрес уникально идентифицирует хост в сети Интернет, то получается, что пара IP:порт уникально идентифицируют приложение в глобальной сети Интернет.</p>
</div>
<div class="paragraph">
<p>Весь диапазон портов делится на две части:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Привилегированные порты - от 0 до 1023. Эти порты может открыть только администратор или суперпользователь.</p>
</li>
<li>
<p>Пользовательские порты - от 1024 до 65 535. Эти порты может открыть обычный пользователь.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>На привилегированных портах, как правило, работают хорошо известные службы в Интернет, например веб (порт 80), почта (25), DNS (53), безопасный веб (443) и другие.</p>
</div>
<div class="paragraph">
<p>На сайте IANA можно найти список служб и портов, которые за ними закреплены - <a href="https://www.iana.org/assignments/service-names-port-numbers/service-names-port-numbers.xhtml" class="bare">https://www.iana.org/assignments/service-names-port-numbers/service-names-port-numbers.xhtml</a></p>
</div>
</div>
<div class="sect2">
<h3 id="_утилита_netstat">Утилита netstat</h3>
<div class="paragraph">
<p>Посмотреть открытые и активные порты на вашем хосте можно командой netstat. Если у вас Windows, то в командной строке (cmd.exe) наберите <em>netstat -an</em>. В результате вы должны увидеть вывод наподобие того, как на рисунке ниже.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="tcp_ip/transport_level/images/netstat.png" alt="Вывод команды netstat под ОС Windows.">
</div>
<div class="title">Figure 98. Вывод команды netstat под ОС Windows.</div>
</div>
<div class="paragraph">
<p>А если у вас ОС Linux, то посмотреть список активных портов можно командой <em>netstat - anltp</em>.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="tcp_ip/transport_level/images/netstat_linux.png" alt="Вывод команды netstat под ОС Linux.">
</div>
<div class="title">Figure 99. Вывод команды netstat под ОС Linux.</div>
</div>
<div class="paragraph">
<p>Для MacOS команда выглядит как <em>netstat -anl</em>. Вывод будет похож на то, как было показано на рисунках выше.</p>
</div>
<div class="paragraph">
<p>Как видно, вывод команды netstat под разные ОС очень похож.</p>
</div>
<div class="paragraph">
<p>Колонка <strong>Proto</strong> оказывает на протокол транспортного уровня:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>tcp - означает протокол TCP.</p>
</li>
<li>
<p>udp - протокол UDP.</p>
</li>
<li>
<p>tcp6 - означает протокол TCP, который в качестве сетевого уровня использует IPv6.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><strong>Local Address</strong> - это локальный IP адрес и порт, которое использует приложение. Если в этом поле IP адрес равен 0.0.0.0, значит, приложение готово принимать данные, которые придут на любой IP адрес для этого хоста. Это полезно, когда на хосте сконфигурировано несколько IP адресов. Чтобы для каждого IP адреса не делать запись, в netstat добавляют одну 0.0.0.0.</p>
</div>
<div class="paragraph">
<p><strong>Foreign Address</strong> - удаленный IP адрес и порт, другими словами, IP адрес и порт другого приложения, которое взаимодействует с локальным.</p>
</div>
<div class="paragraph">
<p><strong>State</strong> - статус соединения. Только TCP протокол имеет статус соединения. У UDP протокола нет статусов.</p>
</div>
<div class="paragraph">
<p><strong>PID (Process ID)</strong> - идентификатор процесса в системе. Если команду netstat выполнить от суперпользователя, то она также покажет PID и имя программы. Как на рисунке.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="tcp_ip/transport_level/images/netstat_sudo.png" alt="Вывод команды netstat под ОС Linux от суперпользователя.">
</div>
<div class="title">Figure 100. Вывод команды netstat под ОС Linux от суперпользователя.</div>
</div>
<div class="paragraph">
<p>Например, в 5-й строке вывода команды netstat можно видеть</p>
</div>
<div class="literalblock">
<div class="content">
<pre>Local Address 0.0.0.0:80</pre>
</div>
</div>
<div class="paragraph">
<p>а в качестве PID указан nginx. Это веб-сервер NGINX открыл порт 80 и готов обслуживать запросы пользователей.</p>
</div>
<div class="paragraph">
<p>netstat удобная утилита, которая позволяет вам узнать состояния всех ваших портов, а также ответить на вопрос - какое приложение занимает конкретный порт.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
В современных дистрибутивах ОС Linux помимо утилиты netstat можно использовать утилиту ss, например, ss -tuap
</td>
</tr>
</table>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_udp">UDP</h2>
<div class="sectionbody">
<div class="paragraph">
<p>UDP (User Datagram Protocol) - протокол передачи пользовательских датаграмм, описан в <a href="https://datatracker.ietf.org/doc/html/rfc768">RFC 768</a>. Это транспортный протокол и, соответственно располагается на транспортном уровне модели ISO/OSI.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="tcp_ip/udp/images/udp.png" alt="UDP протокол в модели OSI.">
</div>
<div class="title">Figure 101. UDP протокол в модели OSI.</div>
</div>
<div class="paragraph">
<p>UDP обеспечивает передачу данных между приложениями, при этом, он не заботится о надежности доставки данных. Во время передачи UDP пакет может потеряться или  прийти в другом порядке. Более того, UDP пакет может даже не отправиться с хоста, если буфер на отправку будет переполнен.</p>
</div>
<div class="paragraph">
<p>Может показаться, зачем тогда придумали UDP, раз он такой ненадежный? При всех этих недостатках UDP отлично решает задачи, для которых он был придуман:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Передача трафика в реальном времени.</p>
</li>
<li>
<p>Передача данных там, где скорость важней надежности.</p>
</li>
<li>
<p>Передача группового трафика.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Если вы откроете <a href="https://datatracker.ietf.org/doc/html/rfc768">RFC 768</a>, то увидите, что весь протокол описан на 3-х страницах, а сам UDP заголовок занимает всего 8 байт:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Порт источника (2 байта)</p>
</li>
<li>
<p>Порт назначения (2 байта)</p>
</li>
<li>
<p>Размер передаваемых в пакете данных (2 байта)</p>
</li>
<li>
<p>Контрольная сумма (2 байта)</p>
</li>
</ul>
</div>
<div class="imageblock">
<div class="content">
<img src="tcp_ip/udp/images/udp_header.png" alt="UDP заголовок.">
</div>
<div class="title">Figure 102. UDP заголовок.</div>
</div>
<div class="sect2">
<h3 id="_передача_данных_в_реальном_времени">Передача данных в реальном времени</h3>
<div class="paragraph">
<p>UDP протокол отлично подходит для передачи данных в реальном времени. Например, когда идет видео-конференция или когда вы играете в многопользовательскую онлайн игру.</p>
</div>
<div class="paragraph">
<p>Представьте, вы играете в многопользовательскую онлайн-игру (CS, Dota2, StarCraft) и используете надежный протокол доставки данных, например, TCP. Если во время передачи данных потеряется пакет с данными о состоянии игры, то TCP попробует его восстановить, т.е. еще раз передать.</p>
</div>
<div class="paragraph">
<p>Мало того, что во время восстановления потерянного пакета у вас подвиснет игра, так еще и пришедшие данные будут уже неактуальны, ведь состояние сервера к этому моменту станет другим.</p>
</div>
<div class="paragraph">
<p>В то же время, если вы будете использовать UDP протокол, то потеря одного пакета приведет только к легкому зависанию игры (или как говорят лаг). А последующие пришедшие пакеты будут содержать актуальное состояние игрового сервера.</p>
</div>
<div class="paragraph">
<p>Если мы это смоделируем на видеоконференцию, то по мере возникновения потерь и восстановлений пакетов, наблюдаемая видеоконференция будет отдаляться от реальной. Чем больше пакетов будет теряться и восстанавливаться, тем на большее время видеоконференция будет отставать от реальности.</p>
</div>
</div>
<div class="sect2">
<h3 id="_скорость_важней_надежности">Скорость важней надежности</h3>
<div class="paragraph">
<p>UDP протокол оказывается очень полезным, когда скорость передачи важней надежности.</p>
</div>
<div class="paragraph">
<p>Например, UDP протокол используется службой DNS. Эта служба занимается сопоставлением доменного имени к IP адресу. Каждый раз, когда вы в браузере вбиваете название сайта, например miminet.ru, ваш хост обращается к DNS серверу, чтобы узнать IP адрес сервера. Эти DNS запросы в качестве транспорта используют UDP протокол. Почему так? Потому что так эффективней! Давайте посчитаем:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Например, хост делает 10 DNS запросов и получаете 10 DNS ответов, как итог, в сети будет 20 пакетов (10 запросов + 10 ответов).</p>
</li>
<li>
<p>Предположим, что каждый 10-й запрос теряется. Итого, будет 21 пакет (11 запросов и 10 ответов).</p>
</li>
<li>
<p>Если мы будем использовать TCP, только для одного DNS запроса в сети будет 9 пакетов. А 10 запросов приведет к появлению 90 пакетов (почему у TCP будет так много пакетов мы узнаем чуть позже, когда будем знакомиться с работой TCP, а пока просто поверьте).</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>Поэтому, в этом случае эффективней использовать UDP.</p>
</div>
<div class="paragraph">
<p>Другим примером является протокол NTP - это протокол синхронизации времени с сервером времени. NTP так устроен, что требуется подсчитать примерное время доставки пакета от хоста к серверу и в обратную сторону.  В случае потери пакетов с данными лучше это определить самостоятельно, повторно засечь время и сделать повторную попытку. Если в этом случае использовать TCP протокол, то потеря пакета и его восстановление сильно повлияет на расчеты.</p>
</div>
</div>
<div class="sect2">
<h3 id="_передача_группового_трафика">Передача группового трафика</h3>
<div class="paragraph">
<p>UDP единственный протокол транспортного уровня в стеке TCP/IP, который может использоваться для передач группового трафика.</p>
</div>
<div class="paragraph">
<p>Например, у вас есть целый компьютерный класс или новый офис с 50 одинаковыми компьютерами. И на все компьютеры вам нужно установить одинаковую ОС и одинаковое ПО. Как правило, такая задача решается следующим путем:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>На один из 50 компьютеров устанавливается все необходимое ПО.</p>
</li>
<li>
<p>Затем, с помощью специальных утилит создается образ жесткого диска. Его размер может быть более десятков гигабайт.</p>
</li>
<li>
<p>В конце, этот образ жесткого диска по сети загружается на остальные компьютеры. Этот процесс обычно называют “разливка образа”.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>Так вот, финальный этап как раз и решается через мультикаст. Загружать по несколько десятков гигабайт на 50 компьютеров слишком долго. Проще это сделать через групповую рассылку. И в качестве протокола транспортного уровня используется UDP.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="tcp_ip/udp/images/udp_multicast.png" alt="Групповой трафик (мультикаст). (https://miminet.ru/web_network?guid=4fc0fafb-2a16-4244-a664-3f1e8f788a63)">
</div>
<div class="title">Figure 103. Групповой трафик (мультикаст). (<a href="https://miminet.ru/web_network?guid=4fc0fafb-2a16-4244-a664-3f1e8f788a63" class="bare">https://miminet.ru/web_network?guid=4fc0fafb-2a16-4244-a664-3f1e8f788a63</a>).</div>
</div>
</div>
<div class="sect2">
<h3 id="_выводы_по_udp">Выводы по UDP</h3>
<div class="paragraph">
<p>Протокол UDP отлично подходит для передачи данных в реальном времени и для доставки данных при групповой рассылке.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_tcp">TCP</h2>
<div class="sectionbody">
<div class="paragraph">
<p>TCP полная противоположность UDP протоколу, он гарантирует доставку данных и старается это сделать на оптимальной скорости. Сам TCP протокол впервые был описан в <a href="https://datatracker.ietf.org/doc/html/rfc793">RFC 793</a>. На рисунке ниже представлен TCP заголовок, как видно, он содержит намного больше полей чем UDP.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="tcp_ip/tcp/tcp/images/tcp_header.png" alt="TCP заголовок.">
</div>
<div class="title">Figure 104. TCP заголовок.</div>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>Source</strong> и <strong>Destination Port</strong> - это порт источника и порт получателя, с ними мы уже знакомы. Как и в UDP это поле размером по 2 байта.</p>
</li>
<li>
<p><strong>Sequence</strong> и <strong>Acknowledgment Number</strong> - это число последовательности и подтверждения. Они используются для определения потерь и восстановления потерянных данных.</p>
</li>
<li>
<p>Флаги (<strong>URG, ACK, PSH, RST, SYN, FIN</strong>) - указывает на тип передаваемого TCP пакета. Например, флаг ACK говорит о подтверждении операции, а флаг SYN о желании установить виртуальное соединение.</p>
</li>
<li>
<p><strong>Window</strong> - по-русски окно, указывает на размер свободного буфера у отправителя. Используя для контроля скорости передачи данных.</p>
</li>
<li>
<p><strong>Checksum</strong> - контрольная сумма пакета. Если данные будут повреждены во время передачи, контрольная сумма это выявит и такой пакет будет отброшен.</p>
</li>
<li>
<p><strong>Options</strong> - различные опции.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Заголовок TCP без опций занимает 20 байт.</p>
</div>
<div class="paragraph">
<p>В отличие от UDP и IP, TCP протокол с состояниями, на рисунке ниже представлена диаграмма состояний и переходов в TCP. Она довольно внушительная, по ходу дела мы разберемся с ней.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="tcp_ip/tcp/tcp/images/tcp_automata.png" alt="Диаграмма состояний и переходов в TCP.">
</div>
<div class="title">Figure 105. Диаграмма состояний и переходов в TCP.</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_установка_соединения">Установка соединения</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Любая передача данных в TCP начинается с установки виртуального соединения. TCP заботится о надежной доставке данных и, перед тем как начать передавать данные, он пытается установить соединение с удаленным приложением.</p>
</div>
<div class="paragraph">
<p>Возможность установить соединение означает, что на другом конце соединение действительно работает приложение и оно готово к обмену данными.</p>
</div>
<div class="paragraph">
<p>Если соединение установить невозможно, значит на другом конце приложение не готово принимать или отправлять данные, а значит,  нет смысла их отправлять или ожидать приема.</p>
</div>
<div class="paragraph">
<p>Можно провести параллель, установка соединение - это как звонок по телефону. Если пользователь поднимает трубку, значит можно начинать общение, а если нет, то нет никакого смысла что-то говорить в трубку.</p>
</div>
<div class="paragraph">
<p>Установка соединения в TCP это 3-х разовое рукопожатие (рисунок ниже):</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Инициатор отправляет TCP пакет с флагом SYN.</p>
</li>
<li>
<p>Принимающая сторона на такой пакет отвечает TCP пакетом с уже двумя установленными флагами: SYN + ACK.</p>
</li>
<li>
<p>в ответ на SYN + ACK инициатор отправляет TCP пакет с флагом ACK.</p>
</li>
</ul>
</div>
<div class="imageblock">
<div class="content">
<img src="tcp_ip/tcp/connection/images/tcp_connection_success.png" alt="Установка соединения в TCP.">
</div>
<div class="title">Figure 106. Установка соединения в TCP.</div>
</div>
<div class="paragraph">
<p>Таким образом, за 3 пакета TCP устанавливает соединение. После успешной установки соединения TCP может начать принимать и передавать данные.</p>
</div>
<div class="paragraph">
<p>Для примера, давайте сделаем небольшую сеть из двух хостов: клиент и сервер, как показано на рисунке ниже.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="tcp_ip/tcp/connection/images/tcp_conn_success_miminet.png" alt="Установка соединения в TCP и передача данных. (https://miminet.ru/web_network?guid=d35bcad2-b2be-4c2a-9902-26d4edd0bb1d).">
</div>
<div class="title">Figure 107. Установка соединения в TCP и передача данных. (<a href="https://miminet.ru/web_network?guid=d35bcad2-b2be-4c2a-9902-26d4edd0bb1d" class="bare">https://miminet.ru/web_network?guid=d35bcad2-b2be-4c2a-9902-26d4edd0bb1d</a>).</div>
</div>
<div class="paragraph">
<p>На сервере мы запустим TCP сервер на порту 5555. А на клиенте мы запустим передачу данных с использованием протокола TCP на IP адрес сервера и на порт 5555. Передадим 1000 байт данных.</p>
</div>
<div class="paragraph">
<p>Запустим эмуляцию и посмотрим за пакетами в сети. После ARP запроса и ответа мы видим, как хост 1 отправляет на сервер SYN пакет, в ответ приходит SYN+ACK, и завершается установка соединения TCP пакетом с флагом ACK.</p>
</div>
<div class="paragraph">
<p>После установки соединения происходит передача данных и завершение соединения. Эту часть мы разберем чуть позже.</p>
</div>
<div class="paragraph">
<p>А теперь давайте посмотрим, как поведет себя TCP, если на сервере никто не будет ожидать подключения на порт 5555.</p>
</div>
<div class="paragraph">
<p>Опять, сделаем небольшую сеть, как на рисунке ниже, она очень похожа на сеть из предыдущего примера. Только на этот раз на сервере не будем запускать TCP сервер на порту 5555. Т.е. теперь на сервере нет приложения, которое готово обмениваться данными на порту 5555.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="tcp_ip/tcp/connection/images/tcp_conn_reset_miminet.png" alt="Попытка установки TCP соединения на закрытый порт. (https://miminet.ru/web_network?guid=b768b8a6-322e-4520-8a7a-1da02b4cd008).">
</div>
<div class="title">Figure 108. Попытка установки TCP соединения на закрытый порт. (<a href="https://miminet.ru/web_network?guid=b768b8a6-322e-4520-8a7a-1da02b4cd008" class="bare">https://miminet.ru/web_network?guid=b768b8a6-322e-4520-8a7a-1da02b4cd008</a>).</div>
</div>
<div class="paragraph">
<p>Запустим эмуляцию и посмотрим, как будет работать протокол TCP в этом случае.</p>
</div>
<div class="paragraph">
<p>В начале, как обычно, ARP-запрос и ARP-ответ, а после мы видим, как хост 1 отправляет SYN пакет, а в ответ приходит TCP пакет с флагом RST+ACK.</p>
</div>
<div class="paragraph">
<p>Если на хосте нет приложения, которое готова обмениваться данными, то в ответ на SYN пакет TCP отправляет пакет с флагом RST+ACK (Reset, от английского сброс). Как изображено на рисунке ниже.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="tcp_ip/tcp/connection/images/tcp_rst_ack.png" alt="Схема установки TCP соединения на закрытый порт.">
</div>
<div class="title">Figure 109. Схема установки TCP соединения на закрытый порт.</div>
</div>
<div class="paragraph">
<p>Такой способ позволяет программисту очень быстро понять, что удаленная сторона не готова обмениваться данными и обработать эту ситуацию.</p>
</div>
<div class="paragraph">
<p>И напоследок, рассмотрим еще одну ситуацию, когда удаленная сторона не отвечает на SYN пакет. Такое может произойти либо если сервер выключен или на нем настроен фаервол - программа, которая умеет блокировать пакеты с определенным IP адресом и портом.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="tcp_ip/tcp/connection/images/tcp_conn_firewall.png" alt="Попытка установки TCP соединения на хост. который не отвечает. (https://miminet.ru/web_network?guid=c16763e6-1ce8-4d50-b3b8-4261ddc9940b).">
</div>
<div class="title">Figure 110. Попытка установки TCP соединения на хост, который не отвечает. (<a href="https://miminet.ru/web_network?guid=c16763e6-1ce8-4d50-b3b8-4261ddc9940b" class="bare">https://miminet.ru/web_network?guid=c16763e6-1ce8-4d50-b3b8-4261ddc9940b</a>).</div>
</div>
<div class="paragraph">
<p>Опять, сделаем сеть состоящую из двух хостов. На сервере будем блокировать порт 5555. А на хосте, как обычно, выполним команду отправки данных на сервер на порт 5555.</p>
</div>
<div class="paragraph">
<p>Блокировка порта 5555 на сервере приведет к тому, что все TCP и UDP пакеты, у которых в поле порт назначения прописан порт 5555 будут выброшены. Т.е. протоколы TCP и UDP ничего не узнают про этот пакет и не смогут на него отреагировать.</p>
</div>
<div class="paragraph">
<p>Запустим эмуляцию и посмотрим, как TCP пытается установить соединение в этом случае.</p>
</div>
<div class="paragraph">
<p>Если на SYN пакет не следует никакой реакции, т.е. нет SYN+ACK или RST, то TCP считает, что пакет потерялся и нужно попробовать еще раз, т.е. отправить еще один SYN пакет. При этом пауза между отправками увеличивается в два раза. Первый повторный SYN пакет отправляется через 1 секунду, вторая попытка через 2 секунды, затем через 4 и так далее. Как показано на рисунке ниже.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="tcp_ip/tcp/connection/images/tcp_loss_syn.png" alt="Схема установки TCP соединения" width="когда нет ответа.">
</div>
<div class="title">Figure 111. Схема установки TCP соединения, когда нет ответа.</div>
</div>
<div class="paragraph">
<p>Последняя попытка установить зависит от настроек ОС. В современных системах TCP ограничивается 4-мя попытками.</p>
</div>
<div class="paragraph">
<p>Именно по этой причине, можно часто видеть как сетевое приложение зависает при попытке подключиться к удаленному хосту. Оно пытается установить соединение, а в ответ не получает ни SYN+ACK, ни RST+ACK пакета.</p>
</div>
<div class="sect2">
<h3 id="_передача_данных">Передача данных</h3>
<div class="paragraph">
<p>TCP - это протокол потоковой передачи данных, т.е. он передает поток байт, а не готовые датаграммы. Это означает, что TCP сам будет решать, сколько данных разместить в одном передаваемом пакете.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
Во время передачи данных в TCP пакете очень часто можно увидеть установленный флаг PUSH (PSH). Он устанавливается приложением на отправляющей стороне, чтобы обеспечить немедленную отправку данных в сеть, без буферизации. Установленный на пакете флаг PSH указывает принимающей стороне на необходимость доставки полученных данных на уровень приложений (в конечное приложение) немедленно по получении, без укладки данных в буфер и ожидания новых данных.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Передача данных в TCP происходит с подтверждением, т.е. после каждого переданного пакета с данными TCP ожидает подтверждения о том, что данные были успешно приняты удаленной стороной. Для надежной передачи данных TCP используется два поля:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Sequence Number -  номер  последовательности</p>
</li>
<li>
<p>Acknowledgment Number - номер подтверждения</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Оба эти поля находятся в заголовке TCP протокола, как показано на рисунке ниже.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="tcp_ip/tcp/send_recv_data/images/tcp_header.png" alt="TCP заголовок.">
</div>
<div class="title">Figure 112. TCP заголовок.</div>
</div>
<div class="paragraph">
<p>Эти поля занимают по 4 байта (32 бита) каждый. Лучше всего представить эти поля, как указатели на буфер. Напомню, что буфер это временная память, которую выделяют программы для хранения временных данных.</p>
</div>
</div>
<div class="sect2">
<h3 id="_номер_последовательности_sequence_number">Номер последовательности (Sequence Number)</h3>
<div class="paragraph">
<p>Что, если во время передачи данных ваши пакеты каким-то образом перепутались и пришли к получателю в перепутанном порядке? В этом случае, получатель перепутает последовательность данных и расположит полученные данные в неправильном порядке.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="tcp_ip/tcp/send_recv_data/images/tcp_sequence_number.png" alt="TCP пакеты пришли в неправильном порядке.">
</div>
<div class="title">Figure 113. TCP пакеты пришли в неправильном порядке.</div>
</div>
<div class="paragraph">
<p>Решить такую проблему можно нумерацией пакетов. Но такой подход приведет к появлению другой проблемы. Если мы будем использовать нумерацию пакетов, чтобы защититься от проблемы перепутанных пакетов, то все пакеты должны будут быть одинакового размера. К примеру, мы первым получим пакет №3 (красный на рисунке выше), на сколько байт мы должны отступить от начала буфера, чтобы разместить данные?</p>
</div>
<div class="paragraph">
<p>Для решения проблемы с перепутанными пакетами используется номер последовательности (Sequence number). Номер последовательности (Sequence number) - указывает на позицию начала передаваемых данных в буфере отправителя. Предположим, TCP отправил 2800 байт данных в 3-х пакетах. Размер передаваемых байт в пакетах 1000 байт,  800 байт и 1000 байт соответственно.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>При отправке первого пакета с данными номер последовательности будет 0.</p>
</li>
<li>
<p>У второго пакета с данными это поле будет установлено в 1000.</p>
</li>
<li>
<p>А при отправке третьего пакета номер последовательности будет установлен в 1800. Как это показано на рисунке ниже.</p>
</li>
</ul>
</div>
<div class="imageblock">
<div class="content">
<img src="tcp_ip/tcp/send_recv_data/images/tcp_seq_example.png" alt="Номер последовательности в TCP заголовке.">
</div>
<div class="title">Figure 114. Номер последовательности в TCP заголовке.</div>
</div>
<div class="paragraph">
<p>Таким образом, принимающая сторона всегда сможет правильно разместить пришедшие данные, даже если пакеты перепутались. Например, принимающий хост получил эти TCP пакеты в следующем порядке: 3, 1, 2.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="tcp_ip/tcp/send_recv_data/images/tcp_seq_example_2.png" alt="TCP правильно располагает данные благодаря номеру последовательности.">
</div>
<div class="title">Figure 115. TCP правильно располагает данные благодаря номеру последовательности.</div>
</div>
<div class="paragraph">
<p>У пакета №3 номер последовательности будет 1800, это означает, что TCP на принимающей стороне разместит эти данные со смещением в 1800 байт.</p>
</div>
<div class="paragraph">
<p>После этого приходит пакет №1, его номер последовательности 0 и TCP разместит эти данные в начале буфера. Последним придет пакет №2, у которого номер последовательности равен 1000. Значит, эти данные будут размещены со смещением в 1000 байт. Этот процесс изображен на рисунке выше.</p>
</div>
<div class="paragraph">
<p>Таким образом, номер последовательности в TCP позволяет размещать данные в буфере принимающей стороны в правильном порядке, даже если сами пакеты придут в перемешанном порядке.</p>
</div>
<div class="paragraph">
<p>Возникает естественный вопрос, а что делать, если пришедшие данные наложились друг на друга? Или, что если хост получит два TCP пакета, у которых будет одинаковый номер смещения, но разные данные? RFC никак не описывает этот момент. Поэтому, разные реализации TCP протокола ведут себя по-разному. В каких-то ОС оставляются более старые данные, а какие-то перезаписывают более новыми.</p>
</div>
</div>
<div class="sect2">
<h3 id="_номер_подтверждения_acknowledgment_number">Номер подтверждения (Acknowledgment Number)</h3>
<div class="paragraph">
<p>Протокол TCP должен обеспечивать надежную доставку данных. И это касается не только данных, которые перемешались во время передачи. Надежность так же включает решения проблемы с потерей данных.</p>
</div>
<div class="paragraph">
<p>Для начала, давайте разберемся, как же работает это поле с номером  подтверждения (Acknowledgment Number). Каждый раз, когда TCP протокол отправляет пакет с данными, он ожидает от удаленной стороны подтверждения (флаг ACK) о том, что данные были успешно доставлены. А номер подтверждения в таком пакете будет указывать на позицию следующую за последним полученным байтом. При этом, учитываются только непрерывно полученные байты.</p>
</div>
<div class="paragraph">
<p>Если хост принял TCP пакет с данными, у которого номер последовательности 0 и размер данных будет равен 1000 байт, то номер подтверждения будет равен 1000. 1000-й байт с позиции 0 будет располагаться на позиции 999. Следующая позиция после 999 будет 1000.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="tcp_ip/tcp/send_recv_data/images/tcp_ack.png" alt="Номер подтверждения (Ack) в TCP.">
</div>
<div class="title">Figure 116. Номер подтверждения (Ack) в TCP.</div>
</div>
<div class="paragraph">
<p>Еще раз воспользуемся нашим примером. Пусть TCP отправил 2800 байт данных в 3-х пакетах. Количество передаваемых байт в пакетах 1000 байт, 800 байт и 1000 байт соответственно.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>При отправке первого пакета с данными номер последовательности будет 0.</p>
</li>
<li>
<p>У второго пакета с данными это поле будет установлено в 1000.</p>
</li>
<li>
<p>А при отправке третьего пакета номер последовательности будет установлен в 1800.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Обмен TCP пакетами между хостами в таком случае будет как на рисунке ниже.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="tcp_ip/tcp/send_recv_data/images/tcp_seq_ack.png" alt="Обмен данными в TCP.">
</div>
<div class="title">Figure 117. Обмен данными в TCP.</div>
</div>
<div class="ulist">
<ul>
<li>
<p>Клиент отправляет на сервер TCP пакет с данными:</p>
<div class="ulist">
<ul>
<li>
<p>Номер последовательности равен 0.</p>
</li>
<li>
<p>Размер передаваемых данных равен 1000 байт.</p>
</li>
</ul>
</div>
</li>
<li>
<p>Сервер, получив TCP пакет с данными, размещает их в своем буфере на прием и отправляет TCP пакет с подтверждением (флаг ACK), где номер подтверждения (поле Ack, не путать с флагом ACK) равен 1000.</p>
</li>
<li>
<p>Клиент отправляет на сервер TCP пакет с данными:</p>
<div class="ulist">
<ul>
<li>
<p>Номер последовательности равен 1000.</p>
</li>
<li>
<p>Размер передаваемых данных равен 800.</p>
</li>
</ul>
</div>
</li>
<li>
<p>Сервер, получив такой пакет, отправляет пакет с подтверждением, где номер подтверждения будет равен 1800.</p>
</li>
<li>
<p>И так далее.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Что если во время передачи данных с использованием протокола TCP произошла потеря пакета? Давайте рассмотрим эту ситуацию на нашем примере. Пусть TCP отправил 2800 байт данных в 3-х пакетах. Количество передаваемых байт в пакетах 1000 байт, 800 байт и 1000 байт соответственно.</p>
</div>
<div class="paragraph">
<p>Предположим, что второй пакет потерялся во время передачи. В схеме работы TCP, потерей пакета считается отсутствие подтверждения на передаваемый пакет. Т.е. когда отправитель не получил пакет с флагом ACK в ответ на переданные данные (смотри рисунок ниже).</p>
</div>
<div class="imageblock">
<div class="content">
<img src="tcp_ip/tcp/send_recv_data/images/tcp_seq_ack_lost.png" alt="Обнаружение потери в TCP путем отсутствия подтверждения.">
</div>
<div class="title">Figure 118. Обнаружение потери в TCP путем отсутствия подтверждения.</div>
</div>
<div class="paragraph">
<p>Если TCP не получает подтверждения на отправленные данные, то считается, что пакет потерялся и TCP снова отправляет пакет с потерявшимися данными. Таймаут ожидания подтверждения зависит от ОС и ее настроек.</p>
</div>
<div class="paragraph">
<p>Обратите внимание, в примере на рисунке выше мы точно не знаем что произошло. Может быть потерялся пакет с данными, а может быть данные дошли до сервера, но потерялся пакет с подтверждением. Оба эти случая считаются одним - отправитель не получил подтверждения за отведенное время (таймаут) и повторно отправляет данные.</p>
</div>
<div class="paragraph">
<p>Итого, номера последовательности и подтверждения используются  для надежной передачи данных и обнаружения потерь. Номер последовательности (Sequence Number) -  позволяет принимающей стороне правильно размещать полученные данные в буфере. А номер подтверждения (Acknowledgment Number) помогает отправителю понять, успешно ли дошли данные до получателя или имеется потеря.</p>
</div>
</div>
<div class="sect2">
<h3 id="_начальное_значение_номера_последовательности">Начальное значение номера последовательности</h3>
<div class="paragraph">
<p>Если посмотреть на номер последовательности сразу после установки соединения, то можно заметить, что оно не равно 0. Его начальное значение, обычно, случайное. Т.е. во время установки соединение обе стороны устанавливают номер последовательности в случайное значение и это значение считается 0. Это сделано для более безопасного соединения и предотвращению атаки TCP-hijacking.</p>
</div>
</div>
<div class="sect2">
<h3 id="_скорость_передачи_данных">Скорость передачи данных</h3>
<div class="paragraph">
<p>Передавать данные по одному пакету и ожидать на него подтверждения надежно, но очень медленно. Давайте посчитаем.</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Расстояние между Владивостоком и Калининградом примерно 7500 км., а туда и обратно будет уже 15 000 км.</p>
</li>
<li>
<p>Для простоты, предположим, что сигнал от хоста во Владивостоке до сервера в Калининграде будет идти со скоростью света (~ 300 000 км/сек). А обработка пакетов будет занимать 0 времени.</p>
</li>
<li>
<p>Тогда получится, что за одну секунду сигнал успеет сбегать туда и обратно 20 раз. Т.е., за 1 секунду мы сможем отправить 20 пакетов и получить 20 подтверждений.</p>
</li>
<li>
<p>Максимальный размер одного пакета 1500 байт - 20 байт IP заголовок - 20 байт TCP заголовок. Остается, 1460 байт данных. 1460 * 20 = 29 200 байт данных. Т.е. скорость передачи данных будет около 28 Кбайт/сек (29 200 / 1024).</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>Добро пожаловать во времена модемов! А если серьезно, то скачивать данные на такой скорости не хочется. А ведь сервер может располагаться и дальше, чем Калининград.</p>
</div>
<div class="paragraph">
<p>Для ускорения передачи данных в TCP необходимо передавать по несколько пакетов с данными, до того, как придет подтверждение. Как это показано на рисунке ниже.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="tcp_ip/tcp/send_recv_data/images/tcp_send_many.png" alt="Передача сразу нескольких пакетов с данными в TCP.">
</div>
<div class="title">Figure 119. Передача сразу нескольких пакетов с данными в TCP.</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_скользящее_окно_sliding_window">Скользящее окно (Sliding Window)</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Решение отправлять сразу несколько пакетов для увеличения скорости передачи данных очевидное, но есть проблема. Несколько пакетов - это сколько, 2, 5, 15 или можно сразу 150? Как узнать?</p>
</div>
<div class="paragraph">
<p>Во время обмена данными между хостами, получаемые данные не попадают сразу в приложение пользователя. Сначала они попадают в буфер приема и только потом, оттуда, они попадают в пользовательское приложение.</p>
</div>
<div class="paragraph">
<p>Современные ОС многопользовательские, поэтому, во время получения пакета для приложения А, на процессоре может исполняться совсем другое приложение. И чтобы полученные данные не выбрасывать, они помещаются во временную память - буфер для приема данных.</p>
</div>
<div class="paragraph">
<p>Этот буфер не бесконечный, поэтому, если данных придет больше, чем в него помещается, то они будут отбрасываться до тех пор, пока в буфере не освободится место.</p>
</div>
<div class="paragraph">
<p>Для избежания переполнения буфера во время приема пакетов в TCP заголовке есть поле Окно (Window), его еще называют Скользящее окно (Sliding Window). Это поле размером в 2 байта (16 бит) и оно сообщает о размере свободного места в буфере на прием. Изначально это место измерялось в байтах. Соответственно, максимальное значение было 65 535 байт. Как не сложно догадаться, теперь этого недостаточно и сейчас используются различные опции, которые позволяют передавать в поле Окно большие значения.</p>
</div>
<div class="paragraph">
<p>Для тех, кому интересно, ищите по ключевым словам:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Window scaling</p>
</li>
<li>
<p><a href="https://datatracker.ietf.org/doc/html/rfc7323">RFC 7323</a></p>
</li>
<li>
<p><a href="https://datatracker.ietf.org/doc/html/rfc1323">RFC 1323</a></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>А мы продолжим. Давайте нарисуем небольшую сеть из двух хостов, как показано на рисунке ниже.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="tcp_ip/tcp/sliding_window/images/2_host_data_exchange.png" alt="Обмен данными по TCP в сети из двух хостов. (https://miminet.ru/web_network?guid=63f69e1e-81ab-43e3-832a-876fc7c8c6f1).">
</div>
<div class="title">Figure 120. Обмен данными по TCP в сети из двух хостов. (<a href="https://miminet.ru/web_network?guid=63f69e1e-81ab-43e3-832a-876fc7c8c6f1" class="bare">https://miminet.ru/web_network?guid=63f69e1e-81ab-43e3-832a-876fc7c8c6f1</a>)</div>
</div>
<div class="paragraph">
<p>Итак, поле Window сообщает информацию о размере свободного места в буфере на прием. Во время установки соединения (3-х разовое рукопожатие: SYN, SYN+ACK, ACK) обе стороны обмениваются информацией о свободном месте в их буфере на прием.</p>
</div>
<div class="paragraph">
<p>После установки соединения отправитель может смело отправить столько пакетов с данными без подтверждения, сколько поместится в буфер на прием у получателя.</p>
</div>
<div class="paragraph">
<p>Отправка данных приведет к уменьшению этого буфера. Но когда приложение на удаленной стороне прочитает данные из буфера, это приведет к освобождению места в буфере, что приведет и к увеличению Window.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="tcp_ip/tcp/sliding_window/images/window.png" alt="Поле Window в TCP - это размер буфера на прием.">
</div>
<div class="title">Figure 121. Поле Window в TCP - это размер буфера на прием.</div>
</div>
<div class="paragraph">
<p>Предположим мы установили TCP соединение и удаленная сторона сообщила свой Window = 4380 байт (это 3 раза по 1460 байт). Это означает, что мы можем сразу отправить 3 TCP сегмента с данными без ожидания подтверждения, как показано на рисунке ниже.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="tcp_ip/tcp/sliding_window/images/window_2.png" alt="TCP отправляет сразу 3 сегмента с данными.">
</div>
<div class="title">Figure 122. TCP отправляет сразу 3 сегмента с данными.</div>
</div>
<div class="paragraph">
<p>На рисунке выше отправитель отправил сразу 3 сегмента с данными до того, как получил хотя бы одно подтверждения. Если все данные придут, это будет означать, что свободного места в буфере у принимающей стороны больше нет. По мере того как будут приходить подтверждения мы увидим, что поле Window уменьшается до 0. После получения первого сегмента оно станет 2920, после второго сегмента 1460 и после получения третьего сегмента поле Window станет 0.</p>
</div>
<div class="paragraph">
<p>Для отправителя это будет означать, что пока больше никаких данных отправлять нельзя. Ситуация изменится, когда приложение на удаленной стороне прочитает данные из буфера на прием. Предположим, наше приложение прочитало всего 2920 байт данных (зеленый кусок), а 1460 еще находятся в буфере, как показано на рисунке ниже.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="tcp_ip/tcp/sliding_window/images/window_3.png" alt="Приложение прочитало 2920 байт данных (зеленый).">
</div>
<div class="title">Figure 123. Приложение прочитало 2920 байт данных (зеленый).</div>
</div>
<div class="paragraph">
<p>Теперь TCP может сообщить отправителю, что буфер освободился и он снова готов принять 2920 байт данных.</p>
</div>
<div class="paragraph">
<p>Таким образом, наше окно как бы сдвигается вправо, отсюда и название "Скользящее окно".</p>
</div>
<div class="paragraph">
<p>В современных системах размер буфера обычно несколько мегабайт, что позволяет передавать данные на достаточно большой скорости.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="tcp_ip/tcp/sliding_window/images/2_host_data_exchange_2.png" alt="Обмен данными по TCP в сети из двух хостов. (https://miminet.ru/web_network?guid=b362d63e-6207-4991-b10c-dadc0c4c4144).">
</div>
<div class="title">Figure 124. Обмен данными по TCP в сети из двух хостов. (<a href="https://miminet.ru/web_network?guid=b362d63e-6207-4991-b10c-dadc0c4c4144" class="bare">https://miminet.ru/web_network?guid=b362d63e-6207-4991-b10c-dadc0c4c4144</a>).</div>
</div>
<div class="paragraph">
<p>Еще раз сделаем сеть из двух хостов, только на этот раз передадим 5000 байт данных. Если вы запустите анимацию такой сети, то увидите, что хост 1 сразу отправляет пакеты с данными, не дожидаясь подтверждения.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_узкое_горлышко">Узкое горлышко</h2>
<div class="sectionbody">
<div class="imageblock">
<div class="content">
<img src="tcp_ip/tcp/bottleneck/images/bottleneck.png" alt="Сеть из 2-х хостов и одного сервера. (https://miminet.ru/web_network?guid=f2289c94-2fcd-4d2a-9db5-560cb5f81a23).">
</div>
<div class="title">Figure 125. Сеть из 2-х хостов и одного сервера. (<a href="https://miminet.ru/web_network?guid=f2289c94-2fcd-4d2a-9db5-560cb5f81a23" class="bare">https://miminet.ru/web_network?guid=f2289c94-2fcd-4d2a-9db5-560cb5f81a23</a>).</div>
</div>
<div class="paragraph">
<p>Пусть скорость подключения хостов и сервера одинаковая, например, 100 Мбит/сек. Если хост 1 будет обмениваться данными с сервером на скорости 60 Мбит/сек. То если хост 2 захочет отправить данные на сервер он столкнется с проблемами, его скорость передачи данных не может быть больше 40 Мбит/сек. Даже если на сервере есть свободное место в буфере на прием данных. Так как подключение сервера до свитча всего 100 Мбит/сек.</p>
</div>
<div class="paragraph">
<p>Еще одна, вполне жизненная ситуация, когда у вас скорость подключения к вашему домашнему роутеру больше, чем скорость, которую предоставляет вам провайдер. Например, вы подключились к своему домашнему Wi-FI роутеру по стандарту IEEE 802.11n (скорость до 600 Мбит/сек), а у вашего провайдера вы купили тариф, по которому скорость передачи данных не более 10 Мбит/сек. Значит, при обмене данными с серверами из сети Интернет вы не сможете отправлять данные быстрей, чем 10 Мбит/сек. А если у вас дома есть еще и другие сетевые устройства (ноутбук, телефоны, …), то ваша скорость передачи данных будет еще меньше.</p>
</div>
<div class="paragraph">
<p>Все это означает, что во время передачи данных по TCP нельзя ориентироваться только на размер свободного места в буфере на прием.</p>
</div>
<div class="paragraph">
<p>Задача TCP, определить самое узкое место на пути следования пакета (узкое горлышко, bottleneck) и ограничить скорость передачи данных пропускной способностью этого места.</p>
</div>
<div class="paragraph">
<p>Как определить узкие места в сети без информации о топологии сети? На самом деле нет нужды определять где именно находится узкое горлышко, достаточно определить, что оно где-то есть и адаптировать скорость передачи данных.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="tcp_ip/tcp/bottleneck/images/bottleneck.png" alt="Сеть из 2-х хостов и одного сервера. (https://miminet.ru/web_network?guid=f2289c94-2fcd-4d2a-9db5-560cb5f81a23).">
</div>
<div class="title">Figure 126. Сеть из 2-х хостов и одного сервера. (<a href="https://miminet.ru/web_network?guid=f2289c94-2fcd-4d2a-9db5-560cb5f81a23" class="bare">https://miminet.ru/web_network?guid=f2289c94-2fcd-4d2a-9db5-560cb5f81a23</a>).</div>
</div>
<div class="paragraph">
<p>Давайте еще раз посмотрим на рисунок выше. Разбирая этот пример мы предположили, что хост 1 передает на сервер данные со скоростью 60 Мбит/сек, а хост 2 передает на сервер данные со скоростью 40 Мбит/сек. Узким горлышком на схеме будет подключение сервера к свитчу.</p>
</div>
<div class="paragraph">
<p>На свитч от хоста 1 и хоста 2 данные могут приходить со скоростью по 100 Мбит/сек от каждого, итого, суммарно, 200 Мбит/сек. А выходная скорость от свитча к серверу всего 100 Мбит/сек.</p>
</div>
<div class="paragraph">
<p>Если сетевое оборудование не успевает передавать пакеты в сеть, оно начинает их размещать в буфере на отправку и ждать, пока освободится канал для передачи. Как это показано на рисунке ниже.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="tcp_ip/tcp/bottleneck/images/switch_buffer.png" alt="Свитч буферизирует пакеты" width="которые не успевает передавать.">
</div>
<div class="title">Figure 127. Свитч буферизирует пакеты, которые не успевает передавать.</div>
</div>
<div class="paragraph">
<p>На рисунке пакеты 1 и 2 успешно передаются на хост, а пакеты 3 и 4 расположись в буфере на отправку. Это означает, что время доставки пакетов 3 и 4 до сервера будет больше, чем время доставки пакетов 1 и 2. Чем больше пакетов будет в буфере на отправку, тем больше будет время их доставки.</p>
</div>
<div class="paragraph">
<p>Таким образом, измеряя время доставки пакетов можно обнаружить момент попадания пакетов в буфер и начать снижать скорость передачи данных.</p>
</div>
<div class="paragraph">
<p>Еще одним способ определения узкого горлышка является потеря пакета. Если во время передачи данных пакет потерялся, значит есть большая вероятность того, что он не поместился даже в буфер и был отброшен устройством.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_контроль_переполнения_congestion_control">Контроль переполнения (Congestion control)</h2>
<div class="sectionbody">
<div class="paragraph">
<p>В TCP протоколе на пакет с данными приходит пакет с подтверждением о его доставке (флаг ACK). Соответственно, замеряя время отправки пакета с данными и время получения подтверждения на этот пакет, мы можем определять узкое горлышко.</p>
</div>
<div class="paragraph">
<p>Время, которое необходимо для отправки пакета и получения на него подтверждения называется RTT (Round-Trip Time). Еще его называют время приема-передачи.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="tcp_ip/tcp/congestion/images/rtt.png" alt="RTT - приема-передачи.">
</div>
<div class="title">Figure 128. RTT - приема-передачи.</div>
</div>
<div class="paragraph">
<p>Если во время передачи данных RTT начинает расти, значит где-то по пути пакеты начинают копиться в буфере на отправку. А значит, нужно уменьшать скорость передачи данных.</p>
</div>
<div class="paragraph">
<p>Скорость передачи данных в TCP регулируется алгоритмом, который называется “Контроль переполнения”. По-английски это Congestion control. Иногда его переводят как контроль скопления.</p>
</div>
<div class="paragraph">
<p>Этот алгоритм оперирует следующими параметрами:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Скользящее окно</p>
</li>
<li>
<p>RTT</p>
</li>
<li>
<p>Потеря пакета</p>
</li>
<li>
<p>Окно переполнения (Congestion Window или сокращенно CWND)</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Из всего перечисленного мы еще не знакомы только с Окном переполнения. Окно переполнения по сути и определяет скорость передачи данных по TCP. Этот параметр в алгоритме определяет, сколько пакетов с данными можно отправить в сеть до того, как получим подтверждение на них. Чем больше таких пакетов с данными мы отправим, тем больше будет скорость передачи.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="tcp_ip/tcp/congestion/images/cwnd.png" alt="Слева CWND = 1" width="справа CWND = 3.">
</div>
<div class="title">Figure 129. Слева CWND = 1, справа CWND = 3.</div>
</div>
<div class="paragraph">
<p>CWND это такой параметр, который с одной стороны всегда хочет разогнаться еще, а с другой, смотрит, не нужно ли притормозить. Тормозами выступают значительное увеличение RTT, потеря пакета и ограничение скользящего окна. Ну а разгон определяется как противоположность тормозу. Если никто не тормозит, значит разгоняемся.</p>
</div>
<div class="paragraph">
<p>Таким образом, используя RTT, скользящее окно и обнаружение потери пакета, TCP адаптирует свою скорость передачи данных.</p>
</div>
<div class="sect2">
<h3 id="_алгоритмы_контроля_переполнения">Алгоритмы контроля переполнения</h3>
<div class="paragraph">
<p>На сегодняшний день существует более 20 различных реализаций алгоритмов переполнения.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="tcp_ip/tcp/congestion/images/congestion_alos.png" alt="Алгоритмы переполнения в TCP (https://en.wikipedia.org/wiki/TCP_congestion_control).">
</div>
<div class="title">Figure 130. Алгоритмы переполнения в TCP (<a href="https://en.wikipedia.org/wiki/TCP_congestion_control" class="bare">https://en.wikipedia.org/wiki/TCP_congestion_control</a>).</div>
</div>
<div class="paragraph">
<p>Они отличаются друг от друга начальным значением CWND, до какого уровня действует фаза низкий старт, при каком отклонении RTT начинать снижать скорость и так далее. А некоторые алгоритмы адаптированы под спутниковые каналы (Long Fat Pipes).</p>
</div>
<div class="paragraph">
<p>Сеть постоянно меняется, меняются каналы передачи данных, сервисы. Поэтому, появляются новые реализации алгоритма контроля переполнения.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_низкий_старт_slow_start">Низкий старт (Slow start)</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Последнее, о чем стоит упомянуть при разборе скорости передачи данных в TCP - это медленный старт.</p>
</div>
<div class="paragraph">
<p>Когда мы говорим про CWND (количество пакетов, которые можно отправить до получения подтверждения), то есть два интересных вопроса:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Какое начальное значение CWND?</p>
</li>
<li>
<p>С какой скоростью он будет расти?</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Вот допустим у нас начальное значение CWND 1, хорошо. Мы отправили пакет с данными и получили подтверждение. Выяснили, что нас никто не тормозит и мы можем разогнаться. Каким поставить следующее значение CWND: 2, 4, 10?</p>
</div>
<div class="paragraph">
<p>Вначале скорость роста CWND экспоненциальная и эта фаза называется Slow start (низкий старт). Как только CWND доходит до определенного предела, скорость роста становится линейной и эта фаза называется Congestion Avoidance (избежание переполнения).</p>
</div>
<div class="imageblock">
<div class="content">
<img src="tcp_ip/tcp/slow_start/images/slow_start.jpg" alt="Низкий старт в TCP.">
</div>
<div class="title">Figure 131. Низкий старт в TCP.</div>
</div>
<div class="paragraph">
<p>Таким образом, находясь на низкой скорости TCP пытается как можно быстрей разогнаться до чего-то приемлемого. А уже после, пытаться адаптироваться и контролировать скорость.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
Во всей (из того, что я видел) литературе Slow start переведен как “Медленный старт”. Хотя как он может быть медленный, если он разгоняется экспоненциально? Считаю, что перевод низкий старт более уместен.
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_алгоритм_нагла_nagle_algorithm">Алгоритм Нагла (Nagle algorithm)</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Алгоритм Нагла или еще его называют Алгоритм Нейгла или <a href="https://datatracker.ietf.org/doc/html/rfc896">RFC 896</a>, в которой он был впервые описан. Нагл работал над увеличением эффективности TCP/IP. Наблюдая за работой сети он обнаружил, что сетевые устройства довольно часто не справлялись со входящим трафиком и начинали размещать пакеты в буфере на отправку. Т.е. происходило переполнение, увеличивался RTT и отправитель начинал снижать скорость отправки новых пакетов в сети. При этом, объем передаваемых данных был не так уж и велик.</p>
</div>
<div class="paragraph">
<p>При детальном наблюдении оказалось, что в сеть очень часто отправлялись TCP пакеты с маленьким объемом данных, иногда даже с 1 байтом. Передача TCP пакета с 1 байтом полезных данных приводит к огромным накладным расходам в 5400% (20 байт TCP заголовок + 20 байт IP заголовок + 14 байт Ethernet заголовок).</p>
</div>
<div class="paragraph">
<p>Идея алгоритма Нагла в уменьшении количества маленьких TCP пакетов в сети. Нагл предложил алгоритм, который должен задерживать отправку небольших порций данных в сеть, если у отправителя есть неподтвержденные данные (т.е. отправитель еще не получил на них пакет с флагом ACK).</p>
</div>
<div class="imageblock">
<div class="content">
<img src="tcp_ip/tcp/nagle/images/nagle.png" alt="Обмен данными с выключенным (левый рисунок) и включенным (правый рисунок) алгоритмом Нагла.">
</div>
<div class="title">Figure 132. Обмен данными с выключенным (левый рисунок) и включенным (правый рисунок) алгоритмом Нагла.</div>
</div>
<div class="paragraph">
<p>На рисунке показано, как алгоритм Нагла уменьшает количество небольших пакетов в сети. Слева на рисунке клиент хочет передать на сервер слово HELLO, при этом, он отправляет по одной букве. Сначало отправляется “H”, потом “E”, затем “L” и так далее. Если алгоритм Нагла будет выключен, то клиент будет отправлять эти буквы в тот момент, когда поступила такая команда от программы (команда send). При условии, что есть такая возможность.</p>
</div>
<div class="paragraph">
<p>На рисунке справа алгоритм Нагла включен и мы видим, как клиент отправив одну букву “H”, ждет, пока придет подтверждение. Он не отправляет мелкие пакеты в сеть, а копит эти данные. Он отправит накопленные данные:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Когда данные будут подтверждены (придет ACK на “H”).</p>
</li>
<li>
<p>Или когда данных накопится достаточно, чтобы отправить целый пакет.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>В нашем случае мы ждем подтверждения и только потом отправляем накопившийся буфер “ELLO”.</p>
</div>
<div class="paragraph">
<p>Алгоритм Нагла выглядит вот так:</p>
</div>
<div class="literalblock">
<div class="content">
<pre> if there is new data to send then
    if the window size ≥ MSS and available data is ≥ MSS then
        send complete MSS segment now
    else
        if there is unconfirmed data still in the pipe then
            enqueue data in the buffer until an acknowledge is received
        else
            send data immediately
        end if
    end if
end if</pre>
</div>
</div>
<div class="paragraph">
<p>Алгоритм Нагла - <a href="https://en.wikipedia.org/wiki/Nagle%27s_algorithm" class="bare">https://en.wikipedia.org/wiki/Nagle%27s_algorithm</a></p>
</div>
<div class="sect2">
<h3 id="_когда_стоит_отключать_алгоритма_нагла">Когда стоит отключать алгоритма Нагла</h3>
<div class="paragraph">
<p>Алгоритм Нагла не всегда полезен. Если у вас интерактивный трафик, например, вы подключились через консоль на удаленный сервер или через удаленный рабочий стол. В этом случае нужно, чтобы интерфейс был отзывчивым для этого необходимо отключать алгоритм Нагла в приложении.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_icmp">ICMP</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Во время передачи данных в сети могут возникать ошибки. И эти ошибки могут быть спонтанными и постоянными. Следствием таких ошибок, обычно, является потеря пакета. Пример спонтанной ошибки - помехи во время передачи сигнала или переполнение буфера на прием пакетов у маршрутизатора. Если хост повторно отправит пакет, то со второго раза он скорее всего дойдет до конечного адресата.</p>
</div>
<div class="paragraph">
<p>А есть постоянные ошибки, которые часто связаны с неверной настройкой сети. Например, во время пересылки пакета через маршрутизатор у пакета закончился TTL (стал равен 0) и маршрутизатор выбрасывает такой пакет. Сколько бы раз TCP не пытался восстановить потерянный пакет, у него ничего не получиться. Ведь каждый раз пакет будет проходить через тот-же маршрутизатор и отбрасываться.</p>
</div>
<div class="paragraph">
<p>Как итог, пользователь или программист решит, что проблема на сервере, так как не смог к нему подключиться. Но на самом деле, проблема в невозможности доставить пакет между этими двумя хостами.</p>
</div>
<div class="paragraph">
<p>ICMP (Internet Control Message Protocol) - протокол помогает определить ошибки на сетевом и транспортном  уровне. ICMP протокол описан в RFC 792 и является неотъемлемой частью TCP/IP стека.</p>
</div>
<div class="paragraph">
<p>ICMP работает поверх IP протокола, но при этом является протоколом сетевого уровня, как показано на рисунке ниже. Его относят к сетевому уровню, так как он по большей части решает проблемы на сетевом уровне.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="tcp_ip/icmp/icmp/images/icmp_osi.png" alt="ICMP протокол в модели ISO/OSI.">
</div>
<div class="title">Figure 133. ICMP протокол в модели ISO/OSI.</div>
</div>
<div class="paragraph">
<p>На рисунке 127 изображен формат заголовка ICMP. Как видно, ICMP заголовок занимает всего 16 байт.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="tcp_ip/icmp/icmp/images/icmp_header.png" alt="Формат ICMP протокола. (https://www.rfc-editor.org/rfc/rfc792#page-4)">
</div>
<div class="title">Figure 134. Формат ICMP протокола. (<a href="https://www.rfc-editor.org/rfc/rfc792#page-4" class="bare">https://www.rfc-editor.org/rfc/rfc792#page-4</a>)</div>
</div>
<div class="paragraph">
<p>Основными полями в ICMP протоколе являются тип (Type) и код (Code):</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Поле тип (<strong>Type</strong>) - указывает на тип возникшей проблемы, например, пункт назначения недостижим (Destination unreachable)</p>
</li>
<li>
<p>Поле код (<strong>Code</strong>) - конкретизирует ошибку, например, если тип указывает на Destination unreachable, то код конкретизирует: сеть недоступна, хост недоступен или порт недоступен.</p>
</li>
<li>
<p>Поле контрольной суммы (@Checksum@) - CRC16</p>
</li>
<li>
<p>Следующие 16 бит зарезервированы (<strong>unused</strong>) для различных типов и кодов ICMP сообщений. Некоторым ICMP сообщениям нужно там размещать дополнительные поля, а некоторым нет.</p>
</li>
<li>
<p>Заголовок <strong>IP + 64 бита данных</strong> - в этом поле содержиться тот самый пакет, который вызвал ошибку. Таким образом, получив ICMP сообщение хост сможет понять, какой именно пакет вызвал ошибку.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Если на хосте или маршрутизаторе во время обработки пакета возникает определенный тип ошибки, то он формирует определенное ICMP сообщение, в него вкладывается IP пакет, который вызвал эту ошибку и это сообщение отправляется на IP адрес отправителя проблемного IP пакета. Таким образом ICMP сообщает отправителю об ошибке.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_destination_unreachable">Destination unreachable</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Destination unreachable (переводится как назначение недостижимо, но имейте в виду, в среде профессионалов используется английская версия):</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Тип = 3</p>
</li>
<li>
<p>Коды:</p>
<div class="ulist">
<ul>
<li>
<p>0 - сеть недоступна</p>
</li>
<li>
<p>1 - хост недоступен</p>
</li>
<li>
<p>2 - протокол недоступен</p>
</li>
<li>
<p>3 - порт недоступен</p>
</li>
<li>
<p>4 - нужна фрагментация, но стоит флаг DF</p>
</li>
<li>
<p>5 - маршрут от источника недоступен</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
<div class="sect2">
<h3 id="_сеть_недоступна">Сеть недоступна</h3>
<div class="paragraph">
<p>Данное сообщение устанавливает <strong>тип</strong> = 3, <strong>код</strong> = 0. Ошибка генерируется, когда хоста или маршрутизатор не знает маршрута до IP сети, в которой находится IP адрес назначения.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="tcp_ip/icmp/destination_unreachable/images/net_unreachable.png" alt="Сеть из двух узлов генерирует ошибку ICMP сеть недоступна. (https://miminet.ru/web_network?guid=6994b921-cc0f-4cbd-b209-7f30784027d7)">
</div>
<div class="title">Figure 135. Сеть из двух узлов генерирует ошибку ICMP сеть недоступна. (<a href="https://miminet.ru/web_network?guid=6994b921-cc0f-4cbd-b209-7f30784027d7" class="bare">https://miminet.ru/web_network?guid=6994b921-cc0f-4cbd-b209-7f30784027d7</a>)</div>
</div>
<div class="paragraph">
<p>Для примера соберем сеть из 1 хоста и 1 маршрутизатора, как показано на рисунке выше. У хоста в качестве маршрутизатора по умолчанию пропишем маршрутизатор 1. А сам маршрутизатор будет знать только про сеть, к которой сам и подключен - это 192.168.1.0/24.</p>
</div>
<div class="paragraph">
<p>С хоста 1 попробуем отправить 1000 байт по TCP на IP адрес 8.8.4.4. Как мы уже знаем, для начала TCP попробует установить TCP соединение (SYN, SYN+ACK, ACK). Так как IP адрес назначения не в нашей сети, то хост 1 отправит его на маршрутизатор. Маршрутизатор, получив этот пакет, не сможет отправить его куда-либо дальше, так как у него нет маршрута до IP сети, которой принадлежит IP адрес назначения. Другими словами, в таблице маршрутизации у маршрутизатора нет ни одной подходящей записи для IP адреса 8.8.4.4.</p>
</div>
<div class="paragraph">
<p>Так как маршрутизатор не знает, куда отправить этот пакет дальше, он его отбрасывает. Чтобы сообщить об этой ошибке отправителю, генерирует и отправляет ICMP сообщение Destination net unreachable.</p>
</div>
<div class="paragraph">
<p>Кстати, обратите внимание, TCP прекращает попытки установки соединения сразу после получения этого ICMP сообщения. А если бы не это ICMP сообщение, то TCP так бы и пытался дальше устанавливать соединение.</p>
</div>
</div>
<div class="sect2">
<h3 id="_хост_недоступен">Хост недоступен</h3>
<div class="paragraph">
<p><strong>Тип</strong> = 3, <strong>код</strong> = 1. Ошибка генерируется, когда маршрутизатор не может доставить пакет до хоста с IP адресом назначения.</p>
</div>
<div class="paragraph">
<p>Соберем сеть из 2-х хостов и 1 маршрутизатора, как на рисунке ниже.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="tcp_ip/icmp/destination_unreachable/images/host_unreachable.png" alt="Сеть из двух узлов генерирует ошибку ICMP хост недоступен. (https://miminet.ru/web_network?guid=1646e111-1a47-4d98-a253-c396904e5351)">
</div>
<div class="title">Figure 136. Сеть из двух узлов генерирует ошибку ICMP хост недоступен. (<a href="https://miminet.ru/web_network?guid=1646e111-1a47-4d98-a253-c396904e5351" class="bare">https://miminet.ru/web_network?guid=1646e111-1a47-4d98-a253-c396904e5351</a>)</div>
</div>
<div class="paragraph">
<p>Хост 1 пытается подключиться к хосту с IP адресом 172.16.12.22 на порт 5555. Сам хост 1 находится в сети 192.168.1.0/24. Поэтому, TCP пакет отправляется на маршрутизатор 1. Маршрутизатор знает про сеть 172.16.12.0/24, в которой находится IP адрес 172.16.12.22. Он пытается отправить пакет для него и начинает отправлять ARP запросы, в поисках MAC адреса для IP адреса 172.16.12.22.</p>
</div>
<div class="paragraph">
<p>После 3-х попыток маршрутизатор делает вывод, что хост с IP адресом 172.16.12.22 не отвечает (его нет или он выключен) и генерирует ICMP сообщение Destination host unreachable.</p>
</div>
<div class="paragraph">
<p>Если запустить анимацию сети, то можно увидеть, как маршрутизатор отправит аж 3 ICMP сообщения о недостижимости хоста. Это все потому, что за время поиска MAC адреса для IP 172.16.12.22 он успел получить целых 3 TCP пакета для этого IP. Поэтому он отправляет 3 ICMP сообщения в ответ на эти три TCP пакета.</p>
</div>
<div class="paragraph">
<p>Таким образом, маршрутизатор сообщает источнику, что он знает про нужную сеть, но хост либо отсутствует или выключен. В любом случае, не отвечает.</p>
</div>
</div>
<div class="sect2">
<h3 id="_протокол_недоступен">Протокол недоступен</h3>
<div class="paragraph">
<p>Никогда не встречал в жизни.</p>
</div>
</div>
<div class="sect2">
<h3 id="_порт_недоступен">Порт недоступен</h3>
<div class="paragraph">
<p><strong>Тип = 3</strong>, <strong>код</strong> = 3. Ошибка генерируется, когда хост получает UDP датаграмму на порт, который никто не слушает.</p>
</div>
<div class="paragraph">
<p>Если UDP отправляет датаграмму на порт, который никто не слушает на удаленной стороне, то в ответ он ничего не получит. И как определить, это датаграмма потерялась или на хосте назначения никто не слушает указанный порт?</p>
</div>
<div class="paragraph">
<p>Для решения этой проблемы используется ICMP сообщение порт недоступен. Это сообщение помогает отправителю UDP сообщений понять, удаленная сторона готова к работе или нет. Это некоторый аналог установки соединения в TCP, только тут ICMP сообщение приходит только в случае недоступности порта.</p>
</div>
<div class="paragraph">
<p>Соберем сеть из 1 хоста и двух серверов, как показано на рисунке ниже.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="tcp_ip/icmp/destination_unreachable/images/port_unreachable.png" alt="Сеть из одного хоста и двух серверов генерирует ошибку ICMP порт недоступен. (https://miminet.ru/web_network?guid=46fb1ad6-555e-4e61-98eb-e6d66346ae60).">
</div>
<div class="title">Figure 137. Сеть из одного хоста и двух серверов генерирует ошибку ICMP порт недоступен. (<a href="https://miminet.ru/web_network?guid=46fb1ad6-555e-4e61-98eb-e6d66346ae60" class="bare">https://miminet.ru/web_network?guid=46fb1ad6-555e-4e61-98eb-e6d66346ae60</a>).</div>
</div>
<div class="paragraph">
<p>Хост 1 отправит два UDP пакета на порт 5555:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Один на сервер 1 с IP адресом 192.168.1, где порт 5555 будет закрыт.</p>
</li>
<li>
<p>Второй на сервер 2 с IP адресом 192.168.1.3, где порт 5555 будет открыт</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Запустив такую сеть мы увидим, что сервер 1, получив UDP датаграмму на порт 5555 отправляет в ответ ICMP сообщение Destination port unreachable. А сервер 2, получив UDP датаграмму на порт 5555 ничего не отправляет, так как UDP датаграмма была обработана.</p>
</div>
<div class="paragraph">
<p>Таким образом, ICMP сообщение Destination port unreachable помогает UDP клиентам определять, действительно ли удаленная сторона готова принимать данные или нет.</p>
</div>
</div>
<div class="sect2">
<h3 id="_нужна_фрагментация_но_стоит_флаг_df">Нужна фрагментация, но стоит флаг DF</h3>
<div class="paragraph">
<p><strong>Тип</strong> = 3, <strong>код</strong> = 4. ICMP сообщение генерируется в случае, когда IP протоколу нужно провести дефрагментацию пакета, но в опциях IP протокола установлен флаг DF (Don’t fragment) запрещающий проводить фрагментацию.</p>
</div>
<div class="paragraph">
<p>В обычной жизни такая ошибка возникает довольно редко. Для примера возьмем сеть из 2-х хостов и одного маршрутизатора, как показано на рисунке ниже. Между хостом 1 и маршрутизатором установлено MTU 9000. Напомню, что MTU - это Maximum Transfer Unit, максимальный размер пакета, который можно передать в сеть. Обычно MTU равен 1500, но есть стандарты, которые позволяют передавать Jumbo-фреймы (слоновые фреймы), размер которых может достигать до 9000 байт.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="tcp_ip/icmp/destination_unreachable/images/icmp_df.png" alt="Сеть из двух хостов и одного маршрутизатора генерирует ошибку ICMP нужна фрагментация" width="но стоит флаг DF.">
</div>
<div class="title">Figure 138. Сеть из двух хостов и одного маршрутизатора генерирует ошибку ICMP нужна фрагментация, но стоит флаг DF.</div>
</div>
<div class="paragraph">
<p>Пусть хост 1 отправит данные размером в 9000 байт на хост 2, при этом установит в IP пакете флаг DF (Don’t fragment). Маршрутизатор получит такой пакет и попробует его отправить на хост 2. Так как пакет размером 9000 байт, а MTU между хостом 2 и маршрутизатором всего 1500, то такой пакет нужно фрагментировать и отправлять порциями. Но флаг DF в IP пакете запрещает фрагментацию.</p>
</div>
<div class="paragraph">
<p>Как результат, маршрутизатор не сможет отправить такой пакет дальше, выбросит его, сгенерировав ICMP сообщение "Нужна фрагментация, но стоит флаг DF" и отправит его на хост 1.</p>
</div>
<div class="paragraph">
<p>Таким образом, хост 1 поймет, что пакет был отброшен.</p>
</div>
<div class="paragraph">
<p>Это ошибку можно посмотреть самостоятельно на своем локальном компьютере. Если у вас Windows, в командной консоли выполните команду</p>
</div>
<div class="literalblock">
<div class="content">
<pre>ping -l 2000 -f 77.88.8.8</pre>
</div>
</div>
<div class="paragraph">
<p>Результат работы команды показан на рисунке ниже. Флаг l - устанавливает размер пакета, в нашем случае это 2000 байт, а флаг f запрещает фрагментировать пакеты.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="tcp_ip/icmp/destination_unreachable/images/icmp_df_windows.png" alt="Утилита ping получает ICMP сообщение нужна фрагментация" width="но стоит флаг DF.">
</div>
<div class="title">Figure 139. Утилита ping получает ICMP сообщение нужна фрагментация, но стоит флаг DF.</div>
</div>
<div class="paragraph">
<p>На сетевом уровне IP протокол понимает, что пакет необходимо фрагментировать, но стоит запрещающий флаг. Поэтому такой пакет отбрасывается и генерируется соответствующее ICMP сообщение.</p>
</div>
</div>
<div class="sect2">
<h3 id="_маршрут_от_источника_недоступен">Маршрут от источника недоступен</h3>
<div class="paragraph">
<p>IP протокол поддерживает опциональные заголовки и для этого у него есть отдельное поле опции (Options). Если забыли формат протокола IP, можете подсмотреть в <a href="https://www.rfc-editor.org/rfc/rfc791#page-11">RFC 791</a>.</p>
</div>
<div class="paragraph">
<p>Одной из таких опций является маршрутизация от источника (<strong>source routing</strong>). Эта опция позволяет отправителю указать маршрутизатор или несколько маршрутизаторов, через которые данный пакет должен пройти. Соответственно, при невозможности отправки пакета по тому пути, который прописан в опции source routing вызывает ICMP сообщение о том, что маршрут от источника недоступен.</p>
</div>
<div class="paragraph">
<p>Стоит сказать, что почти все современные ОС и маршрутизаторы отключают эту опцию. Так как это небезопасно.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_time_exceeded">Time Exceeded</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Time Exceeded (время истекло) - в этой группе находится всего 2 вида сообщения:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>Тип</strong> = 11, <strong>код</strong> = 0 - time to live exceeded in transit (время пересылки истекло).</p>
</li>
<li>
<p><strong>Тип</strong> = 11, <strong>код</strong> = 1 - fragment reassembly time exceeded (время сборки (дефрагментации) пакета истекло)</p>
</li>
</ul>
</div>
<div class="sect2">
<h3 id="_time_to_live_exceeded_in_transit">Time to live exceeded in transit</h3>
<div class="paragraph">
<p>В IP протоколе есть поле TTL (Time To Live), размер этого поля 1 байт (8 бит). Каждый раз, когда IP пакет проходит через маршрутизатор, значение этого поля уменьшается на 1. Когда значение поля становится равным 0, пакет отбрасывается. Это такая защита от вечной пересылки пакета по сети Интернет. При наступлении такого события хост отправляет ICMP сообщение время пересылки истекло.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
Еще это сообщение иногда называют “похоронка”.
</td>
</tr>
</table>
</div>
<div class="imageblock">
<div class="content">
<img src="tcp_ip/icmp/time_exceeded/images/ttl_example.png" alt="Сеть из одного хоста и 3-х маршрутизаторов генерирует ошибку ICMP TTL exceeded. (https://miminet.ru/web_network?guid=7509b963-d190-4aad-8d90-9be42f302bbb).">
</div>
<div class="title">Figure 140. Сеть из одного хоста и 3-х маршрутизаторов генерирует ошибку ICMP TTL exceeded. (<a href="https://miminet.ru/web_network?guid=7509b963-d190-4aad-8d90-9be42f302bbb" class="bare">https://miminet.ru/web_network?guid=7509b963-d190-4aad-8d90-9be42f302bbb</a>).</div>
</div>
<div class="paragraph">
<p>Для демонстрации, соберем сеть из 1 хоста и 3-х маршрутизаторов, как показано на рисунке выше. Маршрутизаторы объединены в кольцо, что позволяет IP пакету циркулировать там, пока на это хватит TTL.</p>
</div>
<div class="paragraph">
<p>С хоста 1 отправим ICMP это запрос на IP адрес 12.34.45.67. При этом, установим его TTL=5 через опцию -t.</p>
</div>
<div class="paragraph">
<p>Запустив анимацию сети мы увидим, что наш ICMP пакет успевает сделать 1 круг и на маршрутизаторе 2 его TTL становится 0, что приводит к генерации ICMP сообщения time to live exceeded.</p>
</div>
<div class="paragraph">
<p>Таким образом, хост источника понимает, что в сети где-то появилось кольцо и необходимо вмешательство сетевого администратора.</p>
</div>
<div class="paragraph">
<p>Кстати говоря, еще это хороший способ узнать, сколько маршрутизаторов между вами и каким-то хостом в Интернете. Для этого можно отправлять ICMP запросы с постоянно увеличивающимся TTL. С TTL=1 вы получите ICMP сообщение от первого маршрутизатора, с TTL=2 от второго и так далее, пока не получите ICMP ответ.</p>
</div>
</div>
<div class="sect2">
<h3 id="_fragment_reassembly_time_exceeded">Fragment reassembly time exceeded</h3>
<div class="paragraph">
<p>Если размер IP пакета больше, чем текущий MTU (Max Transfer Unit), то такой пакет фрагментируется на несколько более мелких пакетов. Если во время пересылки один или несколько таких фрагментов потеряется, то удаленный хост не сможет собрать IP пакет обратно. Если хост не может собрать обратно IP пакет слишком долго, то он может отправить ICMP сообщение Fragment reassembly time exceeded.</p>
</div>
<div class="paragraph">
<p>Стоит знать о такой ошибке, хотя лично ее в жизни никогда не встречал.</p>
</div>
</div>
<div class="sect2">
<h3 id="_сеть_недоступна_2">Сеть недоступна</h3>
<div class="paragraph">
<p>Данное сообщение устанавливает <strong>тип</strong> = 3, <strong>код</strong> = 0. Ошибка генерируется, когда хоста или маршрутизатор не знает маршрута до IP сети, в которой находится IP адрес назначения.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="tcp_ip/icmp/time_exceeded/images/net_unreachable.png" alt="Сеть из двух узлов генерирует ошибку ICMP сеть недоступна. (https://miminet.ru/web_network?guid=6994b921-cc0f-4cbd-b209-7f30784027d7)">
</div>
<div class="title">Figure 141. Сеть из двух узлов генерирует ошибку ICMP сеть недоступна. (<a href="https://miminet.ru/web_network?guid=6994b921-cc0f-4cbd-b209-7f30784027d7" class="bare">https://miminet.ru/web_network?guid=6994b921-cc0f-4cbd-b209-7f30784027d7</a>)</div>
</div>
<div class="paragraph">
<p>Для примера соберем сеть из 1 хоста и 1 маршрутизатора, как показано на рисунке выше. У хоста в качестве маршрутизатора по умолчанию пропишем маршрутизатор 1. А сам маршрутизатор будет знать только про сеть, к которой сам и подключен - это 192.168.1.0/24.</p>
</div>
<div class="paragraph">
<p>С хоста 1 попробуем отправить 1000 байт по TCP на IP адрес 8.8.4.4. Как мы уже знаем, для начала TCP попробует установить TCP соединение (SYN, SYN+ACK, ACK). Так как IP адрес назначения не в нашей сети, то хост 1 отправит его на маршрутизатор. Маршрутизатор, получив этот пакет, не сможет отправить его куда-либо дальше, так как у него нет маршрута до IP сети, которой принадлежит IP адрес назначения. Другими словами, в таблице маршрутизации у маршрутизатора нет ни одной подходящей записи для IP адреса 8.8.4.4.</p>
</div>
<div class="paragraph">
<p>Так как маршрутизатор не знает, куда отправить этот пакет дальше, он его отбрасывает. Чтобы сообщить об этой ошибке отправителю, генерирует и отправляет ICMP сообщение Destination net unreachable.</p>
</div>
<div class="paragraph">
<p>Кстати, обратите внимание, TCP прекращает попытки установки соединения сразу после получения этого ICMP сообщения. А если бы не это ICMP сообщение, то TCP так бы и пытался дальше устанавливать соединение.</p>
</div>
</div>
<div class="sect2">
<h3 id="_хост_недоступен_2">Хост недоступен</h3>
<div class="paragraph">
<p><strong>Тип</strong> = 3, <strong>код</strong> = 1. Ошибка генерируется, когда маршрутизатор не может доставить пакет до хоста с IP адресом назначения.</p>
</div>
<div class="paragraph">
<p>Соберем сеть из 2-х хостов и 1 маршрутизатора, как на рисунке ниже.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="tcp_ip/icmp/time_exceeded/images/host_unreachable.png" alt="Сеть из двух узлов генерирует ошибку ICMP хост недоступен. (https://miminet.ru/web_network?guid=1646e111-1a47-4d98-a253-c396904e5351)">
</div>
<div class="title">Figure 142. Сеть из двух узлов генерирует ошибку ICMP хост недоступен. (<a href="https://miminet.ru/web_network?guid=1646e111-1a47-4d98-a253-c396904e5351" class="bare">https://miminet.ru/web_network?guid=1646e111-1a47-4d98-a253-c396904e5351</a>)</div>
</div>
<div class="paragraph">
<p>Хост 1 пытается подключиться к хосту с IP адресом 172.16.12.22 на порт 5555. Сам хост 1 находится в сети 192.168.1.0/24. Поэтому, TCP пакет отправляется на маршрутизатор 1. Маршрутизатор знает про сеть 172.16.12.0/24, в которой находится IP адрес 172.16.12.22. Он пытается отправить пакет для него и начинает отправлять ARP запросы, в поисках MAC адреса для IP адреса 172.16.12.22.</p>
</div>
<div class="paragraph">
<p>После 3-х попыток маршрутизатор делает вывод, что хост с IP адресом 172.16.12.22 не отвечает (его нет или он выключен) и генерирует ICMP сообщение Destination host unreachable.</p>
</div>
<div class="paragraph">
<p>Если запустить анимацию сети, то можно увидеть, как маршрутизатор отправит аж 3 ICMP сообщения о недостижимости хоста. Это все потому, что за время поиска MAC адреса для IP 172.16.12.22 он успел получить целых 3 TCP пакета для этого IP. Поэтому он отправляет 3 ICMP сообщения в ответ на эти три TCP пакета.</p>
</div>
<div class="paragraph">
<p>Таким образом, маршрутизатор сообщает источнику, что он знает про нужную сеть, но хост либо отсутствует или выключен. В любом случае, не отвечает.</p>
</div>
</div>
<div class="sect2">
<h3 id="_протокол_недоступен_2">Протокол недоступен</h3>
<div class="paragraph">
<p>Никогда не встречал в жизни.</p>
</div>
</div>
<div class="sect2">
<h3 id="_порт_недоступен_2">Порт недоступен</h3>
<div class="paragraph">
<p><strong>Тип = 3</strong>, <strong>код</strong> = 3. Ошибка генерируется, когда хост получает UDP датаграмму на порт, который никто не слушает.</p>
</div>
<div class="paragraph">
<p>Если UDP отправляет датаграмму на порт, который никто не слушает на удаленной стороне, то в ответ он ничего не получит. И как определить, это датаграмма потерялась или на хосте назначения никто не слушает указанный порт?</p>
</div>
<div class="paragraph">
<p>Для решения этой проблемы используется ICMP сообщение порт недоступен. Это сообщение помогает отправителю UDP сообщений понять, удаленная сторона готова к работе или нет. Это некоторый аналог установки соединения в TCP, только тут ICMP сообщение приходит только в случае недоступности порта.</p>
</div>
<div class="paragraph">
<p>Соберем сеть из 1 хоста и двух серверов, как показано на рисунке ниже.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="tcp_ip/icmp/time_exceeded/images/port_unreachable.png" alt="Сеть из одного хоста и двух серверов генерирует ошибку ICMP порт недоступен. (https://miminet.ru/web_network?guid=46fb1ad6-555e-4e61-98eb-e6d66346ae60).">
</div>
<div class="title">Figure 143. Сеть из одного хоста и двух серверов генерирует ошибку ICMP порт недоступен. (<a href="https://miminet.ru/web_network?guid=46fb1ad6-555e-4e61-98eb-e6d66346ae60" class="bare">https://miminet.ru/web_network?guid=46fb1ad6-555e-4e61-98eb-e6d66346ae60</a>).</div>
</div>
<div class="paragraph">
<p>Хост 1 отправит два UDP пакета на порт 5555:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Один на сервер 1 с IP адресом 192.168.1, где порт 5555 будет закрыт.</p>
</li>
<li>
<p>Второй на сервер 2 с IP адресом 192.168.1.3, где порт 5555 будет открыт</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Запустив такую сеть мы увидим, что сервер 1, получив UDP датаграмму на порт 5555 отправляет в ответ ICMP сообщение Destination port unreachable. А сервер 2, получив UDP датаграмму на порт 5555 ничего не отправляет, так как UDP датаграмма была обработана.</p>
</div>
<div class="paragraph">
<p>Таким образом, ICMP сообщение Destination port unreachable помогает UDP клиентам определять, действительно ли удаленная сторона готова принимать данные или нет.</p>
</div>
</div>
<div class="sect2">
<h3 id="_нужна_фрагментация_но_стоит_флаг_df_2">Нужна фрагментация, но стоит флаг DF</h3>
<div class="paragraph">
<p><strong>Тип</strong> = 3, <strong>код</strong> = 4. ICMP сообщение генерируется в случае, когда IP протоколу нужно провести дефрагментацию пакета, но в опциях IP протокола установлен флаг DF (Don’t fragment) запрещающий проводить фрагментацию.</p>
</div>
<div class="paragraph">
<p>В обычной жизни такая ошибка возникает довольно редко. Для примера возьмем сеть из 2-х хостов и одного маршрутизатора, как показано на рисунке ниже. Между хостом 1 и маршрутизатором MTU будет 9000. Напомню, что MTU - это Maximum Transfer Unit, максимальный размер пакета, который можно передать в сеть. Обычно MTU равен 1500, но есть стандарты, которые позволяют передавать Jumbo-фреймы (слоновые фреймы), размер которых может достигать до 9000 байт.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="tcp_ip/icmp/time_exceeded/images/icmp_df.png" alt="Сеть из двух хостов и одного маршрутизатора генерирует ошибку ICMP нужна фрагментация" width="но стоит флаг DF.">
</div>
<div class="title">Figure 144. Сеть из двух хостов и одного маршрутизатора генерирует ошибку ICMP нужна фрагментация, но стоит флаг DF.</div>
</div>
<div class="paragraph">
<p>Пусть хост 1 отправит данные размером в 9000 байт на хост 2, при этом установит в IP пакете флаг DF (Don’t fragment). Маршрутизатор получит такой пакет и попробует его отправить на хост 2. Так как пакет размером 9000 байт, а MTU между хостом 2 и маршрутизатором всего 1500, то такой пакет нужно фрагментировать и отправлять порциями. Но флаг DF в IP пакете запрещает фрагментацию.</p>
</div>
<div class="paragraph">
<p>Как результат, маршрутизатор не сможет отправить такой пакет дальше, выбросит его, сгенерировав ICMP сообщение "Нужна фрагментация, но стоит флаг DF" и отправит его на хост 1.</p>
</div>
<div class="paragraph">
<p>Таким образом, хост 1 поймет, что пакет был отброшен.</p>
</div>
<div class="paragraph">
<p>Это ошибку можно посмотреть самостоятельно на своем локальном компьютере. Если у вас Windows, в командной консоли выполните команду</p>
</div>
<div class="literalblock">
<div class="content">
<pre>ping -l 2000 -f 77.88.8.8</pre>
</div>
</div>
<div class="paragraph">
<p>Результат работы команды показан на рисунке ниже. Флаг l - устанавливает размер пакета, в нашем случае это 2000 байт, а флаг f запрещает фрагментировать пакеты.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="tcp_ip/icmp/time_exceeded/images/icmp_df_windows.png" alt="Утилита ping получает ICMP сообщение нужна фрагментация" width="но стоит флаг DF.">
</div>
<div class="title">Figure 145. Утилита ping получает ICMP сообщение нужна фрагментация, но стоит флаг DF.</div>
</div>
<div class="paragraph">
<p>На сетевом уровне IP протокол понимает, что пакет необходимо фрагментировать, но стоит запрещающий флаг. Поэтому такой пакет отбрасывается и генерируется соответствующее ICMP сообщение.</p>
</div>
</div>
<div class="sect2">
<h3 id="_маршрут_от_источника_недоступен_2">Маршрут от источника недоступен</h3>
<div class="paragraph">
<p>IP протокол поддерживает опциональные заголовки и для этого у него есть отдельное поле опции (Options). Если забыли формат протокола IP, можете подсмотреть в <a href="https://www.rfc-editor.org/rfc/rfc791#page-11">RFC 791</a>.</p>
</div>
<div class="paragraph">
<p>Одной из таких опций является маршрутизация от источника (<strong>source routing</strong>). Эта опция позволяет отправителю указать маршрутизатор или несколько маршрутизаторов, через которые данный пакет должен пройти. Соответственно, при невозможности отправки пакета по тому пути, который прописан в опции source routing вызывает ICMP сообщение о том, что маршрут от источника недоступен.</p>
</div>
<div class="paragraph">
<p>Стоит сказать, что почти все современные ОС и маршрутизаторы отключают ту опцию. Так как это небезопасно.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_echo_и_echo_reply_ping">Echo и Echo reply (ping)</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Пожалуй самые популярные ICMP сообщения. В отличие от многих других ICMP сообщений, эти не сообщают об ошибках, а скорее носят диагностический характер.</p>
</div>
<div class="paragraph">
<p>Echo (эхо или еще его называют ICMP запрос) - ICMP сообщение устанавливает <strong>тип</strong>=8, <strong>код</strong>=0 и служит для проверки доступности удаленного хоста по протоколу TCP/IP.  Получив такое ICMP сообщение хост должен ответить на него ICMP сообщением Echo reply (эхо ответ или я его называю ICMP ответ), установив <strong>тип</strong>=0 и <strong>код</strong>=0.</p>
</div>
<div class="paragraph">
<p>Таким способом можно проверять доступность удаленного хоста. Для отправки ICMP запросов обычно используется утилита ping. Это довольно универсальная утилита и она есть под Windows, MacOS и Linux. Для этого в своей командной строке выполните команду</p>
</div>
<div class="literalblock">
<div class="content">
<pre>ping 77.88.8.8</pre>
</div>
</div>
<div class="paragraph">
<p>Это IP адрес DNS сервера в Яндекс. В результате вы увидите ответ от удаленного хоста, а также время, за которое этот ответ приходит.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="tcp_ip/icmp/echo/images/ping_windows.png" alt="Пример использования утилиты ping под Windows.">
</div>
<div class="title">Figure 146. Пример использования утилиты ping под Windows.</div>
</div>
<div class="paragraph">
<p>В Windows по умолчанию отправляется 4 запроса, а в MacOS и Linux утилита отправляет запросы бесконечно, пока ее не прервет пользователь.</p>
</div>
<div class="paragraph">
<p>Не всегда на ICMP запрос вы можете получить ICMP ответ. Нередко сетевые администраторы настраивают свои сервера и маршрутизаторы таким образом, что они не отвечают на ICMP запросы.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_redirect">Redirect</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Сообщение ICMP Redirect (перенаправление) рекомендует хосту внести изменения в свою таблицу маршрутизации.</p>
</div>
<div class="paragraph">
<p><strong>Тип</strong> = 5</p>
</div>
<div class="paragraph">
<p>Основные коды:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>0</strong> - перенаправление для сети</p>
</li>
<li>
<p><strong>1</strong> - перенаправление для хоста</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Есть еще код 2 и 3, но я не видел их применения в жизни. Не уверен, что они по-прежнему используются. Если очень интересно, предлагаю почитать <a href="https://datatracker.ietf.org/doc/html/rfc792">RFC 792</a> и исходники ядра Linux.</p>
</div>
<div class="paragraph">
<p>Для примера, сделаем сеть как показано на рисунке ниже.  Нам понадобится 2 хоста, 1 маршрутизатор и 1 свитч или хаб.</p>
</div>
<div class="paragraph">
<p>Все устройства подключены к одному свичу, что делает возможным обмениваться данными напрямую. А вот IP настройки таковы, что хост 1 (10.0.0.1/24) и хост 2 (192.168.1.1/24) находятся в разных IP сетях. Поэтому, если мы попробуем отправить пакет от хоста 1 к хосту 2, то мы не сможем это сделать, так как у хоста 1 в таблице маршрутизации нет подходящей записи.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="tcp_ip/icmp/redirect/images/redirect_miminet.png" alt="Сеть из двух хостов и одного маршрутизатора генерирует сообщение ICMP Redirect. (https://miminet.ru/web_network?guid=1d4704c2-f8db-436c-8da9-2892e4d0f577).">
</div>
<div class="title">Figure 147. Сеть из двух хостов и одного маршрутизатора генерирует сообщение ICMP Redirect. (<a href="https://miminet.ru/web_network?guid=1d4704c2-f8db-436c-8da9-2892e4d0f577" class="bare">https://miminet.ru/web_network?guid=1d4704c2-f8db-436c-8da9-2892e4d0f577</a>)</div>
</div>
<div class="paragraph">
<p>Чтобы хосты могли обмениваться данными между собой нужно либо добавить запись в их таблицу маршрутизации или добавить в сеть маршрутизатор. Добавим в сеть маршрутизатор и на одном интерфейсе настроим 2 IP адреса:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>10.0.0.100/24</p>
</li>
<li>
<p>192.168.1.100/24</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>Один IP адрес будет из сети хоста 1, второй - из сети хоста 2. Таким образом, маршрутизатор будет находиться в двух сетях одновременно и сможет переправлять пакеты от одного хоста к другому.</p>
</div>
<div class="paragraph">
<p>На хостах выполним 3 команды:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>На хосте 1 выполним ping на хост 2</p>
</li>
<li>
<p>На хосте 2 выполним ping на хост 1</p>
</li>
<li>
<p>И снова на хосте 1 выполним ping на хост 2</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>А теперь рассмотрим, что произойдет. И для начала, давайте опустим ARP запросы из объяснения и так понятно зачем они нужны:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Хост 1 отправляет ICMP запрос для хост 2 на маршрутизатор.</p>
</li>
<li>
<p>Маршрутизатор, получив ICMP запрос от хоста 1 отправляет его на хост 2. И вот тут происходит интересное. Маршрутизатор отправляет полученные ICMP запрос в тот же сетевой интерфейс, откуда он его только что получил. Это означает, что маршрутизатор в этой цепочке доставки пакета лишний и хост 1 может напрямую доставлять пакеты до хоста 2.</p>
</li>
<li>
<p>Маршрутизатор, через сообщение ICMP redirect рекомендует хосту 1 поправить свою таблицу маршрутизации таким образом, чтобы он доставлял пакеты для хоста 2 напрямую, минуя маршрутизатор.</p>
</li>
<li>
<p>Такая же ситуация происходит и в ситуации, когда хост 2 отправляет хосту 1 ICMP ответ. Маршрутизатор отправляет хосту 2 ICMP redirect о том, что он может отправлять пакеты для хоста 1 напрямую.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>Как итог, можно увидеть, что когда хост 1 уже во второй раз выполняет команду ping на хост 2, то пакеты между ними ходят напрямую, минуя маршрутизатор. Таким образом, ICMP redirect позволяет сокращать маршруты доставки пакетов.</p>
</div>
<div class="paragraph">
<p>Стоит обратить внимание, что ICMP redirect очень небезопасен, при этом, они по умолчанию обрабатываются многими ОС. Поэтому, сетевые администраторы настраивают свои фаерволы таким образом, чтобы они блокировали эти пакеты или вносят изменения в настройки ОС.</p>
</div>
<div class="paragraph">
<p>Для ОС Linux настройки ICMP redirect можно посмотреть в sysctl, как показано на рисунке ниже.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="tcp_ip/icmp/redirect/images/linux_sysctl.png" alt="Настройка ICMP redirect в ОС Linux.">
</div>
<div class="title">Figure 148. Настройка ICMP redirect в ОС Linux.</div>
</div>
<div class="paragraph">
<p>Под Windows настройка поведения при получении ICMP redirect находится в ветке реестра</p>
</div>
<div class="literalblock">
<div class="content">
<pre>HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services\Tcpip\Parameters.</pre>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_source_quench">Source Quench</h2>
<div class="sectionbody">
<div class="paragraph">
<p>ICMP Source Quench (подавление источника) используется для информирования источника о том, что хост или маршрутизатор не успевает обрабатывать пакеты.</p>
</div>
<div class="paragraph">
<p>Используется ICMP <strong>тип</strong> = 4, <strong>код</strong> = 0.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_vlan">VLAN</h2>
<div class="sectionbody">
<div class="paragraph">
<p>VLAN (Virtual Local Area Network) - позволяет разделить единую сеть (широковещательный домен) на изолированные друг от друга сегменты сети.</p>
</div>
<div class="paragraph">
<p>Возьмем пример, когда сдаете в аренду несколько офисов в бизнес-центре. В одном офисе работает компания с разработчиками, а в соседнем туристическая фирма. Для избежания проблем с безопасностью, вы решаете отделить сеть одной компании от другой.</p>
</div>
<div class="paragraph">
<p>Рассмотрим схему сети, состоящую из 4-х хостов, которые подключены к одному коммутатору, как показано на рисунке ниже.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="L2/VLAN/images/vlan_1.png" alt="VLAN по портам (Access). VLAN по портам (Access) (https://miminet.ru/web_network?guid=865d4618-0b97-45b5-a2af-392e15670f76)">
</div>
<div class="title">Figure 149. VLAN по портам (Access) (<a href="https://miminet.ru/web_network?guid=865d4618-0b97-45b5-a2af-392e15670f76" class="bare">https://miminet.ru/web_network?guid=865d4618-0b97-45b5-a2af-392e15670f76</a>)</div>
</div>
<div class="paragraph">
<p>Пусть хост 1 и хост 2 находятся в одном офисе, а хост 3 и хост 4 в другом. Хоть они и подключены к одному коммутатору, мы, как администраторы, хотим изолировать их друг от друга. Для решения этой проблемы используется VLAN.</p>
</div>
<div class="paragraph">
<p>VLAN изолирует один сегмент сети от другого путем назначения идентификатора виртуальной сети (VLAN Id).</p>
</div>
<div class="sect2">
<h3 id="_access_vlan_по_портам">Access VLAN (по портам)</h3>
<div class="paragraph">
<p>VLAN реализуется на свитчах путём назначения VLAN ID (идентификатор виртуальной сети) конкретному порту коммутатора. В нашем примере мы назначили:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>VLAN ID = 10 для портов, куда подключены хосты 1 и 2</p>
</li>
<li>
<p>VLAN ID = 20 для портов, куда подключены хосты 3 и 4.</p>
</li>
</ul>
</div>
<div class="imageblock">
<div class="content">
<img src="L2/VLAN/images/vlan_2.png" alt="VLAN по портам (Access) (https://miminet.ru/web_network?guid=865d4618-0b97-45b5-a2af-392e15670f76).">
</div>
<div class="title">Figure 150. VLAN по портам (Access) (<a href="https://miminet.ru/web_network?guid=865d4618-0b97-45b5-a2af-392e15670f76" class="bare">https://miminet.ru/web_network?guid=865d4618-0b97-45b5-a2af-392e15670f76</a>)</div>
</div>
<div class="paragraph">
<p>Теперь, когда коммутатор получает пакет на порт он определяет, какому VLAN ID принадлежит данный порт. Определив VLAN ID, он коммутирует пакет только в рамках данного VLAN ID. В нашем случае хост 1 и хост 2 подключены в порты с VLAN ID = 10, а хосты 3 и 4 подключены в порты VLAN ID = 20.</p>
</div>
<div class="paragraph">
<p>Если мы запустим ping от хоста 1 к хосту 2, то даже широковещательные (чей MAC-адрес назначения равен FF:FF:FF:FF:FF:FF) пакеты не попадут на хост 3 и 4. Путём назначения VLAN ID на портах коммутатора мы создаём виртуальную сеть. И пакеты из одной виртуальной сети не будут попадать в другую.</p>
</div>
<div class="paragraph">
<p>Можно ещё думать так: когда вы включаете и настраиваете VLAN, то внутри вашего коммутатора создаётся виртуальный коммутатор с портами, которые вы назначили в VLAN. И весь трафик коммутируется внутри этих виртуальных коммутаторов, как показано на рисунке ниже.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="L2/VLAN/images/vlan_3.gif" alt="Виртуальный коммутатор с VLAN.">
</div>
<div class="title">Figure 151. Виртуальный коммутатор с VLAN.</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
VLAN по портам еще называют Port-Based VLAN.
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="_trunk_vlan_тегамметкам">Trunk VLAN (тегам/меткам)</h3>
<div class="paragraph">
<p>Давайте усложним немного нашу схему, как показано на рисунке ниже. При этом оставим условие (хост 1 и 2 в одной сети, хост 3 и 4 в другой). Как видно, хосты из разных VLAN подключены к разным коммутаторам. То есть хост 1 подключён к коммутатору l2sw1, а хост 2 подключён к коммутатору l2sw2.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="L2/VLAN/images/vlan_4.png" alt="VLAN по портам (Access) на двух коммутаторах (https://miminet.ru/web_network?guid=e43b978b-6292-4619-8bec-0c82a75e004d)">
</div>
<div class="title">Figure 152. VLAN по портам (Access) на двух коммутаторах (<a href="https://miminet.ru/web_network?guid=e43b978b-6292-4619-8bec-0c82a75e004d" class="bare">https://miminet.ru/web_network?guid=e43b978b-6292-4619-8bec-0c82a75e004d</a>)</div>
</div>
<div class="paragraph">
<p>В данном примере для решения нашей задачи потребуется сделать два соединения между коммутаторами l2sw1 и l2sw2. По одному соединению мы будем передать VLAN ID = 10, по-другому VLAN ID = 20. Но эта избыточность нам не нужна. Порт на коммутаторе не бесплатное удовольствие, и занимать его просто так нет желания. Есть желание передавать пакеты для обоих VLAN ID по одному физическому соединению, как это показано на рисунке ниже.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="L2/VLAN/images/vlan_5.png" alt="VLAN по тегам (Trunk) (https://miminet.ru/web_network?guid=1ccd87d4-a74f-485e-a95e-e1111c041fc7)">
</div>
<div class="title">Figure 153. VLAN по тегам (Trunk) (<a href="https://miminet.ru/web_network?guid=1ccd87d4-a74f-485e-a95e-e1111c041fc7" class="bare">https://miminet.ru/web_network?guid=1ccd87d4-a74f-485e-a95e-e1111c041fc7</a>)</div>
</div>
<div class="paragraph">
<p>Для реализации такой схемы используется тег. Стандарт IEEE 802.1Q описывает процедуру тегирования трафика. 802.1Q помещает внутрь Ethernet фрейма тег, который передаёт информацию о принадлежности трафика к VLAN.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="L2/VLAN/images/vlan_tag.png" alt="Заголовок 802.1Q в Ethernet фрейме.">
</div>
<div class="title">Figure 154. Заголовок 802.1Q в Ethernet фрейме.</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
На английском языке такой VLAN называется Tagging VLAN, а сам заголовок 802.1Q называется tag. В русской литературе tag переводят как тег или как метка. Поэтому кто-то пишет тегированый VLAN, кто-то VLAN по тегам, а кто-то VLAN с метками.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Заголовок 802.1Q имеет размер 4 байта и помещается между полями MAC-адрес источника и полем Тип/Длина.</p>
</div>
<div class="paragraph">
<p>802.1Q заголовок состоит из следующих полей:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>TPID</strong> (Tag Protocol Identifier, 16 бит) - указывает, какой протокол используется для тегирования. Для 802.1Q используется значение 0x8100. Это поле размещается прямо в том месте, где обычно размещается поле Тип/Длина. Таким образом, принимающая сторона может сразу определить, что имеет дело с заголовком 802.1Q.</p>
</li>
<li>
<p><strong>TCI</strong> (Tag control information. 16 бит) состоит из следующих полей:</p>
<div class="ulist">
<ul>
<li>
<p>Priority code point (PCP, 3 бита) - используется стандартом IEEE 802.1p для задания приоритета передаваемого трафика (class of service). Число 0 соответствует наименьшему приоритету, а 7 — наивысшему.</p>
</li>
<li>
<p>Drop eligible indicator (DEI, 1 бит) - индикатор допустимости удаления. Может использоваться отдельно или совместно с PCP для указания кадров, которые могут быть отброшены при наличии перегрузки.</p>
</li>
<li>
<p><strong>VLAN Identifier</strong> (12 бит) - указывает, какому VLAN ID принадлежит кадр.</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
<div class="paragraph">
<p>Именно поле VLAN Identifier позволяет прямо в пакете передать информацию его принадлежности к конкретному VLAN ID.</p>
</div>
<div class="paragraph">
<p>Теперь для решения нашей задачи нам достаточно одного физического соединения и сконфигурировать соответствующие VLAN. Такой тип соединения обычно называют <strong>Trunk</strong>, <strong>802.1Q</strong> или <strong>тегированый VLAN</strong>.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="L2/VLAN/images/vlan_6.png" alt="VLAN по тегам (Trunk) (https://miminet.ru/web_network?guid=1ccd87d4-a74f-485e-a95e-e1111c041fc7).">
</div>
<div class="title">Figure 155. VLAN по тегам (Trunk) (<a href="https://miminet.ru/web_network?guid=1ccd87d4-a74f-485e-a95e-e1111c041fc7" class="bare">https://miminet.ru/web_network?guid=1ccd87d4-a74f-485e-a95e-e1111c041fc7</a>).</div>
</div>
<div class="paragraph">
<p>Для настройки тегированого VLAN на коммутаторе нужно перевести порт в состояние Trunk и назначить ему идентификаторы VLAN. В нашем случае назначаются идентификаторы 10 и 20 (через запятую).</p>
</div>
<div class="paragraph">
<p>Теперь, когда хост 1 отправит пакет на хост 2, то:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>коммутатор 1 получает пакет от хоста 1, смотрит настройку порта (Access, VLAN Id = 10) и назначает данный пакет в VLAN 10.</p>
</li>
<li>
<p>пакету на коммутаторе 1 разрешено коммутируется только между портами, которым разрешено работать в VLAN 10. На основе таблицы коммутации пакет нужно отправить в порт, который подключен к коммутатору 2.</p>
</li>
<li>
<p>так как порт между коммутатором 1 и 2 сконфигурирован как Trunk, то коммутатор 1 перед отправкой такого пакета добавляет в пакет тег (Tag) с информацией о VLAN (в нашем случае VLAN Id = 10)</p>
</li>
<li>
<p>коммутатор 2 получает на Trunk порт пакет с VLAN Id = 10, значит, данный пакет можно коммутировать только в порты, которые принадлежат VLAN Id =10</p>
</li>
<li>
<p>на основе таблицы коммутации пакет нужно отправить в порт, куда подключён хост 2</p>
</li>
<li>
<p>хост 2 подключён на Access порт с VLAN Id = 10, значит, перед отправкой пакета тег удаляется.</p>
</li>
</ul>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
Терминация - это процесс удаление VLAN тега их пакета.
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="_vlan_маршрутизатор">VLAN маршрутизатор</h3>
<div class="paragraph">
<p>VLAN позволяет нам разделить один большой широковещательный домен на несколько небольших. Представим, есть сеть компании на 1000 хостов (ПК, ноутбуки, телевизоры и т.п.). Сеть, конечно, построена на коммутаторах. Разделение такого одного широковещательного домена на несколько небольших с использованием VLAN будет очень удобным. Например, выделим отдел бухгалтерии, серверную, разработчиков и тестировщиков.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
Без VLAN у нас был бы один большой широковещательный домен, что вызывало бы проблемы с широковещательными пакетами и безопасностью.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>С другой стороны, строя сеть, мы хотим уметь взаимодействовать со всеми хостами. Например, разработчики и тестировщики хотят иметь доступ к серверам.</p>
</div>
<div class="paragraph">
<p>Это приводит нас к необходимости маршрутизировать пакеты между различными VLAN. Как известно, для маршрутизации пакетов используют маршрутизатор.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="L2/VLAN/images/vlan_router_1.png" alt="Маршрутизация между VLAN. (https://miminet.ru/web_network?guid=02521bae-d323-4384-af7c-47f8314607bb).">
</div>
<div class="title">Figure 156. Маршрутизация между VLAN. (<a href="https://miminet.ru/web_network?guid=02521bae-d323-4384-af7c-47f8314607bb" class="bare">https://miminet.ru/web_network?guid=02521bae-d323-4384-af7c-47f8314607bb</a>).</div>
</div>
<div class="paragraph">
<p>Создадим сеть, как показано на рисунке выше. К коммутатору подключено 2 хоста и 1 маршрутизатор:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>хост 1 находится в VLAN 10 (Access port)</p>
</li>
<li>
<p>хост 2 находится в VLAN 20 (Access port)</p>
</li>
<li>
<p>маршрутизатор 1 подключён к двум портам коммутатора. Один порт находится в  VLAN 10, другой в VLAN 20. Оба порта настроены как Acces port.</p>
</li>
</ul>
</div>
<div class="imageblock">
<div class="content">
<img src="L2/VLAN/images/vlan_router_2.png" alt="Конфигурация VLAN на коммутаторе. (https://miminet.ru/web_network?guid=02521bae-d323-4384-af7c-47f8314607bb).">
</div>
<div class="title">Figure 157. Конфигурация VLAN на коммутаторе. (<a href="https://miminet.ru/web_network?guid=02521bae-d323-4384-af7c-47f8314607bb" class="bare">https://miminet.ru/web_network?guid=02521bae-d323-4384-af7c-47f8314607bb</a>).</div>
</div>
<div class="paragraph">
<p>Таким образом, маршрутизатор одновременно подключён сразу к двум VLAN и может с ними взаимодействовать:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Интерфейс 192.168.1.1/24 подключён к порту коммутатора с VLAN 10.</p>
</li>
<li>
<p>Интерфейс 10.0.0.1/24 подключён к порту коммутатора с VLAN 20.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Давайте разберём, что произойдёт, когда хоста 1 отправит пакет хосту 2:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>пакет придёт на порт коммутатора с VLAN 10, значит, коммутация может выполняться только между портами с VLAN 10</p>
</li>
<li>
<p>коммутатор отправит пакет на маршрутизатор 1 через порт, который находится в VLAN 10</p>
</li>
<li>
<p>маршрутизатор получит пакет на интерфейс с IP-адресом 192.168.1.1:</p>
<div class="ulist">
<ul>
<li>
<p>разберёт IP заголовок</p>
</li>
<li>
<p>определит, что IP-адрес получателя (10.0.0.2) не его и будет этот пакет маршрутизировать дальше</p>
</li>
<li>
<p>на основе таблицы маршрутизации определит, что пакет можно отправить во второй интерфейс с IP-адресом 10.0.0.1</p>
</li>
<li>
<p>отправит пакет в сеть</p>
</li>
</ul>
</div>
</li>
<li>
<p>пакет придёт на порт коммутатора с VLAN 20, т.е. коммутация может выполняться только между портами с VLAN 20</p>
</li>
<li>
<p>коммутатор отправит пакет хосту 2.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Вот так, используя обычный маршрутизатор, можно передавать трафик между различными VLAN.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
Вы возможно заметили, что вместо VLAN Id = 10 я начал писать просто VLAN 10. Это не опечатка, а сделано специально. Так короче и уже понятно, что речь идет именно про VLAN Id = 10.
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="_сабинтерфейсы_sub_interface">Сабинтерфейсы (sub-interface)</h3>
<div class="paragraph">
<p>Описанная выше схема рабочая, но не очень эффективная. Она занимает целых два порта коммутатора только для маршрутизации между VLAN. Если ваш маршрутизатор поддерживает создание сабинтерфейсов, то можно обойтись одним физическим соединением.</p>
</div>
<div class="paragraph">
<p>Сабинтерфейс - это виртуальный интерфейс сетевого уровня (привет, модель ISO/OSI), который умеет отправлять и получать пакеты с VLAN тегом (IEEE 802.1q).</p>
</div>
<div class="paragraph">
<p>Давайте переделаем нашу сеть с использованием сабинтерфейсов. У маршрутизатора теперь будет одно физическое соединение вместо двух. И настроим два сабинтерфейса:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>сабинтерфейс 192.168.1.1/24 работает с VLAN 10</p>
</li>
<li>
<p>сабинтерфейс 10.0.0.1/24 работает с VLAN 20</p>
</li>
</ul>
</div>
<div class="imageblock">
<div class="content">
<img src="L2/VLAN/images/vlan_router_3.png" alt="Маршрутизация между VLAN через сабинтерфейсы. (https://miminet.ru/web_network?guid=0f13773b-0ec4-45d4-85f7-ba91330fab08).">
</div>
<div class="title">Figure 158. Маршрутизация между VLAN через сабинтерфейсы. (<a href="https://miminet.ru/web_network?guid=0f13773b-0ec4-45d4-85f7-ba91330fab08" class="bare">https://miminet.ru/web_network?guid=0f13773b-0ec4-45d4-85f7-ba91330fab08</a>).</div>
</div>
<div class="paragraph">
<p>У маршрутизатора осталось только одно физическое соединение, по которому мы будем передавать два различных VLAN. Значит, на коммутаторе нам нужно сконфигурировать соответствующий порт как Trunk. На рисунке ниже показана конфигурация VLAN на коммутаторе.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="L2/VLAN/images/vlan_router_4.png" alt="Конфигурация VLAN на коммутаторе. (https://miminet.ru/web_network?guid=0f13773b-0ec4-45d4-85f7-ba91330fab08).">
</div>
<div class="title">Figure 159. Конфигурация VLAN на коммутаторе. (<a href="https://miminet.ru/web_network?guid=0f13773b-0ec4-45d4-85f7-ba91330fab08" class="bare">https://miminet.ru/web_network?guid=0f13773b-0ec4-45d4-85f7-ba91330fab08</a>).</div>
</div>
<div class="paragraph">
<p>Теперь, если мы отправим пакет от хоста 1 к хосту 2:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>пакет придет на порт коммутатора с VLAN 10, значит, коммутация может выполняться только между портами с VLAN 10</p>
</li>
<li>
<p>коммутатор отправит пакет на маршрутизатор 1 через Trunk порт, который находится в VLAN 10 и 20. Коммутатор добавит VLAN тег с указанием VLAN Id = 10</p>
</li>
<li>
<p>маршрутизатор получит пакет с VLAN тегом, у которого VLAN Id = 10, значит, он будет обрабатываться сабинтерфейсом с IP-адресом 192.168.1.1. Затем маршрутизатор:</p>
<div class="ulist">
<ul>
<li>
<p>разберёт IP заголовок</p>
</li>
<li>
<p>определит, что IP-адрес получателя (10.0.0.2) не его и будет этот пакет маршрутизировать дальше</p>
</li>
<li>
<p>на основе таблицы маршрутизации определит, что пакет можно отправить в сабинтерфейс с IP-адресом 10.0.0.1</p>
</li>
<li>
<p>отправит пакет в сеть, при этом добавит в пакет VLAN тег со значением VLAN Id = 20</p>
</li>
</ul>
</div>
</li>
<li>
<p>пакет с VLAN Id = 20 придёт на Trunk порт коммутатора, т.е. коммутация может выполняться только между портами с VLAN 20</p>
</li>
<li>
<p>коммутатор отправит пакет хосту 2.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Вот таким образом можно организовать трафик между VLAN и не занимать слишком много портов на коммутаторе. Теперь не удивляйтесь, если вдруг увидите маршрутизатор, который подключён к коммутатору только 1 физическим соединением. Им может оказаться VLAN маршрутизатор с настроенными сабинтерфейсами.</p>
</div>
<div class="paragraph">
<p>Ещё такую схему подключения называют ROAS (Router-on-a-stick).</p>
</div>
<div class="paragraph">
<p>Используя VLAN и маршрутизацию между VLAN, можно одну большую сеть разделить не несколько небольших. А ещё можно добавить правила для фильтрации трафика, проходящего через маршрутизатор. Таким образом, можно не только уменьшить широковещательный домен, но и сделать сеть более безопасную.</p>
</div>
</div>
<div class="sect2">
<h3 id="_native_vlan">Native VLAN</h3>
<div class="paragraph">
<p>Когда вы включаете VLAN на коммутаторе, то у него появляется специальный Native VLAN. Можно сказать, что это VLAN Id по умолчанию (обычно это VLAN Id = 1).</p>
</div>
<div class="paragraph">
<p>Коммутаторы не только переправляют чужие пакеты, но и нередко генерируют свои. Есть много протоколов общения между коммутаторами. Например, STP (Spanning Tree Protocol) - протокол для обнаружения и устранения петель в топологии Etherhet. Во время его работы коммутаторы обмениваются специальными STP пакетами между собой. Представим, мы сконфигурировали на коммутаторе Trunk порт с VLAN Id = 10 и 20. А после этого запустили STP процесс на коммутаторе. Коммутатор хочет отправить в Trunk порт STP пакет, какой VLAN Id ему поставить в тег, 10 или 20?</p>
</div>
<div class="paragraph">
<p>В этой ситуации хочется просто отправить пакет для другого коммутатора без установки VLAN тега. Но если мы так поступим, то другому коммутатору на Trunk порт придёт пакет без тега. Что с ним делать, обрабатывать или выбрасывать? А если обрабатывать, то к какому VLAN его приписывать?</p>
</div>
<div class="paragraph">
<p>Именно эти проблемы решает Native VLAN. Если на Trunk порт пришёл пакет без тега, то такой пакет автоматически приписывается к Native VLAN.</p>
</div>
<div class="paragraph">
<p>Другой случай, если вы только что включили VLAN на коммутаторе, то все порты автоматически будут в режиме Access и будут принадлежать Native VLAN. Это нужно, чтобы в момент включения VLAN на коммутаторе, подключенные к этому коммутатору хосты продолжали работать.</p>
</div>
<div class="paragraph">
<p>Таким образом, коммутаторы, на которых включён VLAN, могут спокойно общаться друг с другом, используя Native VLAN и не переживая о том, какой VLAN Id ставить в тег.</p>
</div>
</div>
<div class="sect2">
<h3 id="_vlan_и_mtu">VLAN и MTU</h3>
<div class="paragraph">
<p>Как известно из стандарта, максимальный размер Ethernet фрейма - 1518 байт:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>14 байт Ethernet заголовок</p>
</li>
<li>
<p>до 1500 байт данных</p>
</li>
<li>
<p>4 байта CRC32 (контрольная сумма).</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>А если мы включим VLAN tag, то он добавит ещё 4 байта. В итоге максимальный размер Ethernet фрейма вырастит до 1522. Будет ли пакет такого размера успешно передан?</p>
</div>
<div class="paragraph">
<p><strong>Вопрос</strong>: нужно ли при включении VLAN tag изменять значение MTU (maximum transmission unit) или нет?</p>
</div>
<div class="paragraph">
<p><strong>Ответ</strong>: менять MTU не нужно. Уже очень давно, коммутаторы и сетевые карты по умолчанию, могут принимать пакеты большей длины, чем 1518 или1522 байт.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_туннелирование_vpn">Туннелирование (VPN)</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_введение">Введение</h3>
<div class="paragraph">
<p>В начале изучения компьютерных сетей обязательно изучается модель ISO/OSI и приводятся примеры, как данные по ней передвигаются вверх (от физического уровня к приложению) или вниз (от приложения к физическому уровню).</p>
</div>
<div class="paragraph">
<p>Во время обсуждения маршрутизации оказывается, что иногда пакеты передвигаются вдоль уровней. Например, во время маршрутизации, пакет поднимается с физического уровня до сетевого уровня. Там принимается решение о том, что данный пакет необходимо маршрутизировать дальше, и этот пакет отправляется обратно вниз по стеку.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="VPN/images/vpn_1.png" alt="Движение пакета по модели ISO/OSI во время маршрутизации.">
</div>
<div class="title">Figure 160. Движение пакета по модели ISO/OSI во время маршрутизации.</div>
</div>
<div class="paragraph">
<p>Если открыть сниффер (например, Wireshark) и посмотреть на отправляемые пакеты, то можно заметить, что протокол транспортного уровня (TCP) инкапсулируется (вкладывается внутрь) в протокол сетевого уровня (IP), а он, в свою очередь, в протокол канального уровня (Ethernet). А когда пакет поднимается по стеку, то всё происходит наоборот. Сначала обрабатывается протокол канального уровня (Ethernet), потом сетевого уровня и затем транспортного.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="VPN/images/vpn_2.png" alt="Пакеты в Wireshark.">
</div>
<div class="title">Figure 161. Пакеты в Wireshark.</div>
</div>
<div class="paragraph">
<p>Когда программист занимается реализацией протоколов в операционной системе (ОС) он обычно не смотрит на модель ISO/OSI. Каждый протокол реализуется как некоторый модуль/подпрограмма, который на вход принимает данные и работает с ними.</p>
</div>
<div class="paragraph">
<p>Разберём пример:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Хост получил Ethernet пакет и он поступает Ethernet модулю на обработку.</p>
</li>
<li>
<p>Ethernet модуль разбирает Ethernet заголовок, проверяет длину пакета, извлекает MAC-адрес получателя и сравнивает его со своим. Предположим, что MAC-адрес оказался равен его собственному и Ethernet модуль решает передать данные на обработку следующему модулю.</p>
</li>
<li>
<p>Ethernet модуль заглядывает в поле Тип/Длинна, смотрит значение (пусть это будет 0x0800, что указывает на IP протокол) и ищет модуль, который зарегистрирован в ОС для обработки данного типа.</p>
</li>
<li>
<p>Если такой модуль нашёлся (IP модуль), то Ethernet модуль передаёт извлечённые данные ему на обработку.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Аналогичным образом поступает и модуль IP протокола. IP модуль разбирает IP заголовок, проверяет его на ошибки, извлекает IP-адрес получателя и так далее. В конечном счёте, если IP модуль решит продолжить обработку данных, он заглянет в поле Protocol (протокол) в IP заголовке, извлечёт его значение и, как в случае с Ethernet, попробует передать данные для обработки дальше.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="VPN/images/vpn_3.png" alt="Поле &quot;Протокол&quot; в IP зголовке.">
</div>
<div class="title">Figure 162. Поле "Протокол" в IP зголовке.</div>
</div>
<div class="paragraph">
<p>Мы привыкли, что после IP обычно следует UDP, ICMP или TCP протокол. А что если за IP заголовком последует ещё один IP заголовок. Или, что если после IP заголовка вновь последует Ethernet?</p>
</div>
<div class="paragraph">
<p>С позиции разработчика ничего особенного не произошло. После обработки IP заголовка передать данные на обработку снова модулю IP или Ethernet так же естественно, как и передать их модулю TCP или UDP. То есть двигаясь по стеку протоколов, данные могут передавать в следующем порядке Ethernet &#8594; IPv4 &#8594; IPv4 - &gt; TCP. И в этом не будет никакой трагедии. Нарушение только в модели ISO/OSI =)</p>
</div>
<div class="paragraph">
<p>Предлагаю такое нарушение называть туннелированием. Приведу ещё определение из википедии, выбирайте, кому что больше нравится.</p>
</div>
<div class="paragraph">
<p>“Туннелирование (от англ. tunnelling — «прокладка туннеля») в компьютерных сетях — процесс, в ходе которого создаётся логическое соединение между двумя конечными точками посредством инкапсуляции различных протоколов. Туннелирование представляет собой метод построения сетей, при котором один сетевой протокол инкапсулируется в другой. От обычных многоуровневых сетевых моделей (таких как OSI или TCP/IP) туннелирование отличается тем, что в качестве туннеля используется протокол более высокого, чем инкапсулируемый, уровня, либо протокол того же уровня.”</p>
</div>
<div class="paragraph">
<p>Внутри протокола IPv4 может вкладываться далеко не только TCP, UDP, ICMP, но и IPv4, IPv6, Ethernet и много чего ещё. Полный список можно посмотреть на сайте IANA (<a href="https://www.iana.org/assignments/protocol-numbers/protocol-numbers.xhtml" class="bare">https://www.iana.org/assignments/protocol-numbers/protocol-numbers.xhtml</a>).</p>
</div>
</div>
<div class="sect2">
<h3 id="_для_чего_используется_туннелирование">Для чего используется туннелирование?</h3>
<div class="paragraph">
<p>Главный вопрос: для чего используется туннелирование?</p>
</div>
<div class="paragraph">
<p>Рассмотрим пример, когда у вашей компании есть офис в Москве (Офис 1) и в Санкт-Петербурге (Офис 2). Расстояние между ними большое (около 800 км.). В Москве у вас сидят разработчики и тестировщики, а в Санкт-Петербурге находятся ваши сервера и команда администраторов. Разработчикам и тестировщикам необходимо иметь доступ к вашим внутренним серверам (хранить код, запускать тестовые сборки и т.д.). Как организовать такой доступ?</p>
</div>
<div class="imageblock">
<div class="content">
<img src="VPN/images/vpn_4.png" alt="Сеть компании в двух офисах. (https://miminet.ru/web_network?guid=fcd00973-a899-49d4-911b-7bdf86212d12).">
</div>
<div class="title">Figure 163. Сеть компании в двух офисах. (<a href="https://miminet.ru/web_network?guid=fcd00973-a899-49d4-911b-7bdf86212d12" class="bare">https://miminet.ru/web_network?guid=fcd00973-a899-49d4-911b-7bdf86212d12</a>).</div>
</div>
<div class="paragraph">
<p>На рисунке выше нарисована сеть с демонстрацией проблемы. Коммутаторы “Офис 1” и “Офис 2” установлены в Москве и СПб соответственно. Внутри офисов, естественно, используются серые IP-адреса. Не будем же мы всем нашим сотрудникам и тестовым серверам выделять белые IP-адреса. Поэтому:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>сеть 192.168.1.0/24 - для офиса 1</p>
</li>
<li>
<p>сеть 10.0.0.0/24 - для офиса 2</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Маршрутизатор 1 и 3 (router_1, router_3) - это маршрутизаторы компании, каждый из них имеет по одному белому IP-адресу. Мы можем их настраивать и делать с ними что угодно.</p>
</div>
<div class="paragraph">
<p>Маршрутизатор 2 (router 2) - это маршрутизатор провайдера, у него три белых IP-адреса:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>212.220.2.2/30 - для общения с маршрутизатором 1</p>
</li>
<li>
<p>212.220.2.6/30 - для общения с маршрутизатором 3</p>
</li>
<li>
<p>195.70.198.1/24 - для доступа в интернет. В качестве наглядности я взял сервер с IP-адресом 195.70.198.100</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Для упрощения схемы я нарисовал только один маршрутизатор от провайдера. В реальности их будет несколько, на проблему это никак не повлияет.</p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>Задача 1</strong> - хост 1 из офиса 1 должен уметь получать доступ к хосту 3 из офиса 2.</p>
</li>
<li>
<p><strong>Задача 2</strong> - хост 1 должен иметь доступ в интернет.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>С задачей 2 всё несложно, это мы знаем. Раз у нас есть маршрутизатор 1 с белым IP-адресом, то мы просто включим NAT на нём. В приведённой выше сети именно так и сделано.</p>
</div>
<div class="paragraph">
<p>А вот как быть с решением задачи 1? Чтобы чуть легче думалось, я перерисовал нашу схему и выбросил оттуда лишние устройства. Фокусируемся на главном, нам нужно организовать связь между хостом 1 и хостом 3.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="VPN/images/vpn_5.png" alt="Сеть компании в двух офисах. (https://miminet.ru/web_network?guid=4b35502a-3d7a-4cc4-886d-2da0525569f7).">
</div>
<div class="title">Figure 164. Сеть компании в двух офисах. (<a href="https://miminet.ru/web_network?guid=4b35502a-3d7a-4cc4-886d-2da0525569f7" class="bare">https://miminet.ru/web_network?guid=4b35502a-3d7a-4cc4-886d-2da0525569f7</a>).</div>
</div>
<div class="paragraph">
<p>Из хорошего есть связь между маршрутизатором 1 и маршрутизатором 3. Они могут обмениваться пакетами друг с другом. У каждого из них есть по 1 белому адресу. А вот если мы попробуем отправить пакет от хоста 1 к хосту 3, то он потеряется на маршрутизаторе 2 из-за того, что маршрутизатор 2 не знает, от кого пришёл пакет (IP-адрес источника 192.168.1.2) и не знает, куда его дальше отправлять (10.0.0.2).</p>
</div>
<div class="paragraph">
<p>Можно, например, попросить у провайдера маршрутизацию наших серых сетей (192.168.1.0/24 и 10.0.0.0/24). Пусть провайдер добавит в свои таблицы маршрутизации маршруты до этих сетей. Скорее всего, в этой услуге нам откажут, так как IP-адреса серые.</p>
</div>
<div class="paragraph">
<p>Если внимательно посмотреть на схему, то для решения задачи 1 нам нужно сделать так:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Хост 1 отправляет пакет с IP-адресом назначения хост 3 (10.0.0.2).</p>
</li>
<li>
<p>Пакет от хоста 1 до хоста 3 попадает на маршрутизатор 1.</p>
</li>
<li>
<p>Пакет от хоста 1 до хоста 3 оказывается на маршрутизаторе 3 (<strong>произошла магия!</strong>)</p>
</li>
<li>
<p>Маршрутизатор 3 смотрит на свою таблицу маршрутизации и отправляет пакет до хоста 3. Это мы умеем, так как маршрутизатор 3 знает про сеть 10.0.0.0/24.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Вот как раз для реализации данной магии и используется туннелирование. В данном случае нам нужно создать туннель от маршрутизатора 1 до маршрутизатора 3.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="VPN/images/vpn_6.png" alt="Туннелирование IP пакета.">
</div>
<div class="title">Figure 165. Туннелирование IP пакета.</div>
</div>
<div class="paragraph">
<p>Разберём по шагам, как это работает туннель:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Хост 1 генерирует пакет для хоста 3 и отправляет его маршрутизатор 1</p>
</li>
<li>
<p>Маршрутизатор 1 получает IP пакет для хоста 3.</p>
<div class="olist loweralpha">
<ol class="loweralpha" type="a">
<li>
<p>В настройках маршрутизатора 1 указывается, что пакеты для сети 10.0.0.0/24 (куда входит хост 3) необходимо упаковать в туннель.</p>
</li>
<li>
<p>Маршрутизатор 1 создаёт новый IP пакет, где IP-адрес отправителя он сам (212.220.12.1), а IP-адрес получателя маршрутизатор 3 (212.220.12.5).</p>
</li>
<li>
<p>Внутрь нового IP пакета упаковывается IP пакет от хоста 1 к хосту 3.</p>
</li>
</ol>
</div>
</li>
<li>
<p>Так как у маршрутизатора 1 и 3 есть белые IP-адреса и между ними ходят пакеты, то новый IP пакет доставляется провайдером (в нашем случае это маршрутизатор 2) до маршрутизатора 3.</p>
</li>
<li>
<p>Маршрутизатор 3 получает IP пакет, где IP-адрес получателя он сам. Значит, пакет нужно не маршрутизировать, а обрабатывать самому.</p>
</li>
<li>
<p>Разобрав IP заголовок, маршрутизатор 3 обнаруживает внутри ещё один IP пакет (от хоста 1 к хосту 3). В этот раз IP-адрес получателя не принадлежит маршрутизатору 3, значит пакет необходимо маршрутизировать.</p>
</li>
<li>
<p>Маршрутизатор 3 на основе своей таблицы маршрутизации отправляет IP пакет хосту 3.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>Вот таким образом туннелирование помогает организовать связь между двумя удалёнными офисами.</p>
</div>
<div class="paragraph">
<p>Туннелирование - очень популярная техника в руках сетевых администраторов. Соединить два удалённых офиса или дать доступ к внутренним ресурсам сотрудникам, которые работают удалённо. Помимо этого, применение туннелей популярно у тестировщиков. Например, когда нужно убедиться, что ваш сайт корректно отображается для иностранных посетителей (т.е. правильно определяется страна и язык на основе IP-адресов). Для этого вы можете установить туннели до серверов в других странах и посмотреть на свой сайт через них.</p>
</div>
</div>
<div class="sect2">
<h3 id="_vpn">VPN</h3>
<div class="paragraph">
<p>VPN (virtual private network) - это виртуальная частная сеть, обобщённое название технологий, позволяющих обеспечить одно или несколько сетевых соединений поверх чьей-либо другой сети. А туннелирование - это способ обеспечения таких соединений.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="VPN/images/vpn_vpn.png" alt="VPN.">
</div>
<div class="title">Figure 166. VPN.</div>
</div>
</div>
<div class="sect2">
<h3 id="_ipip">IPIP</h3>
<div class="paragraph">
<p>Туннель IPIP - пожалуй, самый простой способ рассказать о том, что такое туннель, как он работает и как решает поставленные задачи. Как можно догадаться из названия, IPIP туннель подразумевает передачу IP пакета внутри другого IP пакета. Описание IPIP туннеля можно найти в <a href="https://datatracker.ietf.org/doc/html/rfc2003">RFC 2003</a>.</p>
</div>
<div class="paragraph">
<p>Для установки IPIP туннеля нам потребуется два хоста, которые могут общаться между собой.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="VPN/images/vpn_ipip_1.png" alt="IPIP туннель между маршрутизатором 1 и маршрутизатором 3. (https://miminet.ru/web_network?guid=fe1fc02f-6bb4-421d-94cb-6902f826e30d).">
</div>
<div class="title">Figure 167. IPIP туннель между маршрутизатором 1 и маршрутизатором 3. (<a href="https://miminet.ru/web_network?guid=fe1fc02f-6bb4-421d-94cb-6902f826e30d" class="bare">https://miminet.ru/web_network?guid=fe1fc02f-6bb4-421d-94cb-6902f826e30d</a>)</div>
</div>
<div class="paragraph">
<p>Настройки туннеля на одном маршрутизаторе требует выполнить 2 действия:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Создание виртуального L3 интерфейса, а также настройка начального и конечного IP-адреса туннеля</p>
</li>
<li>
<p>Создание маршрута (т.е. добавить в таблицу маршрутизации), какие IP сети необходимо отправлять в туннель.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>Виртуальный интерфейс L3 уровня необходим, чтобы отправлять туда нужные нам IP пакеты. Внутри этого интерфейса наш IP пакет будет обрастать новым IP заголовком. Интерфейс L3 - означает, что ему нужно присвоить свой IP-адрес. Так как внутри этого интерфейса будет создаваться новый IP заголовок, при настройке необходимо ещё указать IP-адреса для источника и назначения.</p>
</div>
<div class="paragraph">
<p>В итоге создание интерфейса для IPIP туннеля на маршрутизаторе 1 требует:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>указать имя интерфейса, обычно это tun0, tunip или что-то в этом духе</p>
</li>
<li>
<p>указать IP-адрес исходящего интерфейса (начальная точка IPIP туннеля), в нашем случае это 212.220.12.1</p>
</li>
<li>
<p>указать IP-адрес конечной точки IPIP туннеля, в нашем случае это 212.220.12.5</p>
</li>
<li>
<p>указать IP-адрес для вновь создаваемого IPIP интерфейса, в нашем случае это 1.1.1.1</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Вторым шагом нужно настроить маршрутизацию. По умолчанию, пакет для хоста 3 маршрутизатор 1 попробует отправить дальше в сеть, а именно, на маршрутизатор 2. Нам нужно сообщить, чтобы он отправлял IP пакет не на маршрутизатор 2, а в IPIP интерфейс. Для этого мы добавим правило в таблицу маршрутизации:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>10.0.0.0/24 отправлять на 1.1.1.1</pre>
</div>
</div>
<div class="paragraph">
<p>Это означает, что все IP пакеты, у которых IP-адрес назначения попадает в сеть 10.0.0.0/24 отправлять в интерфейс с IP-адресом 1.1.1.1, т.е. в наш IPIP туннель.</p>
</div>
<div class="paragraph">
<p>На маршрутизаторе 3 необходимо выполнить похожие действия, чтобы пакет мог прийти в обратном направлении, от хоста 3 к хосту 1.</p>
</div>
<div class="paragraph">
<p>Чтобы посмотреть, как работает IPIP туннель, вы можете открыть готовую сеть (см. рисунок выше) и запустить анимацию сети. Обратите внимание, что от хостов вылетает ICMP пакет (так он подписан), а между маршрутизаторами ходит только IP. Дело в том, что во время анимации Miminet не знает про IPIP туннель. Эту функциональность мы вскоре добавим.</p>
</div>
<div class="paragraph">
<p>IPIP туннель очень просто и понятный, но обладает недостатками:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>данные передаются в открытом виде</p>
</li>
<li>
<p>нет аутентификации и авторизации</p>
</li>
<li>
<p>данные могут быть искажены или подменены во время передачи</p>
</li>
<li>
<p>IPIP инкапсулирует только IPv4 для одноадресной рассылки</p>
</li>
<li>
<p>IPIP туннель не может работать через NAT, т.е. если одна точка туннеля скрыта за NAT, то туннель не построить.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_ipip_туннель_меняем_местоположение">IPIP туннель (меняем местоположение)</h3>
<div class="paragraph">
<p>Давайте рассмотрим пример, как на рисунке ниже.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="VPN/images/vpn_ipip_2.png" alt="Сеть из 3-х маршрутизаторов и одного сервера. (https://miminet.ru/web_network?guid=1844d7b2-641b-4725-96b2-9e148d88daae).">
</div>
<div class="title">Figure 168. Сеть из 3-х маршрутизаторов и одного сервера. (<a href="https://miminet.ru/web_network?guid=1844d7b2-641b-4725-96b2-9e148d88daae" class="bare">https://miminet.ru/web_network?guid=1844d7b2-641b-4725-96b2-9e148d88daae</a>).</div>
</div>
<div class="paragraph">
<p><strong>Хост 1</strong> - это наш домашний или рабочий компьютер.</p>
</div>
<div class="paragraph">
<p><strong>Сервер 1</strong> - сервер, с котором мы хотим обмениваться данными. Допустим, мы занимаемся тестированием веб-сайта, который там запущен.</p>
</div>
<div class="paragraph">
<p><strong>Маршрутизатор 1</strong> - это наш маршрутизатор. В нашей внутренней сети используются серые IP-адреса, а наружу маршрутизатор смотрит белыми. В интернет мы выходим через NAT, как это обычно происходит.</p>
</div>
<div class="paragraph">
<p><strong>Маршрутизатор 2</strong> - какой-то маршрутизатор провайдера.</p>
</div>
<div class="paragraph">
<p><strong>Маршрутизатор 3</strong> - виртуальный маршрутизатор в другой стране, который мы где-то купили.</p>
</div>
<div class="paragraph">
<p>Все маршрутизаторы находятся в публичной сети интернет. Между ними множество других маршрутизаторов и различного сетевого оборудования провайдеров. Для удобства демонстрации я соединил маршрутизаторы напрямую.</p>
</div>
<div class="paragraph">
<p><strong>Задача</strong> - сделать так, чтобы хост 1 общался с сервером так, словно это делает маршрутизатор 3. То есть чтобы пакеты на сервер приходили с IP-адресом маршрутизатора 3. Предположим, что мы хотим проверить, как сервер определяет страну и выбирает язык отображения сайта на основании IP-адреса источника. Или, предположим, есть ограничения на трафик между маршрутизатором 1 и 2 и мы хотим  обойти их.</p>
</div>
<div class="paragraph">
<p>Решить эту задачу нам поможет туннель (возьмём IPIP) и NAT. В общих словах:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>от маршрутизатора 1 до маршрутизатора 3 мы построим IPIP туннель</p>
</li>
<li>
<p>на маршрутизаторе 3 мы настроим NAT, чтобы подменять IP-адрес источника (10.0.0.2) на IP-адрес маршрутизатора 3</p>
</li>
</ul>
</div>
<div class="imageblock">
<div class="content">
<img src="VPN/images/vpn_ipip_3.png" alt="IPIP туннель в обход. (https://miminet.ru/web_network?guid=e1cdb148-519a-480a-8c2f-78590fd2036d).">
</div>
<div class="title">Figure 169. IPIP туннель в обход. (<a href="https://miminet.ru/web_network?guid=e1cdb148-519a-480a-8c2f-78590fd2036d" class="bare">https://miminet.ru/web_network?guid=e1cdb148-519a-480a-8c2f-78590fd2036d</a>).</div>
</div>
<div class="paragraph">
<p>Настроенную сеть я изобразил выше (можете пройти по ссылке и посмотреть все настройки). А теперь давайте разберём по шагам, что и где будет происходить. Все изменения с пакетом, которые будут происходить на пути его следования, можно посмотреть на рисунке ниже.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="VPN/images/vpn_ipip_4.png" alt="Использование IPIP туннеля и NAT.">
</div>
<div class="title">Figure 170. Использование IPIP туннеля и NAT.</div>
</div>
<div class="ulist">
<ul>
<li>
<p>Хост 1 (10.0.0.2) отправляет IP пакет для сервера 1 (198.50.0.2).
IP пакет от хоста 1 для сервера 1 приходит на маршрутизатор 1 и он пытается его отправить дальше.</p>
</li>
<li>
<p>Маршрутизатор 1 смотрит в таблицу маршрутизации и находит запись, что IP пакеты с IP-адресом назначения из IP сети 198.50.0.0/24 нужно отправить в интерфейс 1.1.1.1. Для этого мы добавили маршрут (ip route add 198.50.0.0/24 via 1.1.1.1.)</p>
</li>
<li>
<p>Интерфейс 1.1.1.1 - это виртуальный сетевой интерфейс для IPIP туннеля, который мы настроили. IPIP туннель построен от маршрутизатора 1 (212.220.12.1) до маршрутизатора 3 (212.220.12.2).</p>
</li>
<li>
<p>Оригинальный IP пакет попадает в туннельный интерфейс, там к нему добавляется новый IP заголовок с IP-адресом отправителя 212.220.12.1 (маршрутизатор 1) и IP-адресом получателя 212.220.12.2 (маршрутизатор 3).</p>
</li>
<li>
<p>Маршрутизатор 1 смотрит в таблицу маршрутизации и отправляет новый IP пакет на маршрутизатор 3.</p>
</li>
<li>
<p>Маршрутизатор 3 получает пакет и разбирает IP заголовок. IP-адрес назначения равен одному из IP-адресов маршрутизатора 3, то пакет нужно обрабатывать.</p>
</li>
<li>
<p>Маршрутизатор 3 обрабатывает IP пакет и видит, что следующий протокол снова IP (оригинальный IP пакет).</p>
</li>
<li>
<p>Маршрутизатор 3 снова разбирает IP заголовок. IP-адрес назначения (198.50.0.2) не равен ни одному из IP-адресов маршрутизатора, значит, пакет нужно маршрутизировать, т.е. отправить в сеть.</p>
</li>
<li>
<p>IP-адрес назначения в оригинальном IP пакете равен 198.50.0.2 (сервер 1). Маршрутизатор 3, на основании таблицы маршрутизации решает, что оригинальный IP пакет нужно отправить на маршрутизатор 2.</p>
</li>
<li>
<p>На маршрутизаторе 3 настроен NAT. Его правило гласит - всем пакетам, которые отправляются в интерфейс, ведущий к маршрутизатору 2, менять IP-адрес источника на свой (212.220.12.9).</p>
</li>
<li>
<p>Маршрутизатор 3 заменяет IP-адрес источника на свой (212.220.12.9) в оригинальном IP пакете и отправляет его в сеть.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Вот таким вот образом, на маршрутизатор 2 приходит IP пакет, где:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>IP-адрес источника стоит маршрутизатор 3</p>
</li>
<li>
<p>IP-адрес назначения стоит сервер 1</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>Получив такой пакет, маршрутизатор 2 отправляет его на сервер. Как и маршрутизатор 2, сервер считает, что пакет пришёл от маршрутизатора 3.</p>
</div>
<div class="paragraph">
<p>Во время ответа от сервера 1, пакет пройдёт обратный путь:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>дойдя до маршрутизатора 3, на пакет сработает NAT, и вернёт старый IP-адрес. То есть подменит IP-адрес назначения (так как это ответный пакет) на тот, что стоял раньше, 10.0.0.2 (хост 1).</p>
</li>
<li>
<p>маршрутизатор 3, посмотрев свою таблицу маршрутизации, обнаружит, что все IP пакеты до сети 10.0.0.0/24 нужно отправлять в IPIP туннель. Этот туннель ведёт до маршрутизатора 1.</p>
</li>
<li>
<p>на маршрутизаторе 1 пакет появится из туннеля и будет отправлен хосту 1.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Вот таким нехитрым способом можно строить соединения от одного хоста к другому через свои маршрутизаторы/сервера.</p>
</div>
</div>
<div class="sect2">
<h3 id="_gre_generic_routing_encapsulation">GRE (Generic Routing Encapsulation)</h3>
<div class="paragraph">
<p>Как уже подчёркивалось, IPIP туннелирование имеет ряд недостатков. Серьёзной проблемой является то, что IPIP туннель может положить внутрь только IPv4 пакет.</p>
</div>
<div class="paragraph">
<p>Обычно для построения туннелей используется GRE протокол. GRE (Generic Routing Encapsulation — общая инкапсуляция маршрутов) -  протокол туннелирования сетевых пакетов, разработанный компанией CISCO Systems. GRE может пробрасывать IPv4/IPv6/групповой трафик, а также немаршрутизируемые протоколы: NetBios, IPX, AppleTalk.</p>
</div>
<div class="paragraph">
<p>GRE описан в <a href="https://datatracker.ietf.org/doc/html/rfc2784">RFC 2784</a>, документ небольшой можете почитать самостоятельно. Размер GRE заголовка всего 4 байта.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="VPN/images/vpn_gre_1.png" alt="Заголовок GRE. (https://datatracker.ietf.org/doc/html/rfc2784).">
</div>
<div class="title">Figure 171. Заголовок GRE. (<a href="https://datatracker.ietf.org/doc/html/rfc2784" class="bare">https://datatracker.ietf.org/doc/html/rfc2784</a>).</div>
</div>
<div class="paragraph">
<p>Он вставляется сразу после IP заголовка. На рисунке ниже показана схема инкапсуляции IP пакета в GRE туннель.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="VPN/images/vpn_gre_2.png" alt="Инкапсуляция в GRE.">
</div>
<div class="title">Figure 172. Инкапсуляция в GRE.</div>
</div>
<div class="paragraph">
<p>Как и IPIP туннель, GRE туннель без состояния. Это означает, что конечные точки этого туннеля не хранят состояния о том, кто на другом конце. Если вдруг один из маршрутизаторов этого туннеля выключился или стал недоступен, то второй об этом никак не узнает. GRE небезопасен, передаёт данные в том виде, в котором он их получил. GRE туннель не работает через NAT.</p>
</div>
</div>
<div class="sect2">
<h3 id="_разновидности_туннелей">Разновидности туннелей</h3>
<div class="paragraph">
<p>В целом, все туннели работают по похожей схеме:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>На двух хостах (маршрутизаторах, серверах, пользовательских ПК, телефонах и т.д.) настраивается туннель.</p>
</li>
<li>
<p>После настройки туннеля создаётся виртуальное сетевое устройство, куда будут отправляться пакеты.</p>
</li>
<li>
<p>Добавляются маршруты в таблицу маршрутизации, чтобы отправлять в туннель не все пакеты, а только интересующие</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>Вот и всё.</p>
</div>
<div class="paragraph">
<p>А дальше, различные виды туннелей отличаются по функциональности. Кто-то работает поверх IP (IPIP, GRE), кто-то работает поверх протоколов транспортного уровня TCP/UDP (L2TP, OpenVPN) и работает через NAT, кто-то умеет шифровать данные, кто-то умеет ещё и проходить авторизацию, а кто-то умеет всё это.</p>
</div>
<div class="paragraph">
<p>Существует много различных способов организовать туннель от одного хоста к другому. Ниже приведу небольшой список туннелей с краткими характеристиками их работы.</p>
</div>
</div>
<div class="sect2">
<h3 id="_openvpn">OpenVPN</h3>
<div class="paragraph">
<p>Один из самых распространённых туннелей сегодня. OpenVPN - открытая свободная реализация технологии виртуальной частной сети (VPN) с открытым исходным кодом. В отличие от IPIP и GRE, OpenVPN создаёт зашифрованный канал между сервером и клиентами.</p>
</div>
<div class="paragraph">
<p>OpenVPN работает поверх транспортных протоколов TCP/UDP (по умолчанию используется <a href="https://www.iana.org/assignments/service-names-port-numbers/service-names-port-numbers.txt">порт 1194</a>), что даёт возможность работать через NAT. В общем случае предпочтительным является UDP, так как внутри туннеля зачастую передаются TCP сессии и передавать одну TCP сессию внутри другой не несёт в себе большого смысла.</p>
</div>
<div class="paragraph">
<p>OpenVPN предлагает два различных варианта сетевых интерфейсов: TUN и TAP.</p>
</div>
<div class="paragraph">
<p><strong>TUN</strong> позволяет создавать туннели сетевого уровня, т.е. внутрь туннеля отправляется пакет вплоть до заголовка сетевого уровня.</p>
</div>
<div class="paragraph">
<p><strong>TAP</strong> - для создания туннелей канального уровня, т.е. вкладывается внутрь туннеля весь пакет, включая заголовок канального уровня (Ethernet).</p>
</div>
<div class="paragraph">
<p>Также возможно использование библиотеки компрессии LZO для сжатия потока данных.</p>
</div>
</div>
<div class="sect2">
<h3 id="_ipsec">IPsec</h3>
<div class="paragraph">
<p>IPsec (сокращение от IP Security) - набор протоколов для обеспечения защиты данных, передаваемых по протоколу IP. Хоть сам по себе IPsec и не является туннелем, сложно пройти мимо и не упомянуть его.</p>
</div>
<div class="paragraph">
<p>Уточню для начала, что IPSec - это не один протокол, это стандарт, включающий в себя целых три протокола, каждый со своими функциями:</p>
</div>
<div class="paragraph">
<p><strong>ESP</strong> (Encapsulating Security Payload – безопасная инкапсуляция полезной нагрузки) занимается непосредственно шифрованием данных, а также может обеспечивать аутентификацию источника и проверку целостности данных.</p>
</div>
<div class="paragraph">
<p><strong>AH</strong> (Authentication Header – заголовок аутентификации) отвечает за аутентификацию источника и проверку целостности данных.</p>
</div>
<div class="paragraph">
<p><strong>IKE</strong> (Internet Key Exchange protocol – протокол обмена ключами) используется для формирования IPSec SA, проще говоря, согласования работы участников защищённого соединения. Используя этот протокол, участники договариваются, какой алгоритм шифрования будет использоваться, по какому алгоритму будет производиться (и будет ли вообще) проверка целостности, как аутентифицировать друг друга.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="VPN/images/vpn_ipsec_1.png" alt="Туннельный и транспортный режим работы IPsec.">
</div>
<div class="title">Figure 173. Туннельный и транспортный режим работы IPsec.</div>
</div>
<div class="paragraph">
<p>IPsec может функционировать в двух режимах: туннельном и транспортном.</p>
</div>
<div class="paragraph">
<p>В туннельном режиме шифруется весь исходный IP-пакет: данные, заголовок, а затем он вставляется в поле данных нового пакета, то есть происходит инкапсуляция. В целом, можно создавать IPsec туннели.</p>
</div>
<div class="paragraph">
<p>В транспортном режиме шифруются или подписываются только данные IP-пакета, исходный заголовок сохраняется. Транспортный режим, как правило, используется для установления соединения между хостами. Он может также использоваться между маршрутизаторами для защиты туннелей, организованных каким-нибудь другим способом (GRE).</p>
</div>
<div class="paragraph">
<p>В туннелировании IPsec часто применяется в паре с другими протоколами, чтобы обеспечивать шифрование, аутентификацию и целостность данных. Например, GRE over IPsec.</p>
</div>
</div>
<div class="sect2">
<h3 id="_pptp">PPTP</h3>
<div class="paragraph">
<p>PPTP (Point-to-Point Tunneling Protocol) - устаревший способ создания туннелей из-за проблем с безопасностью. Описан в <a href="https://datatracker.ietf.org/doc/html/rfc2637">RFC 2637</a>.</p>
</div>
<div class="paragraph">
<p>Создание PPTP туннеля состоит из двух частей:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Установка управляющего TCP соединения на <a href="https://www.iana.org/assignments/service-names-port-numbers/service-names-port-numbers.txt">порт 1723</a> между двумя точками туннеля. Данное соединение используется для установки и управления GRE туннелем между этими же хостами.</p>
</li>
<li>
<p>Создание GRE туннеля.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>PPTP использует расширенный формат GRE заголовка, включающий поле Acknowledgment Number.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="VPN/images/vpn_pptp_1.png" alt="Расширенный GRE заголовок в PPTP. (https://datatracker.ietf.org/doc/html/rfc2637#section-4.1)">
</div>
<div class="title">Figure 174. Расширенный GRE заголовок в PPTP. (<a href="https://datatracker.ietf.org/doc/html/rfc2637#section-4.1" class="bare">https://datatracker.ietf.org/doc/html/rfc2637#section-4.1</a>)</div>
</div>
<div class="paragraph">
<p>Сам GRE туннель инкапсулирует внутрь PPP пакеты, как показано на рисунке ниже.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="VPN/images/vpn_pptp_2.png" alt="Инкапсуляция IP пакета в PPTP туннеле.">
</div>
<div class="title">Figure 175. Инкапсуляция IP пакета в PPTP туннеле.</div>
</div>
<div class="paragraph">
<p>PPTP может передавать IP, NetBEUI и IPX пакеты.</p>
</div>
</div>
<div class="sect2">
<h3 id="_mppe_и_mppc">MPPE и MPPC</h3>
<div class="paragraph">
<p>MPPE (Microsoft Point-To-Point Encryption Protocol) - протокол, разработанный компанией Microsoft. Позволяет организовать шифрование данных в PPTP туннеле. Более подробно можно почитать в <a href="https://datatracker.ietf.org/doc/html/rfc3078">RFC 3078</a>. Как правило, вместе с MPPE используется MPPC (Microsoft Point-to-Point Compression, <a href="https://datatracker.ietf.org/doc/html/rfc2118">RFC 2118</a>) протокол. Он занимается сжатием данных. Вместе они сжимают и шифруют данные.</p>
</div>
</div>
<div class="sect2">
<h3 id="_l2tp">L2TP</h3>
<div class="paragraph">
<p>L2TP (Layer 2 Tunneling Protocol) - туннельный протокол для построения VPN описан в <a href="https://datatracker.ietf.org/doc/html/rfc2661">RFC 2661</a>. В отличие от PPTP, IP и GRE, L2PT использует UDP протокол (<a href="https://www.iana.org/assignments/service-names-port-numbers/service-names-port-numbers.txt">порт 1701</a>) для передачи данных. Что позволяет ему работать через NAT.</p>
</div>
<div class="paragraph">
<p>Как и PPTP, L2TP передаёт PPP пакеты. Схема инкапсуляции IP пакета в L2TP туннель представлена на рисунке ниже.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="VPN/images/vpn_l2tp_1.png" alt="Инкапсуляция IP пакета в L2TP туннеле.">
</div>
<div class="title">Figure 176. Инкапсуляция IP пакета в L2TP туннеле.</div>
</div>
<div class="paragraph">
<p>Сам по себе L2PT не предоставляет возможностей для шифрования или целостности передачи данных через публичные сети (как и IPIP или GRE). Поэтому, он часто используется вместе с IPsec. Такую связку называют L2TP/IPsec.</p>
</div>
<div class="paragraph">
<p>L2TP протокол передачи с установлением соединения. Конечные точки соединения называются LAC (L2TP access concentrator) и LNS (L2TP network server). LNS ожидает соединения от LAC. Как только соединение установлено, данные могут передаваться в обе стороны.</p>
</div>
<div class="paragraph">
<p>L2TP пакеты бывают двух видов: <strong>управляющие</strong> (control packets) и <strong>информационные</strong> (data packets). Управляющие сообщения используются для установки, при поддержании и аннулировании туннелей. Они используют надёжный управляющий канал в пределах L2TP, чтобы гарантировать доставку. Ниже проставлен формат L2TP заголовка.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="VPN/images/vpn_l2tp_2.png" alt="Заголовок L2TP пакета. (https://datatracker.ietf.org/doc/html/rfc2661#page-9)">
</div>
<div class="title">Figure 177. Заголовок L2TP пакета. (<a href="https://datatracker.ietf.org/doc/html/rfc2661#page-9" class="bare">https://datatracker.ietf.org/doc/html/rfc2661#page-9</a>)</div>
</div>
<div class="paragraph">
<p>Для надёжности передачи управляющих пакетов используются поля <strong>Ns</strong> и <strong>Nr</strong>.</p>
</div>
<div class="paragraph">
<p><strong>Ns</strong> - определяет порядковый номер информационного или управляющего пакета, начиная с нуля и увеличиваясь на 1 для каждого переданного пакета.</p>
</div>
<div class="paragraph">
<p>Поле <strong>Nr</strong> - содержит порядковый номер, который ожидается для следующего пакета. Таким образом, Nr устанавливается равным Ns последнего по порядку полученного пакета плюс 1. В информационных пакетах Nr зарезервировано и, если присутствует (это определяется S- битом), должно игнорироваться при получении.</p>
</div>
<div class="paragraph">
<p>Информационные сообщения при потере повторно не пересылаются. Восстановление потерянных пакетов с данными возлагается на протоколы транспортного уровня в инкапсулированных данных.</p>
</div>
<div class="paragraph">
<p>L2TP туннель весьма популярный:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Может использоваться в связке с IPsec, что даст высокий уровень безопасности.</p>
</li>
<li>
<p>Доступен по умолчанию на Windows, Linux, MacOS и многих других ОС.</p>
</li>
<li>
<p>Довольно простой в настройке.</p>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_dhcp">DHCP</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Для корректной работы хоста в сети интернет у него должны быть настроены: IP-адрес, маска подсети, IP-адрес маршрутизатора по умолчанию и, возможно, ещё  какие-то параметры. Вот если попробовать вспомнить, когда вы подключаетесь к сети дома или в кафе, вы настраиваете все эти параметры? Скорее всего, нет! Это работает DHCP.</p>
</div>
<div class="paragraph">
<p>DHCP (Dynamic Host Configuration Protocol) - протокол динамической конфигурации хостов, описан в <a href="https://datatracker.ietf.org/doc/html/rfc2131">RFC 2131</a>. Занимается автоматической настройкой сетевых параметров у хостов.</p>
</div>
<div class="paragraph">
<p>Например, вы установили дома у родителей новый Wi-Fi маршрутизатор, попросили их подключиться к нему и, вместо доступа к сети интернет, сидите и настраиваете на ноутбуке IP-адрес, маску, указываете IP-адрес маршрутизатора по умолчанию и DNS сервер (используется для разрешения имён в IP-адрес, например, ya.ru в 77.88.55.242). Или, вы администратор в компании. К вам в офис привезли и подключили 50 новых ПК для разработчиков. И теперь вам необходимо идти в другое помещение и руками прописывать всем новым ПК сетевые настройки. Конечно, это та работа, которую лучше избежать. Она отнимает время, и есть большая вероятность допустить опечатку. И даже если всё сделать чётко, через несколько недель может оказаться, что всем этим ПК нужно сменить сетевые настройки на другие.</p>
</div>
<div class="paragraph">
<p>Чтобы не тратить время сетевых администраторов и простых пользователей сети на сетевые настройки, используется DHCP.</p>
</div>
<div class="paragraph">
<p>DHCP - это протокол прикладного уровня, располагается на 7 уровне модели ISO/OSI, как это показано на рисунке ниже. Прикладной протокол означает, что протокол работает не в ядре вашей ОС (как это делает IP, TCP, UDP, ICMP), а это отдельная программа (сервис в ОС Windows, демон в ОС Linux), которая работает в пользовательском пространстве.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="tcp_ip/dhcp/images/dhcp_1.png" alt="DHCP в модели ISO/OSI.">
</div>
<div class="title">Figure 178. DHCP в модели ISO/OSI.</div>
</div>
<div class="paragraph">
<p>Забегая вперёд, скажу, что с позиции архитектуры, DHCP довольно интересный! С одной стороны, он занимается настройкой IP-адреса, маски и т.д, а с другой, использует IP протокол.</p>
</div>
<div class="sect2">
<h3 id="_dhcp_архитектура">DHCP архитектура</h3>
<div class="paragraph">
<p>DHCP использует клиент-серверную архитектуру, т.е. DHCP-клиент обращается к DHCP-серверу за настройками. Получив такие настройки от сервера, DHCP-клиент использует их для настройки указанного сетевого интерфейса.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
У вас на хосте может быть несколько сетевых интерфейсов, поэтому DHCP-клиенту нужно сообщить, какой именно сетевой интерфейс необходимо настроить.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>DHCP-клиент и сервер общаются между собой при помощи DHCP сообщений. Формат сообщения изображён на рисунке ниже.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="tcp_ip/dhcp/images/dhcp_2.png" alt="Формат DHCP пакета. (https://datatracker.ietf.org/doc/html/rfc2131#page-13)">
</div>
<div class="title">Figure 179. Формат DHCP пакета. (<a href="https://datatracker.ietf.org/doc/html/rfc2131#page-13" class="bare">https://datatracker.ietf.org/doc/html/rfc2131#page-13</a>)</div>
</div>
<div class="paragraph">
<p>В качестве протокола транспортного уровня DHCP использует UDP. При этом:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>DHCP-сервер использует UDP порт 67</p>
</li>
<li>
<p>DHCP-клиент использует UDP порт 68</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Разные порты используются, чтобы DHCP-клиент не обрабатывал сообщения, предназначенные для сервера. И наоборот.</p>
</div>
<div class="paragraph">
<p>Давайте разберёмся с полями в заголовке, они дадут хорошее представление о работе протокола:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>op</strong> - тип сообщения. Значение 1 = BOOTREQUEST устанавливает клиент, при отправке запроса. Значение 2 = BOOTREPLY устанавливает сервер в ответе.</p>
</li>
<li>
<p><strong>htype</strong> - тип аппаратного адреса, например, значение 1 используется для Ethernet. DHCP протокол может работать не только в Ethernet сети, поэтому клиент имеет возможность сообщить, какой аппаратный адрес он использует.</p>
</li>
<li>
<p><strong>hlen</strong> - размер аппаратного адреса. Значение 6 используется для Ethernet (размер MAC-адреса 6 байт).</p>
</li>
<li>
<p><strong>hops</strong> - число ретрансляторов (DHCP relay agent). DHCP-клиент устанавливает это поле в 0, DHCP ретрансляторы, при пересылке сообщения могут увеличивать этот счётчик на 1. Таким образом, когда сообщение дойдёт до DHCP-сервера, он будет знать, сколько между ним и DHCP-клиентом ретрансляторов (иногда их называют DHCP-агенты).</p>
</li>
<li>
<p><strong>xid</strong> - идентификатор транзакции. Случайное число, однозначно определяющее диалог между клиентом и сервером. Когда сервер формирует ответ, он указывает идентификатор трансляции равным тому, что был получен в запросе.</p>
</li>
<li>
<p><strong>secs</strong> - число секунд с начала процесса получения или обновления адреса, указываемое DHCP-клиентом.</p>
</li>
<li>
<p><strong>flags</strong> - флаги.</p>
</li>
<li>
<p><strong>ciaddr</strong> - текущий IP-адрес клиента. Устанавливается, если DHCP-клиент уже обладает некоторым IP-адресом и выполняет запрос, чтобы обновить или освободить ранее полученный IP-адрес. Также этот флаг означает, что клиент может отвечать на ARP запросы.</p>
</li>
<li>
<p><strong>yiaddr</strong> - IP-адрес, который DHCP-сервер предлагает клиенту.</p>
</li>
<li>
<p><strong>siaddr</strong> - IP-адрес следующего сервера для конфигурации. Обычно используется для загрузки образов по сети.</p>
</li>
<li>
<p><strong>giaddr</strong> - адрес ретранслятора, который ретранслировал DHCP-сообщение.</p>
</li>
<li>
<p><strong>сhaddr</strong> - аппаратный адрес клиента. В это поле DHCP-клиент записывает свой MAC-адрес, когда отправляет запросы на сервер.</p>
</li>
<li>
<p><strong>sname</strong> - имя сервера (опциональное поле).</p>
</li>
<li>
<p><strong>file</strong> - полный путь к файлу для загрузки по сети. Не всегда ПК загружается с локального жёсткого диска (SSD/ HDD). Иногда диска просто нет, а иногда вы просто хотите загрузить образ по сети. Например, вы хотите выполнить автоматическую установку ОС на новые компьютеры в вашем офисе или учебном классе. Ходить по всем компьютерам и в каждый вставлять загрузочную флешку неудобно. Можно создать загрузочный образ с автоматической установкой ОС и загрузить его на ПК по сети.</p>
</li>
<li>
<p><strong>options</strong> - список параметров. Именно в параметрах будет указываться выдаваемая маска подсети, маршрутизатор по умолчанию и другие сетевые параметры.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_dhcp_сервер">DHCP-сервер</h3>
<div class="paragraph">
<p>Чтобы в вашей сети заработал DHCP необходимо запустить и сконфигурировать DHCP-сервер. Если мы говорим о домашней сети с Wi-Fi маршрутизатором, то там DHCP запускается автоматически. Как только вы включите и выполните первичную настройку вашего Wi-Fi маршрутизатора, DHCP-сервер автоматически запустится и будет готов к работе. Такие DHCP-сервера (дома, в кафе, ресторане, в БЦ, поезде) обычно выдают следующий настройки:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>IP-адрес</p>
</li>
<li>
<p>маску подсети</p>
</li>
<li>
<p>IP-адрес маршрутизатора по умолчанию</p>
</li>
<li>
<p>DNS сервер</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Это вполне хватит для простого доступа в интернет. На самом деле DHCP способен на большее. Он может выдавать около 200 различных параметров и настроек, полный список можно посмотреть на сайте IANA (<a href="https://www.iana.org/assignments/bootp-dhcp-parameters/bootp-dhcp-parameters.xhtml" class="bare">https://www.iana.org/assignments/bootp-dhcp-parameters/bootp-dhcp-parameters.xhtml</a>).</p>
</div>
<div class="paragraph">
<p>Если вы администратор сети в компании, то, скорее всего, вы будете самостоятельно настраивать и запускать DHCP-сервер на своём оборудовании.</p>
</div>
</div>
<div class="sect2">
<h3 id="_взаимодействие_dhcp_клиента_и_dhcp_сервера">Взаимодействие DHCP-клиента и DHCP-сервера</h3>
<div class="paragraph">
<p>Взаимодействие DHCP-клиента и сервера довольно интересное. С одной стороны, DHCP-клиент должен получить сетевые настройки, а с другой, он использует сетевой протокол (IP).</p>
</div>
<div class="paragraph">
<p>На рисунке ниже представлена обычная схема взаимодействия DHCP-клиента и сервера. Схему взаимодействия буду подкреплять реальными DHCP сообщениями.  Если у вас тоже настройки выдаются автоматически, то вы тоже сможете посмотреть реальные DHCP сообщения. Для этого:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Запустите Wireshark (это сниффер) и начните захватывать пакеты с вашего основного сетевого интерфейса.</p>
</li>
<li>
<p>Если у вас Windows, то запустите командную строку от имени Администратора</p>
<div class="olist loweralpha">
<ol class="loweralpha" type="a">
<li>
<p>выполните команду <code><code>ipconfig /release</code></code></p>
</li>
<li>
<p>затем выполните <code><code>команду ipconfig /renew</code></code></p>
</li>
</ol>
</div>
</li>
<li>
<p>Если у вас MacOS, то в командной строке</p>
<div class="olist loweralpha">
<ol class="loweralpha" type="a">
<li>
<p>выполните команду <code><code>sudo ipconfig set en0 none</code></code></p>
</li>
<li>
<p>затем выполните команду <code><code>sudo ipconfig set en0 dhcp</code></code></p>
</li>
</ol>
</div>
</li>
<li>
<p>Остановите Wireshark и отфильтруйте пакеты по “dhcp”.</p>
</li>
</ol>
</div>
<div class="imageblock">
<div class="content">
<img src="tcp_ip/dhcp/images/dhcp_3.png" alt="Взаимодействие DHCP-клиента и DHCP-сервера.">
</div>
<div class="title">Figure 180. Взаимодействие DHCP-клиента и DHCP-сервера.</div>
</div>
</div>
<div class="sect2">
<h3 id="_dhcp_discover">DHCP DISCOVER</h3>
<div class="paragraph">
<p>Клиент только что подключился к сети и ничего не знает о ней и не имеет собственных сетевых настроек. Сначала он пытается обнаружить в сети рабочий DHCP-сервер. Для этого DHCP-клиент отправляет сообщение <strong>DHCP DISCOVER</strong> на широковещательный IP-адрес (255.255.255.255). Так как IP-адрес широковещательный, то и MAC-адрес тоже устанавливается широковещательным (FF:FF:FF:FF:FF:FF). Этот запрос получают и обрабатывают все хосты в сети.</p>
</div>
<div class="paragraph">
<p>Так как своего IP-адреса ещё нет, то сообщение DHCP DISCOVER отправляется от IP-адреса 0.0.0.0. Внутри этого DHCP сообщения можно увидеть, что почти все поля заполнены 0, кроме некоторых:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>поле <strong>op</strong> установлено в 1 (Boot Request).</p>
</li>
<li>
<p>в поле <strong>chaddr</strong> (MAC-адрес DHCP-клиента) записан MAC-адрес клиента. Может показаться, зачем вообще нужно это поле? DHCP-сервер получает DHCP DICSCOVER сообщение, обрабатывает его и решает отправить DHCP-клиенту ответ. А куда его отправлять? У клиента еще нет IP-адреса! Единственное, что может в этой ситуации сделать сервер, отправить сообщение на MAC-адрес клиента. Хорошо! А на какой MAC-адрес отправлять? Как мы помним, протоколы независимы друг от друга. Т.е. получив DHCP сообщение на уровне приложения (7-й уровень модели ISO/OSI) мы без понятия какие значения MAC-адреса отправителя и получателя были установлены на канальном уровне (2-й уровень модели ISO/OSI). Другими словами, мы не знаем MAC-адрес отправителя. Вот, чтобы решить эту проблему, поле MAC-адрес отправителя есть в DHCP сообщениях и оно помогает серверу отправить ответ.</p>
</li>
<li>
<p>в поле option можно заметить наличие опции Message Type, значение которой установлено в Discover.</p>
</li>
</ul>
</div>
<div class="imageblock">
<div class="content">
<img src="tcp_ip/dhcp/images/dhcp_4.png" alt="DHCP DICSOVER  в Wireshark.">
</div>
<div class="title">Figure 181. DHCP DICSOVER  в Wireshark.</div>
</div>
</div>
<div class="sect2">
<h3 id="_dhcp_offer">DHCP OFFER</h3>
<div class="paragraph">
<p>Получив сообщение DHCP DISCOVER, сервер определяет, может ли он выдать клиенту сетевые настройки. Обычно DHCP-сервер старается запомнить клиента (по MAC-адресу). Если клиент подключается первый раз, то ему выдаются сетевые настройки. Если клиент приходит повторно, то сервер старается ему выдать сетевые настройки, которые были в прошлый раз. Например, в домашней сети вам всегда будет выдаваться один и тот же IP-адрес.</p>
</div>
<div class="paragraph">
<p>Так как в сообщении DHCP OFFER сервер будет предлагать клиенту конкретный IP-адрес, то сервер должен убедиться, что такого IP-адреса в сети нет. Поэтому перед формированием DHCP OFFER сервер отправляет в сеть ICMP Echo запрос на IP-адрес, который он собирается предложить клиенту. Если ответа на такой запрос не последует, то все в порядке и IP можно выделять.</p>
</div>
<div class="paragraph">
<p>Получив DHCP DISCOVER и сформировав ответ, сервер отправляет сообщение DHCP OFFER. Сообщение DHCP OFFER сообщает, какие сетевые настройки сервер может выдать клиенту. То есть сервер ещё ничего не выдал, он только предлагает (от английского слова offer).</p>
</div>
<div class="imageblock">
<div class="content">
<img src="tcp_ip/dhcp/images/dhcp_5.png" alt="DHCP OFFER в Wireshark">
</div>
<div class="title">Figure 182. DHCP OFFER в Wireshark</div>
</div>
<div class="paragraph">
<p>Иногда DHCP OFFER отправляется конкретно получателю (unicast), а иногда широковещательной рассылкой. Это зависит от клиента. Если вы посмотрите на сообщение DHCP DISCOVER, то обратите внимание на поле <strong>Bootp flags</strong>, оно установлено в Unicast. Это будет означать, что сервер может отправлять ответное сообщение прямо на MAC-адрес клиента. В противном случае, если поле <strong>Bootp flags</strong> будет установлено в Broadcast, то ответные пакеты от DHCP-сервера будут отправлять на широковещательный адрес. В нашем случае сообщение DHCP OFFER отправилось прямо получателю.</p>
</div>
<div class="paragraph">
<p>Обратите внимание на IP получателя (колонка Destination), он равен 10.10.10.108. DHCP OFFER отправляется прямо клиенту, у которого ещё нет своего IP-адреса. А отправлять пакеты на IP-адрес 0.0.0.0 нельзя. Поэтому DHCP-сервер в качестве IP-адреса получателя ставит предлагаемый клиенту IP-адрес.</p>
</div>
<div class="paragraph">
<p>В сообщение DHCP OFFER уже можно увидеть заполненные поля <strong>yiaddr</strong> (10.10.10.108 - IP-адрес, который DHCP-сервер предлагает клиенту) и <strong>siaddr</strong> (10.10.10.1 - IP-адрес следующего сервера для конфигурации).</p>
</div>
<div class="imageblock">
<div class="content">
<img src="tcp_ip/dhcp/images/dhcp_6.png" alt="Поля options в сообщение DHCP OFFER.">
</div>
<div class="title">Figure 183. Поля options в сообщение DHCP OFFER.</div>
</div>
<div class="paragraph">
<p>Если в Wireshark пролистать DHCP OFFER сообщение чуть ниже, то можно увидеть предлагаемые опции:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>IP Address Lease Time</strong> равен 186 400 секунд. Это время, на которое выдаётся IP-адрес. DHCP-сервер не выдаёт IP-адреса навсегда, он сдает их в аренду на конкретное время. Каждый раз, когда DHCP-сервер выдает IP-адрес, он указывает продолжительность аренды. Например, в кафе пришёл клиент и подключился к местному Wi-Fi. Он попил кофе, проверил почту и ушел. Выданный IP-адрес ему больше не нужен, при этом вы не можете этот IP-адрес выдать другому клиенту кафе. Чтобы зря не тратить IP-адреса, их сдают в аренду на время.</p>
</li>
<li>
<p>Помимо <strong>IP Address Lease Time</strong> важной является опция <strong>Renewal Time Value</strong>. Это время, через которое DHCP-клиент должен заново продлить аренду. Обычно оно равняется половине времени <strong>IP Address Lease Time</strong>. То есть DHCP-клиент, получив адрес на 186 400 секунд, должен будет через 93 200 секунд продлить аренду выданного адреса. Если клиент не продлит аренду, то через 186 400 секунд DHCP-сервер будет считать, что данный IP-адрес свободен и снова сможет быть выдан.</p>
</li>
<li>
<p>Опция <strong>Subnet mask</strong> (маска подсети) со значением 255.255.255.0</p>
</li>
<li>
<p>Опция <strong>Domain Name Server</strong> (DNS сервер) содержит IP-адрес DNS-сервера. Он необходим, чтобы разрешать DNS имена (yandex.ru) в IP-адрес.</p>
</li>
<li>
<p>Опция <strong>Router</strong> (маршрутизатор по умолчанию) со значением 10.10.10.1.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Вот так, в сообщении DHCP OFFER DHCP-сервер предлагает клиенту сетевые настройки. Ещё раз обращаю внимание, что в сообщении DHCP OFFER, DHCP-сервер только предлагает сетевые настройки. То есть они ещё никому не выданы.</p>
</div>
<div class="paragraph">
<p>Получив сообщение DHCP OFFER клиент принимает решение, устраивают ли его данные параметры или нет. Он может так делать. На практике DHCP-клиент принимает любое сообщение DHCP OFFER.</p>
</div>
</div>
<div class="sect2">
<h3 id="_dhcp_request">DHCP REQUEST</h3>
<div class="paragraph">
<p>Приняв DHCP OFFER клиент генерирует сообщение DHCP REQUEST. На сетевом и канальном уровне стоят широковещательные адреса (255.255.255.255 и FF:FF:FF:FF:FF:FF соответственно). Может показаться, зачем так, ведь клиент уже знает IP и MAC-адрес DHCP-сервера, когда он получил DHCP OFFER. Сообщение DHCP REQUEST отправляется на широковещательный адрес специально. Дело в том, что в сети могут находиться несколько DHCP-серверов и клиент мог получить несколько DHCP OFFER. Выбрав какой-то один DHCP-сервер, клиент отправляет сообщение DHCP REQUEST на широковещательный адрес, чтобы другие DHCP-сервера получили это сообщение и поняли, что клиент выбрал не их, и освободили от резерва предлагаемый IP-адрес.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="tcp_ip/dhcp/images/dhcp_7.png" alt="DHCP REQUEST в Wireshark.">
</div>
<div class="title">Figure 184. DHCP REQUEST в Wireshark.</div>
</div>
<div class="paragraph">
<p>В самом сообщении DHCP REQUEST, как и в случае с DHCP OFFER, заполнено поле op (Boot Request) и поле chaddr (MAC-адрес клиента). А если посмотреть опции, то можно увидеть:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>DHCP Server Identifier</strong> (опция в конце списка) равен 10.10.10.1 указывает на DHCP-сервер, который выбрал клиент.</p>
</li>
<li>
<p><strong>DHCP Message Type</strong> (тип DHCP сообщения) равен Request.
Client Identifier (идентификатор клиента) содержит MAC-адрес клиента.</p>
</li>
<li>
<p><strong>Requested IP Address</strong> (запрашиваемый IP-адрес) равен 10.10.10.108. Тот самый IP-адрес, который DHCP-сервер предлагал в DHCP OFFER в поле <strong>yiaddr</strong>.</p>
</li>
</ul>
</div>
<div class="imageblock">
<div class="content">
<img src="tcp_ip/dhcp/images/dhcp_8.png" alt="Опции в сообщении DHCP REQUEST в Wireshark.">
</div>
<div class="title">Figure 185. Опции в сообщении DHCP REQUEST в Wireshark.</div>
</div>
</div>
<div class="sect2">
<h3 id="_dhcp_acknack">DHCP ACK/NACK</h3>
<div class="paragraph">
<p>Если всё хорошо, то DHCP-сервер, получив такое сообщение, отправит клиенту сообщение DHCP ACK. В котором, как и в сообщение DHCP OFFER, в поле yiaddr будет прописан выдаваемый клиенту IP-адрес, а в опциях будут:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>маска подсети</p>
</li>
<li>
<p>DNS сервер</p>
</li>
<li>
<p>время аренды</p>
</li>
<li>
<p>время обновления аренды</p>
</li>
<li>
<p>маршрутизатор по умолчанию</p>
</li>
<li>
<p>и другие параметры</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Только после получения DHCP ACK клиент применяет выдаваемые сетевые параметры.</p>
</div>
<div class="paragraph">
<p>Если, по какой-то причине DHCP-сервер передумал выдавать клиенту  IP-адрес, то в ответ на DHCP REQUEST сервер отправит DHCP NACK. Например, DHCP-сервер в DHCP OFFER предложил один IP-адрес, а клиент в сообщении DHCP REQUEST запрашивает другой.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="tcp_ip/dhcp/images/dhcp_ack_1.png" alt="Взаимодействие DHCP-клиента и сервера" width="когда в сети два DHCP-сервера.">
</div>
<div class="title">Figure 186. Взаимодействие DHCP-клиента и сервера, когда в сети два DHCP-сервера.</div>
</div>
<div class="paragraph">
<p>Подведём итог взаимодействия DHCP-клиента с сервером:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>DHCP-клиент отправляет широковещательное сообщение DHCP DISCOVER для поиска DHCP-сервера.</p>
</li>
<li>
<p>Все DHCP-сервера в сети, которые получили сообщение DHCP DISCOVER, отвечают сообщением DHCP OFFER (конкретно клиенту или широковещательно, в зависимости от клиента). В этом сообщении они предлагают сетевые настройки (IP-адрес, маска подсети, маршрутизатор по умолчанию и т.д.). При этом предлагаемый IP-адрес резервируется на короткое время.</p>
</li>
<li>
<p>Получив несколько сообщений DHCP OFFER от серверов, DHCP-клиент выбирает один сервер (обычно это тот, от кого быстрей пришёл DHCP OFFER) и отправляет широковещательное сообщение DHCP REQUEST. В этом сообщении DHCP-клиент указывает, какой IP-адрес он хочет получить.</p>
</li>
<li>
<p>Все DHCP-сервера в сети получают DHCP REQUEST сообщение. Если идентификатор сервера не равен собственному, то DHCP-сервер освобождает от резерва предлагаемые IP-адрес. Если же идентификатор сервера равен собственному, то такой DHCP-сервер формирует сообщение DHCP ACK и помечает предлагаемый IP-адрес как выделенный.</p>
</li>
<li>
<p>Получив сообщение DHCP ACK, клиент применяет выданный IP-адрес и другие сетевые настройки.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_dhcp_release">DHCP RELEASE</h3>
<div class="paragraph">
<p>Сообщение DHCP RELEASE клиент отправляет серверу в случае, когда он больше не хочет занимать выделенный ему IP-адрес. Получив такое сообщение, DHCP-сервер возвращает IP-адрес в список свободных. Многие операционные системы отправляют сообщение DHCP RELEASE во время выключения или перезагрузки.</p>
</div>
<div class="paragraph">
<p>Подтверждение на сообщение DHCP RELEASE не требуется.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="tcp_ip/dhcp/images/dhcp_release_1.png" alt="Сообщение DHCP RELEASE.">
</div>
<div class="title">Figure 187. Сообщение DHCP RELEASE.</div>
</div>
<div class="paragraph">
<p>Вы и сами можете инициировать отправку сообщения DHCP RELEASE:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Если у вас ОС Windows, в командной строке от имени Администратора выполните команду <code><code>ipconfig /release</code></code></p>
</li>
<li>
<p>Если у вас MacOS, в терминале выполните команду <code><code>sudo ipconfig set en0 none</code></code></p>
</li>
<li>
<p>Если у вас ОС Linux, в терминале выполните команду <code><code>sudo ifdown eth0</code></code> (при условии, что ваш основной сетевой интерфейс eth0).</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_dhcp_обновление_адреса">DHCP (обновление адреса)</h3>
<div class="paragraph">
<p>Когда хост получает IP-адрес от DHCP-сервера, то вместе с этим, через опции, он получает время аренды (<strong>IP Address Lease Time</strong>) и время обновления аренды (<strong>Renewal Time Value</strong>). Время обновления аренды, как правило, равно половине времени аренды.</p>
</div>
<div class="paragraph">
<p>Если убрать время обновления аренды и оставить только время аренды, то когда оно закончится, DHCP-сервер будет считать, что IP свободен. А хост, который его арендовал, вынужден будет обнулить все выданные сетевые настройки, включая IP-адрес и маску.</p>
</div>
<div class="paragraph">
<p>Конечно, хост повторно может запросить сетевые настройки. Но в таком случае будет небольшое время, когда у хоста опять не будет сетевых настроек и он не сможет работать в сети. Представим, что вы сидите на важной видеоконференции, ведёте доклад как вдруг сеть пропала. Все ждут, пока ваш хост заново получит сетевые настройки.</p>
</div>
<div class="paragraph">
<p>Помимо простоя может случиться ситуация, когда в этот небольшой промежуток на DHCP-сервер придёт запрос от другого хоста, и ваш предыдущий IP-адрес будет выдан другому хосту. А вам в таком случае выдадут новый. Это может привести к некорректной работе некоторых сетевых приложений.</p>
</div>
<div class="paragraph">
<p>Чтобы избежать таких проблем, используют время обновления аренды. Например, пусть DHCP выдал IP-адрес на 48 часов. А время обновления аренды - 24 часа. Это означает, что после истечения первых 24 часов выданный IP всё ещё будет числиться за хостом, но нужно обновить аренду. У хоста будет почти 24 часа, чтобы обновить аренду и спокойно продолжить работать.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="tcp_ip/dhcp/images/dhcp_renew_1.png" alt="Схема обновления сетевых настроек в DHCP.">
</div>
<div class="title">Figure 188. Схема обновления сетевых настроек в DHCP.</div>
</div>
<div class="paragraph">
<p>Обновления сетевых настроек происходит путём повторной отправки сообщения DHCP REQUEST и получения на него DHCP ACK.</p>
</div>
<div class="paragraph">
<p>Попробуйте самостоятельно запустить процесс обновления сетевых настроек. Если у вас ОС Windows, в командной строке от имени Администратора выполните команду <code><code>ipconfig /renew</code></code>.</p>
</div>
<div class="paragraph">
<p>Если у вас MacOS:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Нажмите кнопку “Apple” и перейдите в “Системные настройки”.</p>
</li>
<li>
<p>Выберите “Сеть”</p>
</li>
<li>
<p>Нажмите на Wi-Fi или Ethernet (в зависимости от подключения) в меню слева и кликните “Дополнительно”.</p>
</li>
<li>
<p>В меню сверху выберите TCP/IP. Если выбрано получение IP-адреса “Используя DHCP”, вы сможете увидеть кнопку “Запросить адрес DHCP”, как на рисунке ниже.</p>
</li>
</ol>
</div>
<div class="imageblock">
<div class="content">
<img src="tcp_ip/dhcp/images/dhcp_renew_2.png" alt="Обновление сетевых настроек через DHCP в MacOS.">
</div>
<div class="title">Figure 189. Обновление сетевых настроек через DHCP в MacOS.</div>
</div>
</div>
<div class="sect2">
<h3 id="_dhcp_relay_ретранслятор">DHCP Relay (ретранслятор)</h3>
<div class="paragraph">
<p>В некоторых случаях DHCP-клиент и сервер могут находиться в разных сегментах сети. В такой ситуации DHCP-запросы клиента не смогут дойти до сервера, поскольку маршрутизаторы не передают широковещательные сообщения. Для решения этой проблемы используются DHCP Relay (ретранслятор).</p>
</div>
<div class="imageblock">
<div class="content">
<img src="tcp_ip/dhcp/images/dhcp_relay_1.png" alt="Схема сети" width="когда между DHCP-клиентом и сервером есть маршрутизатор.">
</div>
<div class="title">Figure 190. Схема сети, когда между DHCP-клиентом и сервером есть маршрутизатор.</div>
</div>
<div class="paragraph">
<p>Например, сеть вашей компании насчитывает несколько офисов. Для каждого офиса выделена своя IP сеть. Хосты находятся за маршрутизаторами и не имеют прямого доступа к DHCP-серверу.  Чтобы в каждом офисе не настраивать свой отдельный DHCP-сервер, можно настроить один общий на всех. А для доступа к DHCP-серверу на маршрутизаторах запустить DHCP Relay (ретранслятор).</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Когда хост подключается к сети, он отправляет широковещательное сообщение DHCP DISCOVER.</p>
</li>
<li>
<p>DHCP-ретранслятор получает это сообщение:</p>
<div class="olist loweralpha">
<ol class="loweralpha" type="a">
<li>
<p>добавляет в поле <strong>giaddr</strong> свой IP-адрес</p>
</li>
<li>
<p>увеличивает поле <strong>hops</strong></p>
</li>
<li>
<p>отправляет DHCP DISCOVER сообщение прямиком на DHCP-сервер. Он может это сделать, так как во время настройки DHCP-ретранслятора указывается IP-адрес DHCP-сервера, на который необходимо ретранслировать сообщения.</p>
</li>
</ol>
</div>
</li>
<li>
<p>DHCP-сервер, получив сообщение DHCP DISCOVER, использует поле <strong>giaddr</strong>, чтобы понять, из какой подсети пришёл запрос. Определив подсеть, DHCP-сервер зарезервирует необходимый IP-адрес и сформирует сообщение DHCP OFFER.</p>
</li>
<li>
<p>DHCP-сервер отправит DHCP OFFER прямо на DHCP-ретранслятор, используя поле <strong>giaddr</strong>.</p>
</li>
<li>
<p>DHCP-ретранслятор, получив DHCP OFFER от DHCP-сервера переправит его прямо клиенту.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>DHCP-ретранслятор будет работать подобным образом с сообщениями DHCP REQUEST и DHCP ACK.</p>
</div>
</div>
<div class="sect2">
<h3 id="_dhcp_это_улучшенный_bootp">DHCP - это улучшенный BOOTP</h3>
<div class="paragraph">
<p>В описании протокола и стандарта можно встретить название полей (bootp flags) или ссылки на BOOTP сообщения. Это всё потому, что DHCP является улучшением протокола BOOTP.</p>
</div>
<div class="paragraph">
<p>BOOTP (bootstrap protocol) - протокол прикладного уровня (7-й уровень модели ISO/OSI), используемый для автоматического получения клиентом IP-адреса и, если необходимо, ссылки на загрузочный образ. BOOTP был разработан для бездисковых компьютеров (тонкие клиенты). Его описание можно найти в <a href="https://datatracker.ietf.org/doc/html/rfc951">RFC 951</a>.</p>
</div>
<div class="paragraph">
<p>Для работы он использует UDP протокол и два порта: 67 (сервер) и 68 (клиент). С развитием сети, возможностей BOOTP стало не хватать и ему на смену пришёл DHCP.</p>
</div>
</div>
<div class="sect2">
<h3 id="_безопасность_в_dhcp">Безопасность в DHCP</h3>
<div class="paragraph">
<p>DHCP не использует никаких механизмов аутентификации или шифрования. Всё это, вместе с широковещательными запросами, приводит к проблемам с безопасностью. Не буду углубляться в эту тему тут, просто перечислю две наиболее популярные атаки:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>DHCP Starvation - сетевая атака, которая позволяет зарезервировать все выдаваемые IP-адреса или, другими словами, “истощить” DHCP-сервер. Как мы знаем, DHCP-сервер резервирует IP-адрес при получении DHCP DISCOVER запроса. Чтобы один и тот же IP-адрес выдавался одному клиенту, DHCP-сервер запоминает MAC-адрес клиента. Для проведения атаки в сеть отправляется множество DHCP DISCOVER запросов с поддельных MAC-адресов. Проведя такую атаку, новый клиент не сможет подключиться к сети, так как для него не будет свободных IP-адресов.</p>
</li>
<li>
<p>Rogue DHCP (он же  DHCP Spoofing) - запуск поддельного DHCP-сервера, который будет выдавать клиентам неверные сетевые настройки. Это могут быть просто нерабочие сетевые настройки или такие, чтобы весь трафик шёл не через маршрутизатор, а через специальный поддельный сервер (атака Man-in-the-Middle). Как известно, клиент принимает DHCP OFFER, который пришёл быстрей всего. Для атаки достаточно развернуть свой DHCP-сервер и стараться отправлять DHCP OFFER быстрей всех.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>Поэтому будьте внимательны, когда пользуетесь DHCP в публичных местах.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_arp_proxy">ARP proxy</h2>
<div class="sectionbody">
<div class="paragraph">
<p>ARP Proxy — техника использования ARP-протокола, позволяющая объединить две не связанные на канальном уровне сети в одну. Хосты, находящиеся в этих сетях, могут использовать адреса из одной IP-подсети и обмениваться трафиком между собой без использования маршрутизатора (как им кажется).</p>
</div>
<div class="imageblock">
<div class="content">
<img src="tcp_ip/arp/proxy/images/arp_proxy_1.png" alt="Схема использования ARP Proxy.">
</div>
<div class="title">Figure 191. Схема использования ARP Proxy.</div>
</div>
<div class="paragraph">
<p>Например, на рисунке изображены два хоста A и B, которые находятся на канальном уровне в разных сегментах. На хостах не настроен шлюз по умолчанию. И маски подсетей на маршрутизаторе (/24) и на хостах (/8) отличаются.</p>
</div>
<div class="paragraph">
<p>Если на маршрутизаторе включён Proxy ARP на обоих интерфейсах, то происходит следующее:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Хост A хочет отправить данные хосту B. Так как, на хосте A IP-адрес 10.0.1.2 с маской /8, то он считает, что хост B с IP-адресом 10.0.2.2 находится с ним в одной сети (хосты считают, что они в сети 10.0.0.0/8).</p>
</li>
<li>
<p>Хосту A необходимо узнать MAC-адрес хоста B. Он отправляет ARP-запрос в сеть.</p>
</li>
<li>
<p>Маршрутизатор получает ARP-запрос, но не перенаправляет его, так как получатель в другой сети. Если на маршрутизаторе включён ARP Proxy, то маршрутизатор отправляет хосту A ARP-ответ, в котором подставляет свой MAC-адрес. То есть, для хоста A создается соответствие, что у IP-адреса 10.0.2.2 MAC-адрес интерфейса маршрутизатора (10.0.1.1).</p>
</li>
<li>
<p>Теперь хост A может отправить данные.</p>
</li>
<li>
<p>Маршрутизатор получается пакет, смотрит на IP-адрес получателя и перенаправляет пакет на него. Маршрутизатор заглядывает в свой ARP кеш, не находит запись и отправляет ARP-запрос на поиск MAC адреса хоста 10.0.2.2.</p>
</li>
<li>
<p>Хост B с IP-адресом 10.0.2.2 получает ARP-запрос, сверяет искомый IP со своим. Так как IP-адреса равны, хост B отправляет ARP-ответ.</p>
</li>
<li>
<p>Маршрутизатор, получив ARP-ответ, может спокойно пересылать данные, которые получил от хоста A для хоста B.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>Хост B аналогичным образом считает, что хост A с ним в одной сети. Хосту B необходимо узнать MAC-адрес хоста A. Он отправляет ARP-запрос в сеть.</p>
</div>
<div class="paragraph">
<p>Маршрутизатор получает ARP-запрос, но не перенаправляет его, так как получатель в другой сети. Если на маршрутизаторе включён ARP-proxy, то маршрутизатор отправляет хосту B ARP-ответ, в котором подставляет свой MAC-адрес.</p>
</div>
<div class="paragraph">
<p>Таким образом, Proxy ARP помогает прозрачно объединить два физических сегмента в один.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_разновидности_nat">Разновидности NAT</h2>
<div class="sectionbody">
<div class="paragraph">
<p>NAT - это не простая подмена IP-адреса, от чего у NAT есть несколько разновидностей. При попытке разобраться в разновидностях NAT непременно встречаешься с их различной трактовкой и классификацией. Какой-то единой терминологии нет. Поэтому, когда идёт речь про NAT, вместо названий лучше уточнять детали его реализации.</p>
</div>
<div class="sect2">
<h3 id="_full_cone_nat_статический_nat">Full-cone NAT (статический NAT)</h3>
<div class="paragraph">
<p>Однозначная (взаимная) трансляция между парами “внутренний адрес: внутренний порт” и “публичный адрес: публичный порт”. Применяют для отображения одного внутреннего IP-адреса на один внешний IP-адрес (1 к 1). То есть, если во внутренней сети будет 10 хостов с различными IP-адресами, то для доступа в интернет им потребуется 10 внешних адресов.</p>
</div>
<div class="paragraph">
<p>Такой NAT особенно полезен, когда устройство должно быть доступным снаружи сети. Один внутренний IP-адрес и порт отображаются в один внешний IP-адрес и порт. Поэтому, если кто-то снаружи пришлёт пакет на внешний IP-адрес и порт, этот пакет будет проброшен на внутренний IP-адрес и порт.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="tcp_ip/nat/nat_types/images/full_cone_nat_1.png" alt="Full-cone NAT.">
</div>
<div class="title">Figure 192. Full-cone NAT.</div>
</div>
<div class="paragraph">
<p>Такой NAT используется чаще всего в корпоративных сетях, когда необходимо, чтобы какой-либо IP-адрес всегда был доступен из глобальной сети.</p>
</div>
<div class="paragraph">
<p>Например, когда вы покупаете сервер в облаке и внешний IP-адрес для доступа к нему. Сервер miminet.ru расположен по IP-адресу 51.250.2.96. А когда я подключаюсь к нему для выполнения работ по настройке и смотрю IP-адреса своих сетевых интерфейсов, то вижу IP-адрес 10.130.0.18, как на рисунке ниже.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="tcp_ip/nat/nat_types/images/full_cone_nat_2.png" alt="Пример использования Full-cone NAT.">
</div>
<div class="title">Figure 193. Пример использования Full-cone NAT.</div>
</div>
</div>
<div class="sect2">
<h3 id="_address_restricted_cone_nat">Address-restricted-cone NAT</h3>
<div class="paragraph">
<p>Работает как Full-cone NAT с ограничением по IP-адресу. Один внутренний IP и порт отображаются в один внешний IP-адрес и порт (как Full-cone NAT). Этот тип NAT отличается от Full-cone NAT тем, что во внутреннюю сеть может отправлять пакеты только тот хост, на чей IP-адрес был ранее отправлен пакет через NAT (в нашем случае это хост B).</p>
</div>
<div class="paragraph">
<p>Когда хост А отправит пакет на хост B, NAT добавит в специальную таблицу IP-адрес хоста B и отправит пакет на хост B.</p>
</div>
<div class="paragraph">
<p>Получив пакет на внешний интерфейс, NAT маршрутизатор попробует найти IP-адрес отправителя в своей таблице. Если такой IP-адрес будет в таблице (пакет от хоста B), то такой пакет можно отправить обратно хосту А. Обратите внимание, хост B в этом случае может отправлять пакеты с любого порта и на любой порт (имеется в виду TCP или UDP порт).</p>
</div>
<div class="paragraph">
<p>Хост C в этом случае не может обмениваться пакетами с хостом A.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="tcp_ip/nat/nat_types/images/add_restr_nat_1.png" alt="Address-restricted-cone NAT.">
</div>
<div class="title">Figure 194. Address-restricted-cone NAT.</div>
</div>
</div>
<div class="sect2">
<h3 id="_port_restricted_cone_nat">Port-Restricted-Cone NAT</h3>
<div class="paragraph">
<p>Port-Restricted-Cone NAT работает как Address-restricted-cone NAT, только добавляется ещё и ограничение на порт. Разница в том, что внешний хост может отправить пакеты только в ответ на полученные.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="tcp_ip/nat/nat_types/images/add_restr_nat_1.png" alt="Port-restricted-cone NAT.">
</div>
<div class="title">Figure 195. Port-restricted-cone NAT.</div>
</div>
<div class="paragraph">
<p>Когда хост А отправит пакет на хост B, NAT добавит в специальную таблицу IP-адрес хоста A и B, а также порт (TCP или UDP) источника и назначения. После этого NAT отправит пакет на хост B.</p>
</div>
<div class="paragraph">
<p>Получив пакет на внешний интерфейс, NAT маршрутизатор попробует найти IP-адрес и порт отправителя в своей таблице. Если такой IP-адрес и порт будут в таблице (пакет от хоста B с порта 80), то такой пакет можно отправить обратно хосту А на порт 8001. Обратите внимание, хост B в этом случае может отправлять пакеты только с номером порта 80 и только на порт 8001.</p>
</div>
</div>
<div class="sect2">
<h3 id="_port_address_translation_pat">Port Address Translation (PAT)</h3>
<div class="paragraph">
<p>Трансляция портов (PAT) или ещё иногда его называют Symmetric NAT - наиболее закрытый из всех типов NAT.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="tcp_ip/nat/nat_types/images/pat_1.png" alt="PAT.">
</div>
<div class="title">Figure 196. PAT.</div>
</div>
<div class="paragraph">
<p>Когда хост А отправляет пакет на хост B, то NAT не только меняет IP-адрес источника на свой, но ещё и подменят порт источника на свой. На рисунке выше, хост А отправил пакет, в котором IP-адрес источника хост A, порт источника 8001. Во время пересылки пакета PAT поменял IP-адрес источника на свой (NAT) и порт источника с 8001 на 31786.</p>
</div>
<div class="paragraph">
<p>В этом случае хост B может отправлять только ответные пакеты с порта 80 на IP-адрес NAT и порт 31786. Получив такой пакет NAT найдёт в своей таблице нужное соответствие, поменяет IP-адрес назначения на хост A и порт назначения на 8001 и отправит такой пакет хосту A.</p>
</div>
</div>
<div class="sect2">
<h3 id="_one_to_many">One-to-Many</h3>
<div class="paragraph">
<p>One-to-Many, он же Many-to-One, он же Source NAT (SNAT), он же NAPT (network address and port translation), IP masquerading и ещё его называют NAT overload - пожалуй, наиболее распространённый вид NAT. Так как он самый популярный, то под термином NAT часто подразумевают именно его.</p>
</div>
<div class="paragraph">
<p>One-to-Many - вид NAT, когда множество внутренних IP-адресов транслируются в один внешний. Например, у вас дома, все ваши домашние сетевые устройства (ПК, ноутбук, телефоны, телевизор, умная колонка и т.д.) имеют серые IP-адреса. Ваш домашний маршрутизатор транслирует все эти IP-адреса в один (который выдал провайдер).</p>
</div>
<div class="imageblock">
<div class="content">
<img src="tcp_ip/nat/nat_types/images/one_to_many_1.png" alt="One-to-Many NAT.">
</div>
<div class="title">Figure 197. One-to-Many NAT.</div>
</div>
<div class="paragraph">
<p>Раз несколько внутренних IP-адресов транслируются в один внешний, то может возникнуть путаница. Когда несколько хостов (например, хост A и B) из внутренней сети отправят пакет на один внешний IP-адрес (хост X). В ответ придёт два ответа (для хостов A и B). Как NAT определит, какой ответ для хоста A, а какой для хоста B? Чтобы избежать такой путаницы, NAT подменяет ещё и порт источника. Таким образом, даже если несколько устройств из внутренней сети отправят пакеты для одного внешнего IP-адреса и на один порт, NAT сможет точно определить, какой ответ для кого предназначается.</p>
</div>
<div class="paragraph">
<p>Такой вид NAT, как правило, работает у вас дома.</p>
</div>
</div>
<div class="sect2">
<h3 id="_nat_traversal">NAT traversal</h3>
<div class="paragraph">
<p>Говоря о NAT, стоит упомянуть о NAT traversal. NAT traversal - это техника для установки и поддержания соединения, когда между двумя хостами находиться NAT.</p>
</div>
<div class="paragraph">
<p>NAT traversal востребованная техника, особенно для организации пиринговой файлообменной сети (например, Bittorrent) или для VoIP.</p>
</div>
<div class="paragraph">
<p>На данный момент уже придумано много различных NAT traversal техник, их короткие описания вы можете найти в Wikipedia - <a href="https://en.wikipedia.org/wiki/NAT_traversal#Techniques" class="bare">https://en.wikipedia.org/wiki/NAT_traversal#Techniques</a></p>
</div>
<div class="paragraph">
<p>А для тех, кто хочет узнать немного больше, рекомендую статью Брайн Форда (Bryan Ford) <a href="https://bford.info/pub/net/p2pnat/">Peer-to-Peer Communication Across Network Address Translators</a>.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_pmtud_path_mtu_discovery">PMTUD (Path MTU Discovery)</h2>
<div class="sectionbody">
<div class="paragraph">
<p>PMTUD (Path MTU Discovery) - это метод для определения максимальной единицы передачи (MTU - maximum transmission unit) между двумя IP хостами. Обычно это делается, чтобы избежать фрагментации в IP.</p>
</div>
<div class="sect2">
<h3 id="_mtu_maximum_transmission_unit">MTU (maximum transmission unit)</h3>
<div class="paragraph">
<p>Рассмотрим пример. На рисунке ниже изображена простая сеть с двумя маршрутизаторами. Хост 1 отправляет ICMP эхо-запрос размером 1472 байта на сервер 1.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="tcp_ip/pmtud/images/mtu_1.png" alt="Отправка IP пакета максимального размера (1500 байт). (https://miminet.ru/web_network?guid=d59b4299-b0e4-4e6a-bf2c-78d52d8f2525)">
</div>
<div class="title">Figure 198. Отправка IP пакета максимального размера (1500 байт). (<a href="https://miminet.ru/web_network?guid=d59b4299-b0e4-4e6a-bf2c-78d52d8f2525" class="bare">https://miminet.ru/web_network?guid=d59b4299-b0e4-4e6a-bf2c-78d52d8f2525</a>).</div>
</div>
<div class="paragraph">
<p>Как известно, стандартный размер Ethernet пакета может передавать до 1500 байт данных. В примере выше отправляется ICMP эхо-запрос с 1472 байтами данных. Вот как мы получили эту цифру:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>20 байт - IP заголовок</p>
</li>
<li>
<p>8 байт - ICMP заголовок</p>
</li>
<li>
<p>1500 - 20 - 8 = 1472 байта данных</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>То есть, 1472 байта данных - это максимальный размер, который мы можем отправить в одном ICMP эхо-запросе через Etherhet. Если мы попробуем отправить 1473 байта данных, то такой IP пакет уже не поместится в Ethernet пакет и он будет разбит на два пакета.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
Вы можете скопировать приведённую сеть в примере и поменять размер передаваемых данных в ICMP эхо-запросе на 1473. Затем запустите эмуляцию и убедитесь, что теперь вместо одного IP пакета, хост 1 отправляет 2 пакета.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Чтобы протоколы сетевого уровня (например, IP) знали максимальное количество байт данных, которые можно отправить, используется параметр MTU (maximum transmission unit). Например, в MacOS этот параметр можно найти в настройках сети.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="tcp_ip/pmtud/images/mtu_2.png" alt="MTU в MacOS.">
</div>
<div class="title">Figure 199. MTU в MacOS.</div>
</div>
<div class="paragraph">
<p>Или можно в терминале набрать команду ifconfig и увидеть текущее значение MTU рядом с каждым интерфейсом.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="tcp_ip/pmtud/images/mtu_3.png" alt="Значения MTU у каждого интерфейса в MacOS.">
</div>
<div class="title">Figure 200. Значения MTU у каждого интерфейса в MacOS.</div>
</div>
<div class="paragraph">
<p>Если у вас Linux, то вы можете посмотреть текущие значения MTU командой ip a (или ifconfig). Ниже приведён пример вывода команды <code><code>ip a</code></code></p>
</div>
<div class="imageblock">
<div class="content">
<img src="tcp_ip/pmtud/images/mtu_4.png" alt="Значения MTU у каждого интерфейса в Linux.">
</div>
<div class="title">Figure 201. Значения MTU у каждого интерфейса в Linux.</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
Обратите внимание, что у Loopback интерфейсов (lo) MTU больше чем 1500. У MacOS значение MTU 16384, а у Linux 65536. Это потому, что loopback-интерфейс полностью программный и по умолчанию не отправляет данные в сеть. Вместо этого он обрабатывает их на этом же хосте.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Если мы отправим в сеть ICMP запрос данными превышающими 1472 байта данных, то такой IP пакет будет фрагментирован. Это нормальное поведение. А вот если мы попробуем отправить такой пакет и установим флаг в “Don’t fragment” в IP пакете, то мы получим сообщение об ошибке, что такой пакет нельзя отправить в сеть, так как он слишком большой и стоит запрет на его фрагментацию.</p>
</div>
<div class="paragraph">
<p>Например, на Linux хосте выполним команду <code><code>ping -s 1473 -M do 8.8.8.8</code></code>. Давайте разберём, что означает эта команда и параметры:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>ping</strong> - отправляет ICMP эхо-запрос на указанный IP-адрес (в нашем случае это 8.8.8.8).</p>
</li>
<li>
<p>параметр <strong>-s</strong> указывает на размер передаваемых данных в ICMP эхо-запросе. В нашем случае это 1473 байта. Это означает, что в один пакет мы не поместимся (1473 + 8 байт ICMP заголовок + 20 байт IP заголовок = 1501 байт). Значит нужно будет фрагментировать этот пакет.</p>
</li>
<li>
<p>параметр <strong>-M do</strong> указывает, что мы хотим установить бит Don’t fragment, который запрещает фрагментировать IP пакет.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>В результате получим сообщение, что сообщение слишком длинное (1501 байт), а MTU всего 1500.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="tcp_ip/pmtud/images/mtu_5.png" alt="Отправка большого ICMP эхо-запроса с запретом на фрагментацию.">
</div>
<div class="title">Figure 202. Отправка большого ICMP эхо-запроса с запретом на фрагментацию.</div>
</div>
<div class="paragraph">
<p>Если маршрутизатор получит IP пакет, который он не сможет дальше переслать из-за того, что он не пролазит в установленный MTU и в нём стоит флаг Don’t fragment, то в ответ мы получим ICMP сообщение с типом 3 (Destination unreachable) и кодом 4 (fragmentation needed and DF set) - нужна фрагментация, но стоит флаг DF.</p>
</div>
<div class="paragraph">
<p>На самом деле это не такая уж и редкая проблема. Давайте вернёмся к нашему примеру с двумя маршрутизаторами, где мы отправляли IP пакет максимального размера и у нас всё отлично работало. А теперь давайте все оставим как есть, только между маршрутизаторами 1 и 2 установим IPIP туннель. В этот туннель мы будем отправлять пакеты для хостов 1 и 2. Например, наш провайдер, по своим соображениям, решил поднять туннель между своими маршрутизаторами, и теперь наши пакеты попадают в этот туннель. Или это вы решили поднять туннель между удаленными офисами.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="tcp_ip/pmtud/images/mtu_6.png" alt="Отправка IP пакета максимального размера по пути с IPIP туннелем. (https://miminet.ru/web_network?guid=cd8c557b-52df-4a85-9fe4-3f570dd7527f)">
</div>
<div class="title">Figure 203. Отправка IP пакета максимального размера по пути с IPIP туннелем. (<a href="https://miminet.ru/web_network?guid=cd8c557b-52df-4a85-9fe4-3f570dd7527f" class="bare">https://miminet.ru/web_network?guid=cd8c557b-52df-4a85-9fe4-3f570dd7527f</a>)</div>
</div>
<div class="paragraph">
<p>И снова запустим на ping с размером передаваемых данных 1472. Видно, как вдруг всё поломалось. ICMP эхо-запрос больше не доходит до сервера. А в ответ мы получаем ICMP сообщение с кодом 3 и типом 4.</p>
</div>
<div class="paragraph">
<p>Это происходит по той причине, что мы пытаемся отправить пакет максимального размера в IPIP туннель. При попытке отправить его в IPIP туннель он увеличиться ещё на 20 байт (добавить новый IP заголовок). Как итог, его размер станет 1520 байт, а это больше чем MTU=1500.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="tcp_ip/pmtud/images/mtu_7.png" alt="IP пакет максимального размера попал в IPIP туннель.">
</div>
<div class="title">Figure 204. IP пакет максимального размера попал в IPIP туннель.</div>
</div>
<div class="paragraph">
<p>Т.е. если во время маршрутизации нашего пакета он перестанет пролазить в сеть и будет стоять флаг Don’t fragment. То он будет отброшен, а в ответ мы получим ICMP сообщение об этой ошибке (тип=3, код=4).</p>
</div>
<div class="paragraph">
<p>Конечно, эту проблему легко решить путём снятия бита DF (Don’t fragment), что разрешит маршрутизатору фрагментировать полученный IP пакет. Для этого добавим к команде ping параметр <code><code>-M dont</code></code>, как показано на рисунке ниже.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="tcp_ip/pmtud/images/mtu_8.png" alt="Отправка IP пакета максимального размера по пути с IPIP туннелем и снятым флагом DF. (https://miminet.ru/web_network?guid=8e498f62-6784-44bb-af39-70dfc42cea6c)">
</div>
<div class="title">Figure 205. Отправка IP пакета максимального размера по пути с IPIP туннелем и снятым флагом DF. (<a href="https://miminet.ru/web_network?guid=8e498f62-6784-44bb-af39-70dfc42cea6c" class="bare">https://miminet.ru/web_network?guid=8e498f62-6784-44bb-af39-70dfc42cea6c</a>)</div>
</div>
<div class="paragraph">
<p>В результате между маршрутизатором 1 и маршрутизатором 2 будет передан не один пакет, а два. На маршрутизаторе 2 произойдёт сборка двух пакетов в один и исходный пакет будет передан на сервер. При отправке ответа от сервера к хосту 1 произойдёт аналогичная ситуация, только собирать пакеты уже будет маршрутизатор 1.</p>
</div>
</div>
<div class="sect2">
<h3 id="_разные_mtu">Разные MTU</h3>
<div class="paragraph">
<p>Обычно MTU относят к сетевому уровню, указывая таким образом, какой максимальный размер данных можно упаковать в протокол канального уровня. Полностью его стоит называть L3 MTU или IP MTU. Но так как очень часто именно с ним идёт работа, то он превратился просто в MTU. Но, не только на сетевом уровне имеется MTU.</p>
</div>
<div class="paragraph">
<p>L2 MTU / Ethernet MTU / Hardware MTU - это MTU для технологии канального уровня. L2 MTU должен быть больше чем MTU. Вот передали мы 1500 байт данных на канальный уровень, их же ещё нужно упаковать в Ethernet. После добавления Ethernet заголовка размер фрейма вырос до 1518 байт.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="tcp_ip/pmtud/images/mtu_types_1.png" alt="L2 MTU.">
</div>
<div class="title">Figure 206. L2 MTU.</div>
</div>
<div class="paragraph">
<p>А ещё мы знаем, что в Ethernet заголовок может быть добавлен VLAN tag, что ещё увеличит размер фрейма. Часто L2 MTU устанавливается на все случаи жизни и равен он что-то около 1600. Этот параметр вы увидите нечасто, но если встретите, теперь будете знать, что он означает.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
Разные производители оборудования по-разному считают L2 MTU. Кто-то включает в расчёт Ethernet заголовок, кто включает дополнения как VLAN Tag, но при этом не включают Ethernet заголовок. Поэтому внимательно читайте документацию от производителя.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>TCP MSS - определяет максимальный размер данных, которые могут быть переданы в одном TCP пакете. Это ещё один параметр, с помощью которого можно влиять на максимальный размер передаваемого пакета.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="tcp_ip/pmtud/images/mtu_types_2.png" alt="TCP MSS" width="MTU и L2 MTU.">
</div>
<div class="title">Figure 207. TCP MSS, MTU и L2 MTU.</div>
</div>
<div class="paragraph">
<p>Например, если вы установите TCP MSS в 1400, то максимальный размер ваших IP пакетов станет 1440 байт (1400 байт данных + 20 байт TCP заголовок + 20 байт IP заголовок).</p>
</div>
</div>
<div class="sect2">
<h3 id="_проблема_фрагментации_ipv4">Проблема фрагментации IPv4</h3>
<div class="paragraph">
<p>На первый взгляд может показать, что проблемы с фрагментацией нет никакой. Просто давайте не ставить этот чёртов бит Don’t fragment в IP пакете и всё. В целом да, все так, если пренебрегать эффективностью и скоростью.</p>
</div>
<div class="sect3">
<h4 id="_эффективность_оборудования">Эффективность оборудования</h4>
<div class="paragraph">
<p>Когда речь идёт о вашем домашнем компьютере или ноутбуке, или даже телефоне, то без разницы, будет ваш хост фрагментировать пакеты или нет. Это не является проблемой. Но если говорим о маршрутизаторах и коммутационном оборудовании у провайдеров или компаний, то оказывается, что разница есть, и очень большая.</p>
</div>
<div class="paragraph">
<p>Оборудования у провайдеров и в центрах обработки данных (ЦОД) крупных компаний (Яндекс, Вконтакте, Mail.ru и т.д.) работают с трафиком не с 10-100 Мбит/сек, как ваш домашний маршрутизатор. Они работают с десятками и даже сотнями гигабит в секунду. Давайте сделаем грубый расчёт для канала всего в 1 гигабит/сек:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Скорость 1 Гбит/сек = 125 000 000 байт в секунду (1 000 000 000 / 8).</p>
</li>
<li>
<p>Если в канал со скоростью 125 000 000 байт в секунду отправлять Ethernet пакеты максимального размера (1518 байт = 1514 + 4 байта CRC32), то получится 82 345 пакета. Давайте округлим до 82 000.</p>
</li>
<li>
<p>Пусть у нас будет дуплексный канал. 82 000 пакетов мы отправляем и столько же получаем на вход. Итого, получим 164 000 пакетов в секунду. Вот с такой скоростью должен работать маршрутизатор.</p>
</li>
<li>
<p>И это расчёты всего для 1 Гбит/канала. А если у вас 5, 10, 100 Гбит/канал?! Можете сами прикинуть, насколько быстрым должен быть такой маршрутизатор.</p>
</li>
</ol>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
При грубом расчёте не учитывались: преамбула, SFD и межпакетный интервал.
</td>
</tr>
</table>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
Сетевое оборудование для построения крупных компьютерных сетей, как правило, достаточно дорогое. Оно должно не просто работать, а очень и очень быстро!
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Маршрутизатор хочет заниматься маршрутизацией, т.е. пересылкой пакета из одной сети в другую. И он хочет делать это как можно быстрей. Фрагментация пакета приведёт к двум проблемам:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Для фрагментации пакета нужно потратить немного процессорного времени и памяти. Это не сложно, если нужно фрагментировать немного. Но если вы проложили туннель и теперь вам нужно фрагментировать половину трафика (например, 82 000 пакетов в секунду), то это уже много.</p>
</li>
<li>
<p>Фрагментация пакета не так сложна, как его обратная сборка.</p>
<div class="olist loweralpha">
<ol class="loweralpha" type="a">
<li>
<p><strong>Память</strong>. При получении фрагмента маршрутизатор вынужден выделить сразу достаточно места в памяти, вплоть до 64 Кбайт (максимальный размер IP пакета), для размещения всего IP пакета. Нельзя сказать, какой размер оригинального IP пакета, пока маршрутизатор не получит пакет с флагом More fragmetns (MF) равным 0.</p>
</li>
<li>
<p><strong>Время сборки</strong>. При получении IP фрагмента маршрутизатор будет вынужден ждать остальные фрагменты и держать пакет в памяти. И все это время данные будут просто лежать в буфере маршрутизатора. Это негативно отразится на общей скорости передачи.</p>
</li>
<li>
<p><strong>Потеря фрагмента</strong>. Если какой-то IP фрагмент потеряется, тогда пакет будет лежать в буфере маршрутизатора длительное время, пока не сработает таймаут. В этом случае маршрутизатор отправит ICMP сообщение c типом 11 и кодом 1 - время сборки IP пакета истекло (fragment reassembly time exceeded).</p>
</li>
<li>
<p><strong>Процессор</strong>. Сборка фрагментов тоже не бесплатное занятие. Как и создание фрагментов, сборка потребует небольшого ресурса центрального процессора. И, как в случае с фрагментацией, собирать несколько пакетов несложно. Сложно собирать по несколько десятков тысяч пакетов в секунду.</p>
</li>
</ol>
</div>
</li>
</ol>
</div>
</div>
<div class="sect3">
<h4 id="_эффективность_канала">Эффективность канала</h4>
<div class="paragraph">
<p>Эффективность использования канала для передачи данных напрямую зависит от соотношения служебной информации к передаваемым данным. Каждый провайдер и администратор корпоративной сети стремится выжать максимум из своих каналов.</p>
</div>
<div class="paragraph">
<p>Рассмотрим пример с IPIP туннелем, в который мы отправим IP пакет максимального размера со снятым DF флагом.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="tcp_ip/pmtud/images/mtu_frag_1.png" alt="Отправка IP пакета максимального размера по пути с IPIP туннелем и снятым флагом DF. (https://miminet.ru/web_network?guid=8e498f62-6784-44bb-af39-70dfc42cea6c)">
</div>
<div class="title">Figure 208. Отправка IP пакета максимального размера по пути с IPIP туннелем и снятым флагом DF. (<a href="https://miminet.ru/web_network?guid=8e498f62-6784-44bb-af39-70dfc42cea6c" class="bare">https://miminet.ru/web_network?guid=8e498f62-6784-44bb-af39-70dfc42cea6c</a>)</div>
</div>
<div class="paragraph">
<p>Хост 1 отправил IP пакет максимально возможного размера:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>1472 байта данных + 8 байт ICMP заголовок + 20 байт IP заголовок) = 1500 байт данных.</p>
</li>
<li>
<p>добавим к этому Ethernet заголовок 14 байт + 4 байта CRC32</p>
</li>
<li>
<p>общий размер пакета 1518 байт, из которых 1472 байта данных.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>С позиции эффективности использования канала - это лучший пакет. Придя на маршрутизатор 1 этот пакет отправляется в IPIP туннель, и теперь он не влазит в канал, необходимо фрагментировать пакет. Не влезло всего 20 байт. Это значит, что маршрутизатор 1 отправит на маршрутизатор 2 два IP пакета. В одном будет 1452 байт данных, а во втором всего 20. Для второго пакета получается:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>20 байт данных + 20 байт IP заголовка</p>
</li>
<li>
<p>14 байт Ethernet заголовок + 4 байта CRC32</p>
</li>
<li>
<p>размер пакета 58 байт. Это меньше минимального размера Ethernet фрейма, поэтому этот пакет дополнится до 64 байт случайными данными.</p>
</li>
<li>
<p>итого 64 байта из которых всего треть (20 байт) данных.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Чем больше будет таких маленьких пакетов, тем меньше будет эффективность использования канала.</p>
</div>
<div class="paragraph">
<p>По этим причинам хосты обычно отправляют IP пакеты в сеть с установленным флагом DF (Don’t fragment).</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_pmtud">PMTUD</h3>
<div class="paragraph">
<p>Чтобы снизить проблему с фрагментацией IPv4 пакетов появилась техника, позволяющая узнать максимально допустимый MTU на всем пути следования пакета, и адаптировать свой MTU под максимально допустимый. Эта техника называется Path MTU Discovery (PMTUD) и она описана в <a href="https://datatracker.ietf.org/doc/html/rfc1191">RFC 1191</a>.</p>
</div>
<div class="paragraph">
<p>В основе работы PMTUD лежит ICMP сообщение с типом 4 и кодом 3 (Destination Unreachable: fragmentation needed and DF set):</p>
</div>
<div class="ulist">
<ul>
<li>
<p>при отправке пакетов хост запрещает фрагментировать IPv4 пакеты путем установки флага DF в 1.</p>
</li>
<li>
<p>если на пути следования пакета какой-то маршрутизатор не сможет отправить его дальше из-за MTU, то такой пакет будет отброшен, а сам маршрутизатор отправит ICMP сообщение “fragmentation needed and DF set”. В этом сообщении маршрутизатор сообщит свой MTU, чтобы хост смог адаптировать размер новых пакетов.</p>
</li>
<li>
<p>получив такое ICMP сообщение хост адаптирует свой MTU под новое значение.</p>
</li>
<li>
<p>вновь отправляемые пакеты успешно проходят MTU.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Таким образом, используя PMTUD хост может определить, что на пути следования пакета где-то есть маршрутизатор с меньшим MTU, чем у него, и адаптировать свой MTU.</p>
</div>
<div class="paragraph">
<p>На рисунке ниже показана схема сети с хостом, двумя маршрутизаторами и сервером. Между маршрутизаторами поднят IPIP туннель.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="tcp_ip/pmtud/images/mtu_frag_1.png" alt="Path MTU Discovery. (https://miminet.ru/web_network?guid=a98dd32f-c167-4c8d-b61c-1972dcd9feac)">
</div>
<div class="title">Figure 209. Path MTU Discovery. (<a href="https://miminet.ru/web_network?guid=a98dd32f-c167-4c8d-b61c-1972dcd9feac" class="bare">https://miminet.ru/web_network?guid=a98dd32f-c167-4c8d-b61c-1972dcd9feac</a>)</div>
</div>
<div class="paragraph">
<p>Хост 1 отправляет 1500 байт данных по TCP. 1500 байт в любом случае не влезут в один IP пакет, поэтому, будет отправлено два пакета с данными: один максимально большой, второй маленький.</p>
</div>
<div class="paragraph">
<p>Запустим эту сеть и посмотрим, что происходит:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>пропустим этап с отправкой ARP пакетов и установкой TCP соединения.</p>
</li>
<li>
<p>на 13-м шаге хост 1 отправляет сразу 4 пакета:</p>
<div class="ulist">
<ul>
<li>
<p>завершение установки TCP соединения (SYN, SYN+ACK, <strong>ACK</strong>)</p>
</li>
<li>
<p>большой пакет с данными</p>
</li>
<li>
<p>маленький пакет с оставшимися данными</p>
</li>
<li>
<p>пакет закрытия соединения (FIN+ACK)</p>
</li>
</ul>
</div>
</li>
<li>
<p>маршрутизатор 1 получает все 4 пакета и:</p>
<div class="ulist">
<ul>
<li>
<p>все пакеты, кроме большого пакета с данными он маршрутизирует дальше. Можно заметить, как 3-и IP пакета попали в туннель и отправились на маршрутизатор 2.</p>
</li>
<li>
<p>большой пакет с данными отбрасывается и генерируется ICMP сообщение “Destination Unreachable: fragmentation needed and DF set”.</p>
</li>
</ul>
</div>
</li>
<li>
<p>хост 1 получает ICMP сообщение и адаптирует свой MTU. Теперь он отправляет не 1 пакет с данными, а два.</p>
</li>
<li>
<p>маршрутизатор 1 получает эти два пакета и успешно отправляет их дальше.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Используя технику PMTUD хост может автоматически адаптировать свой MTU. Все современные ОС поддерживают и используют PMTUD. Ели вы запустите сниффер на своем компьютере, то сможете обнаружить, что у больших IP пакетов стоит флаг DF.</p>
</div>
</div>
<div class="sect2">
<h3 id="_черная_дыра_blackhole">Черная дыра (BlackHole)</h3>
<div class="paragraph">
<p>Одной из проблем работы PMTUD является некорректная настройка на маршрутизаторах и фаерволы.</p>
</div>
<div class="paragraph">
<p>Некоторые неопытные сетевые администраторы блокируют маршрутизацию и генерацию любых ICMP сообщений. Это приводит к тому, что хост не получает ICMP сообщения “Destination Unreachable: fragmentation needed and DF set”. При этом, его IP пакеты не доходят до получателя из-за проблем с MTU на одном из маршрутизаторов. Создается ощущение, что пакеты словно отправляются в черную дыру, от сюда и название этой проблемы.</p>
</div>
<div class="paragraph">
<p>Симптом такой проблемы обычно выглядит следующим образом:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>хост успешно устанавливает соединение до сервера, например, до веб-сервера</p>
</li>
<li>
<p>при попытке скачать страницу или файл с веб-сервера все зависает и никакие данные не передаются</p>
</li>
<li>
<p>новое соединение устанавливается, но данные не скачиваются или не отправляются.</p>
</li>
</ol>
</div>
</div>
<div class="sect2">
<h3 id="_tcp_mss">TCP MSS</h3>
<div class="paragraph">
<p><a href="https://www.rfc-editor.org/rfc/rfc2923">RFC 2923</a> (TCP Problems with Path MTU Discovery) описывает не только эту, но и другие проблемы, которые могут возникнуть при PMTUD. Помимо описания проблем данный документ предлагает и их решения.</p>
</div>
<div class="paragraph">
<p>Одно из решений для черной дыра является изменение MSS параметра у TCP. MSS (Maximum Segment Size) - определяет максимальный размер данных, которые TCP готов принять в одном IP пакете. Во время установки TCP соединения каждая сторона объявляет свой размер MSS. Например, если MSS будет равен 1400, это означает, что в один TCP пакет не будет содержать более 1400 байт данных.</p>
</div>
<div class="paragraph">
<p>Если TCP может успешно устанавливать соединение и отправлять небольшие порции данных, но обнаруживает потерю при отправке больших сегментов данных, то он начинает уменьшать MSS до тех пор, пока пакеты не перестанут теряться.</p>
</div>
</div>
</div>
</div>
</div>
<div id="footer">
<div id="footer-text">
Last updated 2024-10-02 10:56:26 +0300
</div>
</div>
<script>
;(function () { /*! Asciidoctor Tabs | Copyright (c) 2018-present Dan Allen | MIT License */
  'use strict'

  var config = (document.currentScript || {}).dataset || {}
  var forEach = Array.prototype.forEach

  init(document.querySelectorAll('.tabs'))

  function init (tabsBlocks) {
    if (!tabsBlocks.length) return
    forEach.call(tabsBlocks, function (tabs) {
      var syncIds = tabs.classList.contains('is-sync') ? {} : undefined
      var tablist = tabs.querySelector('.tablist ul')
      tablist.setAttribute('role', 'tablist')
      var start
      forEach.call(tablist.querySelectorAll('li'), function (tab, idx) {
        tab.tabIndex = -1
        tab.setAttribute('role', tab.classList.add('tab') || 'tab')
        var id, anchor, syncId
        if (!(id = tab.id) && (anchor = tab.querySelector('a[id]'))) {
          id = tab.id = anchor.parentNode.removeChild(anchor).id
        }
        var panel = id && tabs.querySelector('.tabpanel[aria-labelledby~="' + id + '"]')
        if (!panel) return idx ? undefined : toggleSelected(tab, true) // invalid state
        syncIds && (((syncId = tab.textContent.trim()) in syncIds) ? (syncId = undefined) : true) &&
        (syncIds[(tab.dataset.syncId = syncId)] = tab)
        idx || (syncIds && (start = { tab: tab, panel: panel })) ? toggleHidden(panel, true) : toggleSelected(tab, true)
        tab.setAttribute('aria-controls', panel.id)
        panel.setAttribute('role', 'tabpanel')
        var onClick = syncId === undefined ? activateTab : activateTabSync
        tab.addEventListener('click', onClick.bind({ tabs: tabs, tab: tab, panel: panel }))
      })
      if (!tabs.closest('.tabpanel')) {
        forEach.call(tabs.querySelectorAll('.tabpanel table.tableblock'), function (table) {
          var container = Object.assign(document.createElement('div'), { className: 'tablecontainer' })
          table.parentNode.insertBefore(container, table).appendChild(table)
        })
      }
      if (start) {
        var syncGroupId
        for (var i = 0, lst = tabs.classList, len = lst.length, className; i !== len; i++) {
          if (!(className = lst.item(i)).startsWith('data-sync-group-id=')) continue
          tabs.dataset.syncGroupId = syncGroupId = lst.remove(className) || className.slice(19).replace(/\u00a0/g, ' ')
          break
        }
        if (syncGroupId === undefined) tabs.dataset.syncGroupId = syncGroupId = Object.keys(syncIds).sort().join('|')
        var preferredSyncId = 'syncStorageKey' in config &&
          window[(config.syncStorageScope || 'local') + 'Storage'].getItem(config.syncStorageKey + '-' + syncGroupId)
        var tab = preferredSyncId && syncIds[preferredSyncId]
        tab && Object.assign(start, { tab: tab, panel: document.getElementById(tab.getAttribute('aria-controls')) })
        toggleSelected(start.tab, true) || toggleHidden(start.panel, false)
      }
    })
    onHashChange()
    toggleClassOnEach(tabsBlocks, 'is-loading', 'remove')
    window.setTimeout(toggleClassOnEach.bind(null, tabsBlocks, 'is-loaded', 'add'), 0)
    window.addEventListener('hashchange', onHashChange)
  }

  function activateTab (e) {
    var tab = this.tab
    var tabs = this.tabs || (this.tabs = tab.closest('.tabs'))
    var panel = this.panel || (this.panel = document.getElementById(tab.getAttribute('aria-controls')))
    querySelectorWithSiblings(tabs, '.tablist .tab', 'tab').forEach(function (el) {
      toggleSelected(el, el === tab)
    })
    querySelectorWithSiblings(tabs, '.tabpanel', 'tabpanel').forEach(function (el) {
      toggleHidden(el, el !== panel)
    })
    if (!this.isSync && 'syncStorageKey' in config && 'syncGroupId' in tabs.dataset) {
      var storageKey = config.syncStorageKey + '-' + tabs.dataset.syncGroupId
      window[(config.syncStorageScope || 'local') + 'Storage'].setItem(storageKey, tab.dataset.syncId)
    }
    if (!e) return
    var loc = window.location
    var hashIdx = loc.hash ? loc.href.indexOf('#') : -1
    if (~hashIdx) window.history.replaceState(null, '', loc.href.slice(0, hashIdx))
    e.preventDefault()
  }

  function activateTabSync (e) {
    activateTab.call(this, e)
    var thisTabs = this.tabs
    var thisTab = this.tab
    var initialY = thisTabs.getBoundingClientRect().y
    forEach.call(document.querySelectorAll('.tabs'), function (tabs) {
      if (tabs === thisTabs || tabs.dataset.syncGroupId !== thisTabs.dataset.syncGroupId) return
      querySelectorWithSiblings(tabs, '.tablist .tab', 'tab').forEach(function (tab) {
        if (tab.dataset.syncId === thisTab.dataset.syncId) activateTab.call({ tabs: tabs, tab: tab, isSync: true })
      })
    })
    var shiftedBy = thisTabs.getBoundingClientRect().y - initialY
    if (shiftedBy && (shiftedBy = Math.round(shiftedBy))) window.scrollBy({ top: shiftedBy, behavior: 'instant' })
  }

  function querySelectorWithSiblings (scope, selector, siblingClass) {
    var el = scope.querySelector(selector)
    if (!el) return []
    var result = [el]
    while ((el = el.nextElementSibling) && el.classList.contains(siblingClass)) result.push(el)
    return result
  }

  function toggleClassOnEach (elements, className, method) {
    forEach.call(elements, function (el) {
      el.classList[method](className)
    })
  }

  function toggleHidden (el, state) {
    el.classList[(el.hidden = state) ? 'add' : 'remove']('is-hidden')
  }

  function toggleSelected (el, state) {
    el.setAttribute('aria-selected', '' + state)
    el.classList[state ? 'add' : 'remove']('is-selected')
    el.tabIndex = state ? 0 : -1
  }

  function onHashChange () {
    var id = window.location.hash.slice(1)
    if (!id) return
    var tab = document.getElementById(~id.indexOf('%') ? decodeURIComponent(id) : id)
    if (!(tab && tab.classList.contains('tab'))) return
    'syncId' in tab.dataset ? activateTabSync.call({ tab: tab }) : activateTab.call({ tab: tab })
  }
})()
</script>
</body>
</html>