<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="generator" content="Asciidoctor 2.0.22">
<title>Программирование сокетов</title>
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:300,300italic,400,400italic,600,600italic%7CNoto+Serif:400,400italic,700,700italic%7CDroid+Sans+Mono:400,700">
<style>
/*! Asciidoctor default stylesheet | MIT License | https://asciidoctor.org */
/* Uncomment the following line when using as a custom stylesheet */
/* @import "https://fonts.googleapis.com/css?family=Open+Sans:300,300italic,400,400italic,600,600italic%7CNoto+Serif:400,400italic,700,700italic%7CDroid+Sans+Mono:400,700"; */
html{font-family:sans-serif;-webkit-text-size-adjust:100%}
a{background:none}
a:focus{outline:thin dotted}
a:active,a:hover{outline:0}
h1{font-size:2em;margin:.67em 0}
b,strong{font-weight:bold}
abbr{font-size:.9em}
abbr[title]{cursor:help;border-bottom:1px dotted #dddddf;text-decoration:none}
dfn{font-style:italic}
hr{height:0}
mark{background:#ff0;color:#000}
code,kbd,pre,samp{font-family:monospace;font-size:1em}
pre{white-space:pre-wrap}
q{quotes:"\201C" "\201D" "\2018" "\2019"}
small{font-size:80%}
sub,sup{font-size:75%;line-height:0;position:relative;vertical-align:baseline}
sup{top:-.5em}
sub{bottom:-.25em}
img{border:0}
svg:not(:root){overflow:hidden}
figure{margin:0}
audio,video{display:inline-block}
audio:not([controls]){display:none;height:0}
fieldset{border:1px solid silver;margin:0 2px;padding:.35em .625em .75em}
legend{border:0;padding:0}
button,input,select,textarea{font-family:inherit;font-size:100%;margin:0}
button,input{line-height:normal}
button,select{text-transform:none}
button,html input[type=button],input[type=reset],input[type=submit]{-webkit-appearance:button;cursor:pointer}
button[disabled],html input[disabled]{cursor:default}
input[type=checkbox],input[type=radio]{padding:0}
button::-moz-focus-inner,input::-moz-focus-inner{border:0;padding:0}
textarea{overflow:auto;vertical-align:top}
table{border-collapse:collapse;border-spacing:0}
*,::before,::after{box-sizing:border-box}
html,body{font-size:100%}
body{background:#fff;color:rgba(0,0,0,.8);padding:0;margin:0;font-family:"Noto Serif","DejaVu Serif",serif;line-height:1;position:relative;cursor:auto;-moz-tab-size:4;-o-tab-size:4;tab-size:4;word-wrap:anywhere;-moz-osx-font-smoothing:grayscale;-webkit-font-smoothing:antialiased}
a:hover{cursor:pointer}
img,object,embed{max-width:100%;height:auto}
object,embed{height:100%}
img{-ms-interpolation-mode:bicubic}
.left{float:left!important}
.right{float:right!important}
.text-left{text-align:left!important}
.text-right{text-align:right!important}
.text-center{text-align:center!important}
.text-justify{text-align:justify!important}
.hide{display:none}
img,object,svg{display:inline-block;vertical-align:middle}
textarea{height:auto;min-height:50px}
select{width:100%}
.subheader,.admonitionblock td.content>.title,.audioblock>.title,.exampleblock>.title,.imageblock>.title,.listingblock>.title,.literalblock>.title,.stemblock>.title,.openblock>.title,.paragraph>.title,.quoteblock>.title,table.tableblock>.title,.verseblock>.title,.videoblock>.title,.dlist>.title,.olist>.title,.ulist>.title,.qlist>.title,.hdlist>.title{line-height:1.45;color:#7a2518;font-weight:400;margin-top:0;margin-bottom:.25em}
div,dl,dt,dd,ul,ol,li,h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6,pre,form,p,blockquote,th,td{margin:0;padding:0}
a{color:#2156a5;text-decoration:underline;line-height:inherit}
a:hover,a:focus{color:#1d4b8f}
a img{border:0}
p{line-height:1.6;margin-bottom:1.25em;text-rendering:optimizeLegibility}
p aside{font-size:.875em;line-height:1.35;font-style:italic}
h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6{font-family:"Open Sans","DejaVu Sans",sans-serif;font-weight:300;font-style:normal;color:#ba3925;text-rendering:optimizeLegibility;margin-top:1em;margin-bottom:.5em;line-height:1.0125em}
h1 small,h2 small,h3 small,#toctitle small,.sidebarblock>.content>.title small,h4 small,h5 small,h6 small{font-size:60%;color:#e99b8f;line-height:0}
h1{font-size:2.125em}
h2{font-size:1.6875em}
h3,#toctitle,.sidebarblock>.content>.title{font-size:1.375em}
h4,h5{font-size:1.125em}
h6{font-size:1em}
hr{border:solid #dddddf;border-width:1px 0 0;clear:both;margin:1.25em 0 1.1875em}
em,i{font-style:italic;line-height:inherit}
strong,b{font-weight:bold;line-height:inherit}
small{font-size:60%;line-height:inherit}
code{font-family:"Droid Sans Mono","DejaVu Sans Mono",monospace;font-weight:400;color:rgba(0,0,0,.9)}
ul,ol,dl{line-height:1.6;margin-bottom:1.25em;list-style-position:outside;font-family:inherit}
ul,ol{margin-left:1.5em}
ul li ul,ul li ol{margin-left:1.25em;margin-bottom:0}
ul.circle{list-style-type:circle}
ul.disc{list-style-type:disc}
ul.square{list-style-type:square}
ul.circle ul:not([class]),ul.disc ul:not([class]),ul.square ul:not([class]){list-style:inherit}
ol li ul,ol li ol{margin-left:1.25em;margin-bottom:0}
dl dt{margin-bottom:.3125em;font-weight:bold}
dl dd{margin-bottom:1.25em}
blockquote{margin:0 0 1.25em;padding:.5625em 1.25em 0 1.1875em;border-left:1px solid #ddd}
blockquote,blockquote p{line-height:1.6;color:rgba(0,0,0,.85)}
@media screen and (min-width:768px){h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6{line-height:1.2}
h1{font-size:2.75em}
h2{font-size:2.3125em}
h3,#toctitle,.sidebarblock>.content>.title{font-size:1.6875em}
h4{font-size:1.4375em}}
table{background:#fff;margin-bottom:1.25em;border:1px solid #dedede;word-wrap:normal}
table thead,table tfoot{background:#f7f8f7}
table thead tr th,table thead tr td,table tfoot tr th,table tfoot tr td{padding:.5em .625em .625em;font-size:inherit;color:rgba(0,0,0,.8);text-align:left}
table tr th,table tr td{padding:.5625em .625em;font-size:inherit;color:rgba(0,0,0,.8)}
table tr.even,table tr.alt{background:#f8f8f7}
table thead tr th,table tfoot tr th,table tbody tr td,table tr td,table tfoot tr td{line-height:1.6}
h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6{line-height:1.2;word-spacing:-.05em}
h1 strong,h2 strong,h3 strong,#toctitle strong,.sidebarblock>.content>.title strong,h4 strong,h5 strong,h6 strong{font-weight:400}
.center{margin-left:auto;margin-right:auto}
.stretch{width:100%}
.clearfix::before,.clearfix::after,.float-group::before,.float-group::after{content:" ";display:table}
.clearfix::after,.float-group::after{clear:both}
:not(pre).nobreak{word-wrap:normal}
:not(pre).nowrap{white-space:nowrap}
:not(pre).pre-wrap{white-space:pre-wrap}
:not(pre):not([class^=L])>code{font-size:.9375em;font-style:normal!important;letter-spacing:0;padding:.1em .5ex;word-spacing:-.15em;background:#f7f7f8;border-radius:4px;line-height:1.45;text-rendering:optimizeSpeed}
pre{color:rgba(0,0,0,.9);font-family:"Droid Sans Mono","DejaVu Sans Mono",monospace;line-height:1.45;text-rendering:optimizeSpeed}
pre code,pre pre{color:inherit;font-size:inherit;line-height:inherit}
pre>code{display:block}
pre.nowrap,pre.nowrap pre{white-space:pre;word-wrap:normal}
em em{font-style:normal}
strong strong{font-weight:400}
.keyseq{color:rgba(51,51,51,.8)}
kbd{font-family:"Droid Sans Mono","DejaVu Sans Mono",monospace;display:inline-block;color:rgba(0,0,0,.8);font-size:.65em;line-height:1.45;background:#f7f7f7;border:1px solid #ccc;border-radius:3px;box-shadow:0 1px 0 rgba(0,0,0,.2),inset 0 0 0 .1em #fff;margin:0 .15em;padding:.2em .5em;vertical-align:middle;position:relative;top:-.1em;white-space:nowrap}
.keyseq kbd:first-child{margin-left:0}
.keyseq kbd:last-child{margin-right:0}
.menuseq,.menuref{color:#000}
.menuseq b:not(.caret),.menuref{font-weight:inherit}
.menuseq{word-spacing:-.02em}
.menuseq b.caret{font-size:1.25em;line-height:.8}
.menuseq i.caret{font-weight:bold;text-align:center;width:.45em}
b.button::before,b.button::after{position:relative;top:-1px;font-weight:400}
b.button::before{content:"[";padding:0 3px 0 2px}
b.button::after{content:"]";padding:0 2px 0 3px}
p a>code:hover{color:rgba(0,0,0,.9)}
#header,#content,#footnotes,#footer{width:100%;margin:0 auto;max-width:62.5em;*zoom:1;position:relative;padding-left:.9375em;padding-right:.9375em}
#header::before,#header::after,#content::before,#content::after,#footnotes::before,#footnotes::after,#footer::before,#footer::after{content:" ";display:table}
#header::after,#content::after,#footnotes::after,#footer::after{clear:both}
#content{margin-top:1.25em}
#content::before{content:none}
#header>h1:first-child{color:rgba(0,0,0,.85);margin-top:2.25rem;margin-bottom:0}
#header>h1:first-child+#toc{margin-top:8px;border-top:1px solid #dddddf}
#header>h1:only-child{border-bottom:1px solid #dddddf;padding-bottom:8px}
#header .details{border-bottom:1px solid #dddddf;line-height:1.45;padding-top:.25em;padding-bottom:.25em;padding-left:.25em;color:rgba(0,0,0,.6);display:flex;flex-flow:row wrap}
#header .details span:first-child{margin-left:-.125em}
#header .details span.email a{color:rgba(0,0,0,.85)}
#header .details br{display:none}
#header .details br+span::before{content:"\00a0\2013\00a0"}
#header .details br+span.author::before{content:"\00a0\22c5\00a0";color:rgba(0,0,0,.85)}
#header .details br+span#revremark::before{content:"\00a0|\00a0"}
#header #revnumber{text-transform:capitalize}
#header #revnumber::after{content:"\00a0"}
#content>h1:first-child:not([class]){color:rgba(0,0,0,.85);border-bottom:1px solid #dddddf;padding-bottom:8px;margin-top:0;padding-top:1rem;margin-bottom:1.25rem}
#toc{border-bottom:1px solid #e7e7e9;padding-bottom:.5em}
#toc>ul{margin-left:.125em}
#toc ul.sectlevel0>li>a{font-style:italic}
#toc ul.sectlevel0 ul.sectlevel1{margin:.5em 0}
#toc ul{font-family:"Open Sans","DejaVu Sans",sans-serif;list-style-type:none}
#toc li{line-height:1.3334;margin-top:.3334em}
#toc a{text-decoration:none}
#toc a:active{text-decoration:underline}
#toctitle{color:#7a2518;font-size:1.2em}
@media screen and (min-width:768px){#toctitle{font-size:1.375em}
body.toc2{padding-left:15em;padding-right:0}
body.toc2 #header>h1:nth-last-child(2){border-bottom:1px solid #dddddf;padding-bottom:8px}
#toc.toc2{margin-top:0!important;background:#f8f8f7;position:fixed;width:15em;left:0;top:0;border-right:1px solid #e7e7e9;border-top-width:0!important;border-bottom-width:0!important;z-index:1000;padding:1.25em 1em;height:100%;overflow:auto}
#toc.toc2 #toctitle{margin-top:0;margin-bottom:.8rem;font-size:1.2em}
#toc.toc2>ul{font-size:.9em;margin-bottom:0}
#toc.toc2 ul ul{margin-left:0;padding-left:1em}
#toc.toc2 ul.sectlevel0 ul.sectlevel1{padding-left:0;margin-top:.5em;margin-bottom:.5em}
body.toc2.toc-right{padding-left:0;padding-right:15em}
body.toc2.toc-right #toc.toc2{border-right-width:0;border-left:1px solid #e7e7e9;left:auto;right:0}}
@media screen and (min-width:1280px){body.toc2{padding-left:20em;padding-right:0}
#toc.toc2{width:20em}
#toc.toc2 #toctitle{font-size:1.375em}
#toc.toc2>ul{font-size:.95em}
#toc.toc2 ul ul{padding-left:1.25em}
body.toc2.toc-right{padding-left:0;padding-right:20em}}
#content #toc{border:1px solid #e0e0dc;margin-bottom:1.25em;padding:1.25em;background:#f8f8f7;border-radius:4px}
#content #toc>:first-child{margin-top:0}
#content #toc>:last-child{margin-bottom:0}
#footer{max-width:none;background:rgba(0,0,0,.8);padding:1.25em}
#footer-text{color:hsla(0,0%,100%,.8);line-height:1.44}
#content{margin-bottom:.625em}
.sect1{padding-bottom:.625em}
@media screen and (min-width:768px){#content{margin-bottom:1.25em}
.sect1{padding-bottom:1.25em}}
.sect1:last-child{padding-bottom:0}
.sect1+.sect1{border-top:1px solid #e7e7e9}
#content h1>a.anchor,h2>a.anchor,h3>a.anchor,#toctitle>a.anchor,.sidebarblock>.content>.title>a.anchor,h4>a.anchor,h5>a.anchor,h6>a.anchor{position:absolute;z-index:1001;width:1.5ex;margin-left:-1.5ex;display:block;text-decoration:none!important;visibility:hidden;text-align:center;font-weight:400}
#content h1>a.anchor::before,h2>a.anchor::before,h3>a.anchor::before,#toctitle>a.anchor::before,.sidebarblock>.content>.title>a.anchor::before,h4>a.anchor::before,h5>a.anchor::before,h6>a.anchor::before{content:"\00A7";font-size:.85em;display:block;padding-top:.1em}
#content h1:hover>a.anchor,#content h1>a.anchor:hover,h2:hover>a.anchor,h2>a.anchor:hover,h3:hover>a.anchor,#toctitle:hover>a.anchor,.sidebarblock>.content>.title:hover>a.anchor,h3>a.anchor:hover,#toctitle>a.anchor:hover,.sidebarblock>.content>.title>a.anchor:hover,h4:hover>a.anchor,h4>a.anchor:hover,h5:hover>a.anchor,h5>a.anchor:hover,h6:hover>a.anchor,h6>a.anchor:hover{visibility:visible}
#content h1>a.link,h2>a.link,h3>a.link,#toctitle>a.link,.sidebarblock>.content>.title>a.link,h4>a.link,h5>a.link,h6>a.link{color:#ba3925;text-decoration:none}
#content h1>a.link:hover,h2>a.link:hover,h3>a.link:hover,#toctitle>a.link:hover,.sidebarblock>.content>.title>a.link:hover,h4>a.link:hover,h5>a.link:hover,h6>a.link:hover{color:#a53221}
details,.audioblock,.imageblock,.literalblock,.listingblock,.stemblock,.videoblock{margin-bottom:1.25em}
details{margin-left:1.25rem}
details>summary{cursor:pointer;display:block;position:relative;line-height:1.6;margin-bottom:.625rem;outline:none;-webkit-tap-highlight-color:transparent}
details>summary::-webkit-details-marker{display:none}
details>summary::before{content:"";border:solid transparent;border-left:solid;border-width:.3em 0 .3em .5em;position:absolute;top:.5em;left:-1.25rem;transform:translateX(15%)}
details[open]>summary::before{border:solid transparent;border-top:solid;border-width:.5em .3em 0;transform:translateY(15%)}
details>summary::after{content:"";width:1.25rem;height:1em;position:absolute;top:.3em;left:-1.25rem}
.admonitionblock td.content>.title,.audioblock>.title,.exampleblock>.title,.imageblock>.title,.listingblock>.title,.literalblock>.title,.stemblock>.title,.openblock>.title,.paragraph>.title,.quoteblock>.title,table.tableblock>.title,.verseblock>.title,.videoblock>.title,.dlist>.title,.olist>.title,.ulist>.title,.qlist>.title,.hdlist>.title{text-rendering:optimizeLegibility;text-align:left;font-family:"Noto Serif","DejaVu Serif",serif;font-size:1rem;font-style:italic}
table.tableblock.fit-content>caption.title{white-space:nowrap;width:0}
.paragraph.lead>p,#preamble>.sectionbody>[class=paragraph]:first-of-type p{font-size:1.21875em;line-height:1.6;color:rgba(0,0,0,.85)}
.admonitionblock>table{border-collapse:separate;border:0;background:none;width:100%}
.admonitionblock>table td.icon{text-align:center;width:80px}
.admonitionblock>table td.icon img{max-width:none}
.admonitionblock>table td.icon .title{font-weight:bold;font-family:"Open Sans","DejaVu Sans",sans-serif;text-transform:uppercase}
.admonitionblock>table td.content{padding-left:1.125em;padding-right:1.25em;border-left:1px solid #dddddf;color:rgba(0,0,0,.6);word-wrap:anywhere}
.admonitionblock>table td.content>:last-child>:last-child{margin-bottom:0}
.exampleblock>.content{border:1px solid #e6e6e6;margin-bottom:1.25em;padding:1.25em;background:#fff;border-radius:4px}
.sidebarblock{border:1px solid #dbdbd6;margin-bottom:1.25em;padding:1.25em;background:#f3f3f2;border-radius:4px}
.sidebarblock>.content>.title{color:#7a2518;margin-top:0;text-align:center}
.exampleblock>.content>:first-child,.sidebarblock>.content>:first-child{margin-top:0}
.exampleblock>.content>:last-child,.exampleblock>.content>:last-child>:last-child,.exampleblock>.content .olist>ol>li:last-child>:last-child,.exampleblock>.content .ulist>ul>li:last-child>:last-child,.exampleblock>.content .qlist>ol>li:last-child>:last-child,.sidebarblock>.content>:last-child,.sidebarblock>.content>:last-child>:last-child,.sidebarblock>.content .olist>ol>li:last-child>:last-child,.sidebarblock>.content .ulist>ul>li:last-child>:last-child,.sidebarblock>.content .qlist>ol>li:last-child>:last-child{margin-bottom:0}
.literalblock pre,.listingblock>.content>pre{border-radius:4px;overflow-x:auto;padding:1em;font-size:.8125em}
@media screen and (min-width:768px){.literalblock pre,.listingblock>.content>pre{font-size:.90625em}}
@media screen and (min-width:1280px){.literalblock pre,.listingblock>.content>pre{font-size:1em}}
.literalblock pre,.listingblock>.content>pre:not(.highlight),.listingblock>.content>pre[class=highlight],.listingblock>.content>pre[class^="highlight "]{background:#f7f7f8}
.literalblock.output pre{color:#f7f7f8;background:rgba(0,0,0,.9)}
.listingblock>.content{position:relative}
.listingblock code[data-lang]::before{display:none;content:attr(data-lang);position:absolute;font-size:.75em;top:.425rem;right:.5rem;line-height:1;text-transform:uppercase;color:inherit;opacity:.5}
.listingblock:hover code[data-lang]::before{display:block}
.listingblock.terminal pre .command::before{content:attr(data-prompt);padding-right:.5em;color:inherit;opacity:.5}
.listingblock.terminal pre .command:not([data-prompt])::before{content:"$"}
.listingblock pre.highlightjs{padding:0}
.listingblock pre.highlightjs>code{padding:1em;border-radius:4px}
.listingblock pre.prettyprint{border-width:0}
.prettyprint{background:#f7f7f8}
pre.prettyprint .linenums{line-height:1.45;margin-left:2em}
pre.prettyprint li{background:none;list-style-type:inherit;padding-left:0}
pre.prettyprint li code[data-lang]::before{opacity:1}
pre.prettyprint li:not(:first-child) code[data-lang]::before{display:none}
table.linenotable{border-collapse:separate;border:0;margin-bottom:0;background:none}
table.linenotable td[class]{color:inherit;vertical-align:top;padding:0;line-height:inherit;white-space:normal}
table.linenotable td.code{padding-left:.75em}
table.linenotable td.linenos,pre.pygments .linenos{border-right:1px solid;opacity:.35;padding-right:.5em;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}
pre.pygments span.linenos{display:inline-block;margin-right:.75em}
.quoteblock{margin:0 1em 1.25em 1.5em;display:table}
.quoteblock:not(.excerpt)>.title{margin-left:-1.5em;margin-bottom:.75em}
.quoteblock blockquote,.quoteblock p{color:rgba(0,0,0,.85);font-size:1.15rem;line-height:1.75;word-spacing:.1em;letter-spacing:0;font-style:italic;text-align:justify}
.quoteblock blockquote{margin:0;padding:0;border:0}
.quoteblock blockquote::before{content:"\201c";float:left;font-size:2.75em;font-weight:bold;line-height:.6em;margin-left:-.6em;color:#7a2518;text-shadow:0 1px 2px rgba(0,0,0,.1)}
.quoteblock blockquote>.paragraph:last-child p{margin-bottom:0}
.quoteblock .attribution{margin-top:.75em;margin-right:.5ex;text-align:right}
.verseblock{margin:0 1em 1.25em}
.verseblock pre{font-family:"Open Sans","DejaVu Sans",sans-serif;font-size:1.15rem;color:rgba(0,0,0,.85);font-weight:300;text-rendering:optimizeLegibility}
.verseblock pre strong{font-weight:400}
.verseblock .attribution{margin-top:1.25rem;margin-left:.5ex}
.quoteblock .attribution,.verseblock .attribution{font-size:.9375em;line-height:1.45;font-style:italic}
.quoteblock .attribution br,.verseblock .attribution br{display:none}
.quoteblock .attribution cite,.verseblock .attribution cite{display:block;letter-spacing:-.025em;color:rgba(0,0,0,.6)}
.quoteblock.abstract blockquote::before,.quoteblock.excerpt blockquote::before,.quoteblock .quoteblock blockquote::before{display:none}
.quoteblock.abstract blockquote,.quoteblock.abstract p,.quoteblock.excerpt blockquote,.quoteblock.excerpt p,.quoteblock .quoteblock blockquote,.quoteblock .quoteblock p{line-height:1.6;word-spacing:0}
.quoteblock.abstract{margin:0 1em 1.25em;display:block}
.quoteblock.abstract>.title{margin:0 0 .375em;font-size:1.15em;text-align:center}
.quoteblock.excerpt>blockquote,.quoteblock .quoteblock{padding:0 0 .25em 1em;border-left:.25em solid #dddddf}
.quoteblock.excerpt,.quoteblock .quoteblock{margin-left:0}
.quoteblock.excerpt blockquote,.quoteblock.excerpt p,.quoteblock .quoteblock blockquote,.quoteblock .quoteblock p{color:inherit;font-size:1.0625rem}
.quoteblock.excerpt .attribution,.quoteblock .quoteblock .attribution{color:inherit;font-size:.85rem;text-align:left;margin-right:0}
p.tableblock:last-child{margin-bottom:0}
td.tableblock>.content{margin-bottom:1.25em;word-wrap:anywhere}
td.tableblock>.content>:last-child{margin-bottom:-1.25em}
table.tableblock,th.tableblock,td.tableblock{border:0 solid #dedede}
table.grid-all>*>tr>*{border-width:1px}
table.grid-cols>*>tr>*{border-width:0 1px}
table.grid-rows>*>tr>*{border-width:1px 0}
table.frame-all{border-width:1px}
table.frame-ends{border-width:1px 0}
table.frame-sides{border-width:0 1px}
table.frame-none>colgroup+*>:first-child>*,table.frame-sides>colgroup+*>:first-child>*{border-top-width:0}
table.frame-none>:last-child>:last-child>*,table.frame-sides>:last-child>:last-child>*{border-bottom-width:0}
table.frame-none>*>tr>:first-child,table.frame-ends>*>tr>:first-child{border-left-width:0}
table.frame-none>*>tr>:last-child,table.frame-ends>*>tr>:last-child{border-right-width:0}
table.stripes-all>*>tr,table.stripes-odd>*>tr:nth-of-type(odd),table.stripes-even>*>tr:nth-of-type(even),table.stripes-hover>*>tr:hover{background:#f8f8f7}
th.halign-left,td.halign-left{text-align:left}
th.halign-right,td.halign-right{text-align:right}
th.halign-center,td.halign-center{text-align:center}
th.valign-top,td.valign-top{vertical-align:top}
th.valign-bottom,td.valign-bottom{vertical-align:bottom}
th.valign-middle,td.valign-middle{vertical-align:middle}
table thead th,table tfoot th{font-weight:bold}
tbody tr th{background:#f7f8f7}
tbody tr th,tbody tr th p,tfoot tr th,tfoot tr th p{color:rgba(0,0,0,.8);font-weight:bold}
p.tableblock>code:only-child{background:none;padding:0}
p.tableblock{font-size:1em}
ol{margin-left:1.75em}
ul li ol{margin-left:1.5em}
dl dd{margin-left:1.125em}
dl dd:last-child,dl dd:last-child>:last-child{margin-bottom:0}
li p,ul dd,ol dd,.olist .olist,.ulist .ulist,.ulist .olist,.olist .ulist{margin-bottom:.625em}
ul.checklist,ul.none,ol.none,ul.no-bullet,ol.no-bullet,ol.unnumbered,ul.unstyled,ol.unstyled{list-style-type:none}
ul.no-bullet,ol.no-bullet,ol.unnumbered{margin-left:.625em}
ul.unstyled,ol.unstyled{margin-left:0}
li>p:empty:only-child::before{content:"";display:inline-block}
ul.checklist>li>p:first-child{margin-left:-1em}
ul.checklist>li>p:first-child>.fa-square-o:first-child,ul.checklist>li>p:first-child>.fa-check-square-o:first-child{width:1.25em;font-size:.8em;position:relative;bottom:.125em}
ul.checklist>li>p:first-child>input[type=checkbox]:first-child{margin-right:.25em}
ul.inline{display:flex;flex-flow:row wrap;list-style:none;margin:0 0 .625em -1.25em}
ul.inline>li{margin-left:1.25em}
.unstyled dl dt{font-weight:400;font-style:normal}
ol.arabic{list-style-type:decimal}
ol.decimal{list-style-type:decimal-leading-zero}
ol.loweralpha{list-style-type:lower-alpha}
ol.upperalpha{list-style-type:upper-alpha}
ol.lowerroman{list-style-type:lower-roman}
ol.upperroman{list-style-type:upper-roman}
ol.lowergreek{list-style-type:lower-greek}
.hdlist>table,.colist>table{border:0;background:none}
.hdlist>table>tbody>tr,.colist>table>tbody>tr{background:none}
td.hdlist1,td.hdlist2{vertical-align:top;padding:0 .625em}
td.hdlist1{font-weight:bold;padding-bottom:1.25em}
td.hdlist2{word-wrap:anywhere}
.literalblock+.colist,.listingblock+.colist{margin-top:-.5em}
.colist td:not([class]):first-child{padding:.4em .75em 0;line-height:1;vertical-align:top}
.colist td:not([class]):first-child img{max-width:none}
.colist td:not([class]):last-child{padding:.25em 0}
.thumb,.th{line-height:0;display:inline-block;border:4px solid #fff;box-shadow:0 0 0 1px #ddd}
.imageblock.left{margin:.25em .625em 1.25em 0}
.imageblock.right{margin:.25em 0 1.25em .625em}
.imageblock>.title{margin-bottom:0}
.imageblock.thumb,.imageblock.th{border-width:6px}
.imageblock.thumb>.title,.imageblock.th>.title{padding:0 .125em}
.image.left,.image.right{margin-top:.25em;margin-bottom:.25em;display:inline-block;line-height:0}
.image.left{margin-right:.625em}
.image.right{margin-left:.625em}
a.image{text-decoration:none;display:inline-block}
a.image object{pointer-events:none}
sup.footnote,sup.footnoteref{font-size:.875em;position:static;vertical-align:super}
sup.footnote a,sup.footnoteref a{text-decoration:none}
sup.footnote a:active,sup.footnoteref a:active,#footnotes .footnote a:first-of-type:active{text-decoration:underline}
#footnotes{padding-top:.75em;padding-bottom:.75em;margin-bottom:.625em}
#footnotes hr{width:20%;min-width:6.25em;margin:-.25em 0 .75em;border-width:1px 0 0}
#footnotes .footnote{padding:0 .375em 0 .225em;line-height:1.3334;font-size:.875em;margin-left:1.2em;margin-bottom:.2em}
#footnotes .footnote a:first-of-type{font-weight:bold;text-decoration:none;margin-left:-1.05em}
#footnotes .footnote:last-of-type{margin-bottom:0}
#content #footnotes{margin-top:-.625em;margin-bottom:0;padding:.75em 0}
div.unbreakable{page-break-inside:avoid}
.big{font-size:larger}
.small{font-size:smaller}
.underline{text-decoration:underline}
.overline{text-decoration:overline}
.line-through{text-decoration:line-through}
.aqua{color:#00bfbf}
.aqua-background{background:#00fafa}
.black{color:#000}
.black-background{background:#000}
.blue{color:#0000bf}
.blue-background{background:#0000fa}
.fuchsia{color:#bf00bf}
.fuchsia-background{background:#fa00fa}
.gray{color:#606060}
.gray-background{background:#7d7d7d}
.green{color:#006000}
.green-background{background:#007d00}
.lime{color:#00bf00}
.lime-background{background:#00fa00}
.maroon{color:#600000}
.maroon-background{background:#7d0000}
.navy{color:#000060}
.navy-background{background:#00007d}
.olive{color:#606000}
.olive-background{background:#7d7d00}
.purple{color:#600060}
.purple-background{background:#7d007d}
.red{color:#bf0000}
.red-background{background:#fa0000}
.silver{color:#909090}
.silver-background{background:#bcbcbc}
.teal{color:#006060}
.teal-background{background:#007d7d}
.white{color:#bfbfbf}
.white-background{background:#fafafa}
.yellow{color:#bfbf00}
.yellow-background{background:#fafa00}
span.icon>.fa{cursor:default}
a span.icon>.fa{cursor:inherit}
.admonitionblock td.icon [class^="fa icon-"]{font-size:2.5em;text-shadow:1px 1px 2px rgba(0,0,0,.5);cursor:default}
.admonitionblock td.icon .icon-note::before{content:"\f05a";color:#19407c}
.admonitionblock td.icon .icon-tip::before{content:"\f0eb";text-shadow:1px 1px 2px rgba(155,155,0,.8);color:#111}
.admonitionblock td.icon .icon-warning::before{content:"\f071";color:#bf6900}
.admonitionblock td.icon .icon-caution::before{content:"\f06d";color:#bf3400}
.admonitionblock td.icon .icon-important::before{content:"\f06a";color:#bf0000}
.conum[data-value]{display:inline-block;color:#fff!important;background:rgba(0,0,0,.8);border-radius:50%;text-align:center;font-size:.75em;width:1.67em;height:1.67em;line-height:1.67em;font-family:"Open Sans","DejaVu Sans",sans-serif;font-style:normal;font-weight:bold}
.conum[data-value] *{color:#fff!important}
.conum[data-value]+b{display:none}
.conum[data-value]::after{content:attr(data-value)}
pre .conum[data-value]{position:relative;top:-.125em}
b.conum *{color:inherit!important}
.conum:not([data-value]):empty{display:none}
dt,th.tableblock,td.content,div.footnote{text-rendering:optimizeLegibility}
h1,h2,p,td.content,span.alt,summary{letter-spacing:-.01em}
p strong,td.content strong,div.footnote strong{letter-spacing:-.005em}
p,blockquote,dt,td.content,td.hdlist1,span.alt,summary{font-size:1.0625rem}
p{margin-bottom:1.25rem}
.sidebarblock p,.sidebarblock dt,.sidebarblock td.content,p.tableblock{font-size:1em}
.exampleblock>.content{background:#fffef7;border-color:#e0e0dc;box-shadow:0 1px 4px #e0e0dc}
.print-only{display:none!important}
@page{margin:1.25cm .75cm}
@media print{*{box-shadow:none!important;text-shadow:none!important}
html{font-size:80%}
a{color:inherit!important;text-decoration:underline!important}
a.bare,a[href^="#"],a[href^="mailto:"]{text-decoration:none!important}
a[href^="http:"]:not(.bare)::after,a[href^="https:"]:not(.bare)::after{content:"(" attr(href) ")";display:inline-block;font-size:.875em;padding-left:.25em}
abbr[title]{border-bottom:1px dotted}
abbr[title]::after{content:" (" attr(title) ")"}
pre,blockquote,tr,img,object,svg{page-break-inside:avoid}
thead{display:table-header-group}
svg{max-width:100%}
p,blockquote,dt,td.content{font-size:1em;orphans:3;widows:3}
h2,h3,#toctitle,.sidebarblock>.content>.title{page-break-after:avoid}
#header,#content,#footnotes,#footer{max-width:none}
#toc,.sidebarblock,.exampleblock>.content{background:none!important}
#toc{border-bottom:1px solid #dddddf!important;padding-bottom:0!important}
body.book #header{text-align:center}
body.book #header>h1:first-child{border:0!important;margin:2.5em 0 1em}
body.book #header .details{border:0!important;display:block;padding:0!important}
body.book #header .details span:first-child{margin-left:0!important}
body.book #header .details br{display:block}
body.book #header .details br+span::before{content:none!important}
body.book #toc{border:0!important;text-align:left!important;padding:0!important;margin:0!important}
body.book #toc,body.book #preamble,body.book h1.sect0,body.book .sect1>h2{page-break-before:always}
.listingblock code[data-lang]::before{display:block}
#footer{padding:0 .9375em}
.hide-on-print{display:none!important}
.print-only{display:block!important}
.hide-for-print{display:none!important}
.show-for-print{display:inherit!important}}
@media amzn-kf8,print{#header>h1:first-child{margin-top:1.25rem}
.sect1{padding:0!important}
.sect1+.sect1{border:0}
#footer{background:none}
#footer-text{color:rgba(0,0,0,.6);font-size:.9em}}
@media amzn-kf8{#header,#content,#footnotes,#footer{padding:0}}
</style>
<style>
/*! Asciidoctor Tabs | Copyright (c) 2018-present Dan Allen | MIT License */
.tabs {
    margin-bottom: 1.25em;
}

.tablist > ul {
    display: flex;
    flex-wrap: wrap;
    list-style: none;
    margin: 0;
    padding: 0;
}

.tablist > ul li {
    align-items: center;
    background-color: #fff;
    cursor: pointer;
    display: flex;
    font-weight: bold;
    line-height: 1.5;
    padding: 0.25em 1em;
    position: relative;
}

.tablist > ul li:focus-visible {
    outline: none;
}

.tablist.ulist,
.tablist.ulist > ul li {
    margin: 0;
}

.tablist.ulist > ul li + li {
    margin-left: 0.25em;
}

.tabs .tablist li::after {
    content: "";
    display: block;
    height: 1px;
    position: absolute;
    bottom: -1px;
    left: 0;
    right: 0;
}

.tabs.is-loading .tablist li:not(:first-child),
.tabs:not(.is-loading) .tablist li:not(.is-selected) {
    background-color: #f5f5f5;
}

.tabs.is-loading .tablist li:first-child::after,
.tabs:not(.is-loading) .tablist li.is-selected::after {
    background-color: #fff;
}

/*
.tabs:not(.is-loading) .tablist li,
.tabs:not(.is-loading) .tablist li::after {
  transition: background-color 200ms ease-in-out;
}
*/

.tablist > ul p {
    line-height: inherit;
    margin: 0;
}

.tabpanel {
    background-color: #fff;
    padding: 1.25em;
}

.tablist > ul li,
.tabpanel {
    border: 1px solid #dcdcdc;
}

.tablist > ul li {
    border-bottom: 0;
}

.tabs.is-loading .tabpanel + .tabpanel,
.tabs:not(.is-loading) .tabpanel.is-hidden {
    display: none;
}

.tabpanel > :first-child {
    margin-top: 0;
}

/* #content is a signature of the Asciidoctor standalone HTML output */
#content .tabpanel > :last-child,
#content .tabpanel > :last-child > :last-child,
#content .tabpanel > :last-child > :last-child > li:last-child > :last-child {
    margin-bottom: 0;
}

.tablecontainer {
    overflow-x: auto;
}

#content .tablecontainer {
    margin-bottom: 1.25em;
}

#content .tablecontainer > table.tableblock {
    margin-bottom: 0;
}
</style>
</head>
<body class="article">
<div id="header">
<h1>Программирование сокетов</h1>
</div>
<div id="content">
<div class="sect1">
<h2 id="_сокеты">Сокеты</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Для работы с сетью на низком уровне используются сокеты (socket). Сокет - это название программного интерфейса (API) для обеспечения обмена данными между процессами. Процессы при этом могут исполняться как на одном хосте, так и на различных.</p>
</div>
<div class="paragraph">
<p>Хорошей аналогией сокета является файловый дескриптор - некоторая абстракция, для работы с файлами в ОС. Вы можете открыть или закрыть файловый дескриптор, можете прочитать или записать туда данные и т.д.</p>
</div>
<div class="paragraph">
<p>Использование сокета у клиента немного отличается от сервера. Во время разработки сервера вы увидите эту разницу.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
Подробности по использованию сокетов в Python можно найти <a href="https://docs.python.org/3.8/library/socket.html">в официальной документации</a>.
</td>
</tr>
</table>
</div>
<div class="sect2">
<h3 id="_tcp_клиент">TCP-клиент</h3>
<div class="paragraph">
<p>Давайте напишем первого сетевого клиента, который будет подключаться к серверу miminet.ru на порт 80 (TCP), отправлять HTTP-запрос, получать HTTP-ответ и печатать содержимое ответа в консоль. Схема работы показана на рисунке ниже.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="programming/python/socket/socket-client/socket-tcp/images/http-schema.png" alt="Схема работы TCP-клиента.">
</div>
<div class="title">Figure 1. Схема работы TCP-клиента.</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
HTTP (HyperText Transfer Protocol) - протокол для коммуникации с веб-сервером. HTTP-запрос - запрос отправляемый клиентом на веб-сервер. В ответ на такой запрос веб-сервер отправляет данные (HTML страницу, JS код, картинки, видео и т.д.) или отправляет информационное сообщение.
</td>
</tr>
</table>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
По умолчанию, веб-сервер для работы использует порт 80 (TCP).
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Нам необходимо выполнить следующие действия:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Создать TCP сокет.</p>
</li>
<li>
<p>Подключиться к веб-серверу miminet.ru на порт 80.</p>
</li>
<li>
<p>Отправить HTTP-запрос.</p>
</li>
<li>
<p>Получить ответ и вывести его на экран.</p>
</li>
</ol>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="python"><span style="color:#777">#!/usr/bin/python</span>

<span style="color:#080;font-weight:bold">import</span> <span style="color:#B44;font-weight:bold">socket</span>

HOST = <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">miminet.ru</span><span style="color:#710">&quot;</span></span>
PORT = <span style="color:#00D">80</span>                                               <span style="color:#777"># HTTP port</span>

ip_addr = socket.gethostbyname(HOST)                    <span style="color:#777"># Get IP address by name</span>
s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)   <span style="color:#777"># Create TCP socket</span>
s.connect((ip_addr, PORT))                              <span style="color:#777"># Connect to miminet.ru</span>
s.send(<span style="color:#549"><span>b</span><span style="color:#325">'</span><span>GET / HTTP/1.0</span><span style="color:#325">\n</span><span style="color:#325">\n</span><span style="color:#325">'</span></span>)                           <span style="color:#777"># Send HTTP-request</span>
data = s.recv(<span style="color:#00D">4096</span>)                                     <span style="color:#777"># Recieve data from miminet.ru</span>
print(data)                                             <span style="color:#777"># Print data to console</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Вы можете скопировать этот код и попробовать выполнить его у себя. В результате его работы в консоль должно вывестись следующее сообщение:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code>(venv) ScrumBook:src ilya2$ python tcp-client-1.py
b'HTTP/1.1 301 Moved Permanently\r\nServer: nginx/1.25.4\r\nDate: Wed, 16 Oct 2024 08:40:37 GMT\r\nContent-Type: text/html\r\nContent-Length: 169\r\nConnection: close\r\nLocation: https://miminet.ru/\r\n\r\n&lt;html&gt;\r\n&lt;head&gt;&lt;title&gt;301 Moved Permanently&lt;/title&gt;&lt;/head&gt;\r\n&lt;body&gt;\r\n&lt;center&gt;&lt;h1&gt;301 Moved Permanently&lt;/h1&gt;&lt;/center&gt;\r\n&lt;hr&gt;&lt;center&gt;nginx/1.25.4&lt;/center&gt;\r\n&lt;/body&gt;\r\n&lt;/html&gt;\r\n'</code></pre>
</div>
</div>
<div class="paragraph">
<p>Я постарался прокомментировать каждую строку, но давайте подробней  разберем, что мы делаем и что происходит</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="python"><span style="color:#080;font-weight:bold">import</span> <span style="color:#B44;font-weight:bold">socket</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Импортируем модуль socket. Как раз он нам позволит работать с сокетами.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="python">ip_addr = socket.gethostbyname(HOST)</code></pre>
</div>
</div>
<div class="paragraph">
<p>Для создания TCP соединения необходимо знать IP-адрес хоста и порт, на который мы хотим подключиться. Пока мы знаем только имя хоста miminet.ru и порт 80. Функция gethostbyname позволяет по имени определить IP-адрес хоста. Т.е. по имени miminet.ru она вернет IP-адрес хоста. Сохраним его в переменную ip_addr.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="python">s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</code></pre>
</div>
</div>
<div class="paragraph">
<p>Данный код создает TCP сокет и сохраняет его в переменную <code>s</code>. Функция <code>socket</code> позволяет создавать не только TCP или UDP сокеты. Она принимает два обязательных параметра:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>socket.AF_INET - когда мы хотим открыть сокет из семейства протоколов TCP/IP</p>
</li>
<li>
<p>socket.SOCK_STREAM - для создания TCP-сокета.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>И так, сокет создан, IP-адрес и порт известны, можем подключаться.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="python">s.connect((ip_addr, PORT))</code></pre>
</div>
</div>
<div class="paragraph">
<p>Функция <code>connect</code> устанавливает TCP соединения (3-х разовое рукопожатие SYN, SYN+ACK, ACK) на заданный IP-адрес и порт. Обратите внимание, что функция <code>connect</code> принимает только один порт - это порт назначения. Т.е. порт, на который мы устанавливаем соединение. У клиентов (тот кто инициирует установку соединения) порт источника выбирается случайным образом.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="python">s.send(<span style="color:#549"><span>b</span><span style="color:#325">'</span><span>GET / HTTP/1.0</span><span style="color:#325">\n</span><span style="color:#325">\n</span><span style="color:#325">'</span></span>)</code></pre>
</div>
</div>
<div class="paragraph">
<p>Функция <code>send</code> отправляет данные в установленное TCP соединение. В данном случае мы отправили HTTP-запрос на веб-сервер miminet.ru. HTTP - это текстовый протокол, поэтому, запрос можно написать прямым текстом. Два подряд идущие перевода строки <code>\n\n</code> означают окончание HTTP-запроса. В этом HTTP-запросе мы хотим получить главную страницу miminet.ru.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="python">data = s.recv(<span style="color:#00D">4096</span>)</code></pre>
</div>
</div>
<div class="paragraph">
<p>Получаем данные из сокета. Функция <code>recv</code> по умолчанию работает в блокирующем режиме. Это означает, что вызвав эту функцию программа будет ожидать, пока не придут данные. Так как заранее не известно, сколько данных придет, указал 4096 байт. Если данных придет меньше, вернут их, если придет больше, вернут не более 4096 байт. Полученные данные сохраняем в переменную <code>data</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="python">print(data)</code></pre>
</div>
</div>
<div class="paragraph">
<p>Печатаем полученные данные в консоль.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
На самом деле можно опустить вызов функции <code>gethostbyname</code>, так как функция <code>connect</code> может самостоятельно по имени определить IP адрес. Я решил оставить <code>gethostbyname</code> для наглядности.
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="_обработка_ошибок">Обработка ошибок</h3>
<div class="paragraph">
<p>Код из примера выше годится только для примера. Не трудно заметить, что там нет обработки ошибок. Давайте добавим обработку ошибок и посмотрим, что может пойти не так.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="python"><span style="color:#777">#!/usr/bin/python</span>

<span style="color:#080;font-weight:bold">import</span> <span style="color:#B44;font-weight:bold">socket</span>

HOST = <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">miminet.ru</span><span style="color:#710">&quot;</span></span>
PORT = <span style="color:#00D">80</span>

s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)

<span style="color:#080;font-weight:bold">try</span>:
    s.connect((HOST, PORT))
    s.send(<span style="color:#549"><span>b</span><span style="color:#325">'</span><span>GET / HTTP/1.0</span><span style="color:#325">\n</span><span style="color:#325">\n</span><span style="color:#325">'</span></span>)
    data = s.recv(<span style="color:#00D">4096</span>)
    print(data)
<span style="color:#080;font-weight:bold">except</span> <span style="color:#C00;font-weight:bold">Exception</span> <span style="color:#080;font-weight:bold">as</span> e:
    <span style="color:#080;font-weight:bold">print</span> (<span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">Socket error: </span><span style="color:#710">&quot;</span></span> + <span style="color:#369;font-weight:bold">str</span>(e))</code></pre>
</div>
</div>
<div class="sect3">
<h4 id="_ошибка_преобразования_имени_в_ip_адрес">Ошибка преобразования имени в IP адрес</h4>
<div class="paragraph">
<p>Попробуем вместо имени хоста miminet.ru подставить несуществующее имя, например, miminet.rus.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="python">HOST = <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">miminet.rus</span><span style="color:#710">&quot;</span></span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Для этого изменим имя хоста в переменной HOST и запустим наш код. В результате мы получим ошибку:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="console">(venv) ScrumBook:src ilya2$ python tcp-client-2-hostname.py
Socket error: [Errno 8] nodename nor servname provided, or not known</code></pre>
</div>
</div>
<div class="paragraph">
<p>Она означает, что нам не удалось по имени хоста определить IP-адрес. Дальнейшая установка соединения бессмысленно, так как мы не знаем IP-адрес хоста.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
Для воспроизведения следующих ошибок верните имя в переменной HOST обратно на miminet.ru
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="_ошибка_подключения">Ошибка подключения</h4>
<div class="paragraph">
<p>Для воспроизведения ошибки подключения поменяем переменную PORT c 80 на 81 (можно и 81 и многие другие порты, которые закрыты). Запустим наш код и увидим ошибку подключения:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="console">(venv) ScrumBook:src ilya2$ python tcp-client-2-port81.py
Socket error: [Errno 61] Connection refused</code></pre>
</div>
</div>
<div class="paragraph">
<p>Данная ошибка сообщает, что на удаленной стороне нет программы, которая готова работать на указанном порту. В моем случае - это порт 81. Нет смысла продолжать выполнять программу и пытаться отправить данные. Ошибка появляется, когда во время установки TCP соединения клиент получает пакет с флагом RST. Из хорошего, данная ошибка появляется быстро. Т.е. наш хост отправил SYN пакет, в ответ получил RST и сообщил об этом нам.</p>
</div>
<div class="paragraph">
<p>А теперь попробуем установить TCP соединение на порт, который не будет отвечать пакетом с флагом RST. Посмотрим, как себя поведет наша программа. Для этого на сервере miminet.ru настроен фаервол, который отбрасывает все входящие TCP пакеты с портом назначения равным 8000.</p>
</div>
<div class="paragraph">
<p>Поменяем переменную PORT на 8000 и запустим нашу программу. После длительного ожидания появляется ошибка:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="console">(venv) ScrumBook:src ilya2$ python tcp-client-2-port8000-1.py
Socket error: [Errno 60] Operation timed out</code></pre>
</div>
</div>
<div class="paragraph">
<p>Ошибка означает, что не удалось установить TCP соединение. Такую ошибку можно наблюдать, когда пакеты по какой-то причине не доходят до сервера. Либо они блокируются фаерволом, либо сервер просто выключен.</p>
</div>
<div class="paragraph">
<p>Это неприятная ошибка! Сокет и все его функции, включая <code>connect</code>, по умолчанию работают в блокирующем режиме. Это когда программа вызывает функцию и ждет, пока эта функция не завершит свою работу. И когда пакеты во время установки соединения вот так теряются, то вся программа зависает. В моем случае программа зависла на 75 секунд.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="console">(venv) ScrumBook:src ilya2$ time python tcp-client-2-port8000-1.py
Socket error: [Errno 60] Operation timed out

real    1m15.779s
user    0m0.028s
sys     0m0.012s</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
Если у вас Linux или MacOS, то для замера времени исполнения программы, перед запуском напишите time. Общее время исполнения программы будет отображаться в строке real.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Чтобы решить проблему с подвисанием, можно запустить работу с сокетом в отдельном потоке. Но, даже в отдельном потоке установка соединения может происходить аж 70 секунд. Это очень долго! Современные сети работают на много быстрей, чтобы ждать столько времени перед тем, как будет принято решение о невозможности установить соединение. Для уменьшения таймаута воспользуемся функцией <code>settimeout</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="python">s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
s.settimeout(<span style="color:#00D">5</span>)</code></pre>
</div>
</div>
<div class="paragraph">
<p>Сразу после создания сокета установим таймаут на блокирующие операции в 5 секунд. Теперь функция <code>connect</code> ожидает всего 5 секунд, после чего сообщает об ошибке и завершает свою работу.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="console">(venv) ScrumBook:src ilya2$ time python tcp-client-2-port8000-2.py
Socket error: timed out

real    0m5.055s
user    0m0.032s
sys     0m0.013s</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
Установка таймаута в 0 переведет сокет в неблокирующий режим. В этом случае нужно будет поменять схему работы с сокетом. Об этом будет подробней рассказано дальше по курсу.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>При работе с сокетом я всегда рекомендую уменьшать таймауты до приемлемого значения. Современные компьютерные сети позволяют на много быстрей определить невозможность установки соединения и сообщить об этом.</p>
</div>
</div>
<div class="sect3">
<h4 id="_обработка_отправки_данных_send">Обработка отправки данных (send)</h4>
<div class="paragraph">
<p>Функция <code>send</code> обычно отрабатывает без сбоя. Но вот что стоит о ней знать! Когда вы вызываете send, то данные не передаются приложению на другом конце сокета. Функция send только помещает данные в буфер для отправки. И все.</p>
</div>
<div class="paragraph">
<p>После того как функция <code>send</code> поместила данные на отправку, соединение может быть уже разорвано и, соответственно, никакие данные никуда не будут переданы. Учтите этот момент!</p>
</div>
</div>
<div class="sect3">
<h4 id="_обработка_получения_данных_recv">Обработка получения данных (recv)</h4>
<div class="paragraph">
<p>Функция <code>recv</code> принимает один обязательный аргумент - это максимальное количество байт, которое можно вернуть. В случае ошибки функция <code>recv</code> вернёт 0 байт данных. Это будет означать, что соединение было закрыто и от туда больше ничего не может быть получено.</p>
</div>
<div class="paragraph">
<p>Особо внимание стоит обратить на работу функции <code>recv</code>. Функция recv - блокирующая функция и она будет ожидать данные вечно (либо пока соединение не будет закрыто). Теоретически, вызвав <code>recv</code> вы можете вечно ожидать, пока она что-то вернет.</p>
</div>
<div class="paragraph">
<p>Чтобы воспроизвести проблему с <code>recv</code> изменим наш код на следующий:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="python"><span style="color:#777">#!/usr/bin/python</span>

<span style="color:#080;font-weight:bold">import</span> <span style="color:#B44;font-weight:bold">socket</span>

HOST = <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">miminet.ru</span><span style="color:#710">&quot;</span></span>
PORT = <span style="color:#00D">80</span>

s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
s.settimeout(<span style="color:#00D">5</span>)

<span style="color:#080;font-weight:bold">try</span>:
    s.connect((HOST, PORT))
    data = s.recv(<span style="color:#00D">4096</span>)
    print(data)
<span style="color:#080;font-weight:bold">except</span> <span style="color:#C00;font-weight:bold">Exception</span> <span style="color:#080;font-weight:bold">as</span> e:
    <span style="color:#080;font-weight:bold">print</span> (<span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">Socket error: </span><span style="color:#710">&quot;</span></span> + <span style="color:#369;font-weight:bold">str</span>(e))</code></pre>
</div>
</div>
<div class="paragraph">
<p>В этом коде мы убрали отправку HTTP-запроса (<code>s.send</code>) и сразу ожидаем данные. Запустите этот код. Программа будет ожидать данные до тех пор, пока сокет не будет закрыт или пока не истечет таймаут.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="console">(venv) ScrumBook:src ilya2$ time python tcp-client-2-recv.py
Socket error: timed out

real    0m5.079s
user    0m0.028s
sys     0m0.011s</code></pre>
</div>
</div>
<div class="paragraph">
<p>В этом случае ожидание длилось 5 секунд - время установленного таймаута.</p>
</div>
</div>
<div class="sect3">
<h4 id="_tcp_клиент_с_обработкой_ошибок">TCP-клиент с обработкой ошибок</h4>
<div class="paragraph">
<p>Давайте посмотрим, как будет выглядеть наш TCP-клиент с обработкой указанных ошибок:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="python"><span style="color:#777">#!/usr/bin/python</span>

<span style="color:#080;font-weight:bold">import</span> <span style="color:#B44;font-weight:bold">socket</span>

HOST = <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">miminet.ru</span><span style="color:#710">&quot;</span></span>
PORT = <span style="color:#00D">80</span>

s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
s.settimeout(<span style="color:#00D">5</span>)

<span style="color:#080;font-weight:bold">try</span>:
    s.connect((HOST, PORT))
    s.send(<span style="color:#549"><span>b</span><span style="color:#325">'</span><span>GET / HTTP/1.0</span><span style="color:#325">\n</span><span style="color:#325">\n</span><span style="color:#325">'</span></span>)
    data = s.recv(<span style="color:#00D">4096</span>)

    <span style="color:#080;font-weight:bold">if</span> <span style="color:#080;font-weight:bold">not</span> data:
        <span style="color:#080;font-weight:bold">raise</span> <span style="color:#C00;font-weight:bold">RuntimeError</span>(<span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">socket connection broken</span><span style="color:#710">&quot;</span></span>)

    print(data)
<span style="color:#080;font-weight:bold">except</span> <span style="color:#C00;font-weight:bold">Exception</span> <span style="color:#080;font-weight:bold">as</span> e:
    <span style="color:#080;font-weight:bold">print</span> (<span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">Socket error: </span><span style="color:#710">&quot;</span></span>+<span style="color:#369;font-weight:bold">str</span>(e))</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="python">s.settimeout(<span style="color:#00D">5</span>)</code></pre>
</div>
</div>
<div class="paragraph">
<p>Чтобы не ждать слишком долго блокирующих операций (при невозможности установить соединение и когда нечего читать в буфере приема).</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="python">    <span style="color:#080;font-weight:bold">if</span> <span style="color:#080;font-weight:bold">not</span> data:
        <span style="color:#080;font-weight:bold">raise</span> <span style="color:#C00;font-weight:bold">RuntimeError</span>(<span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">socket connection broken</span><span style="color:#710">&quot;</span></span>)</code></pre>
</div>
</div>
<div class="paragraph">
<p>Проверяем результат работы функции <code>recv</code> и в случае ошибки сообщаем, что соединение было закрыто.</p>
</div>
<div class="paragraph">
<p>В целом, уже не плохо!</p>
</div>
<div class="paragraph">
<p>Правда, проблема с <code>recv</code> до конца не решена. Если данные не поступят, то <code>recv</code> будет их ждать 5 секунд.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_проверка_доступности_данных_select">Проверка доступности данных (select)</h3>
<div class="paragraph">
<p>Можно работу с сокетами выделить в отдельный поток (<code>thread</code>) и не переживать о блокировке кода. Но, это перенос проблемы из одного места в другое. Для решения данной проблемы используется функция <code>`select</code>.</p>
</div>
<div class="paragraph">
<p>Функция <code>select</code> позволяет проверить наличия данных в буфере, что дает возможность вызывать <code>recv</code> только тогда, когда буфер не пуст и избегать ненужных ожиданий. Ниже представлен код с использованием <code>select</code></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="python"><span style="color:#777">##!/usr/bin/python</span>

<span style="color:#080;font-weight:bold">import</span> <span style="color:#B44;font-weight:bold">socket</span>
<span style="color:#080;font-weight:bold">import</span> <span style="color:#B44;font-weight:bold">select</span>

HOST = <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">miminet.ru</span><span style="color:#710">&quot;</span></span>
PORT = <span style="color:#00D">80</span>

s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
s.settimeout(<span style="color:#00D">5</span>)

<span style="color:#080;font-weight:bold">try</span>:
    s.connect((HOST, PORT))
    s.send(<span style="color:#549"><span>b</span><span style="color:#325">'</span><span>GET / HTTP/1.0</span><span style="color:#325">\n</span><span style="color:#325">\n</span><span style="color:#325">'</span></span>)

    rdy = select.select([s], [], [], <span style="color:#00D">2</span>)
    <span style="color:#080;font-weight:bold">if</span> <span style="color:#080;font-weight:bold">not</span> rdy[<span style="color:#00D">0</span>]:
        <span style="color:#080;font-weight:bold">raise</span> <span style="color:#C00;font-weight:bold">RuntimeError</span>(<span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">no response</span><span style="color:#710">&quot;</span></span>)

    data = s.recv(<span style="color:#00D">4096</span>)

    <span style="color:#080;font-weight:bold">if</span> <span style="color:#080;font-weight:bold">not</span> data:
        <span style="color:#080;font-weight:bold">raise</span> <span style="color:#C00;font-weight:bold">RuntimeError</span>(<span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">socket connection broken</span><span style="color:#710">&quot;</span></span>)

    print(data)

<span style="color:#080;font-weight:bold">except</span> <span style="color:#C00;font-weight:bold">Exception</span> <span style="color:#080;font-weight:bold">as</span> e:
    <span style="color:#080;font-weight:bold">print</span> (<span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">Socket error: </span><span style="color:#710">&quot;</span></span>+<span style="color:#369;font-weight:bold">str</span>(e))</code></pre>
</div>
</div>
<div class="paragraph">
<p>Функция select принимает 4 аргумент:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>список дескрипторов, готовых для чтения</p>
</li>
<li>
<p>список дескрипторов, готовых для записи</p>
</li>
<li>
<p>список дескрипторов которые в исключительном состоянии (exceptional condition)</p>
</li>
<li>
<p>время ожидания (float)</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="python">    rdy = select.select([s], [], [], <span style="color:#00D">2</span>)
    <span style="color:#080;font-weight:bold">if</span> <span style="color:#080;font-weight:bold">not</span> rdy[<span style="color:#00D">0</span>]:
        <span style="color:#080;font-weight:bold">raise</span> <span style="color:#C00;font-weight:bold">RuntimeError</span>(<span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">no response</span><span style="color:#710">&quot;</span></span>)</code></pre>
</div>
</div>
<div class="paragraph">
<p>Как и многие другие функции, <code>select</code> - блокирующая функция. Код выше означает - жать 2 секунды или пока в сокете <code>s</code> не появятся данные для чтения.</p>
</div>
<div class="paragraph">
<p>Проверка нужна для того, чтобы определить, функция <code>select</code> завершилась по таймауту  (2 секунды) или появились данные для чтения.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
функция select работает с дескрипторами и ей все равно, это сокет, файловый дескриптор или дескриптор для ввода/вывода с консоли.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Таким образом, у нас получился следующий TCP-клиент:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>если все хорошо, то все хорошо</p>
</li>
<li>
<p>если невозможно установить TCP соединение, сразу сообщаем об этом</p>
</li>
<li>
<p>если TCP соединение не устанавливается 5 секунд (вместо 70), прекращаем работу с ошибкой</p>
</li>
<li>
<p>если данные не приходят в ответ на запрос, ждем 2 секунды (вместо 5) и прекращаем работу.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Это уже на много лучше того, что было изначально.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
Вся сила функции <code>select</code> совсем не в том, что мы ждем всего 2 секунды. Она раскрывается при работе с множеством сокетов. Что бы для каждого сокета не выделять отдельный поток, используя <code>select</code> всю работу можно организовать в одном потоке.
</td>
</tr>
</table>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_udp_клиент">UDP-клиент</h2>
<div class="sectionbody">
<div class="paragraph">
<p>UDP-клиент во многом очень похож на TCP-клиент. Напишем программу, которая узнает точное время от одного из серверов времени. Для работы с сервером времени используется UDP протокол.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
Для синхронизации времени ОС используют SNTP (Simple Network Time Protocol) протокол. Сервер SNTP использует для работы порт 123 (UDP). SNTP работает по схеме запрос-ответ. Клиент отправляет запрос на сервер, а в ответ получает информацию о точном времени.
</td>
</tr>
</table>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="python"><span style="color:#080;font-weight:bold">import</span> <span style="color:#B44;font-weight:bold">socket</span>
<span style="color:#080;font-weight:bold">import</span> <span style="color:#B44;font-weight:bold">struct</span>
<span style="color:#080;font-weight:bold">import</span> <span style="color:#B44;font-weight:bold">time</span>
<span style="color:#080;font-weight:bold">import</span> <span style="color:#B44;font-weight:bold">select</span>

NTP_SERVER = <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">2.ru.pool.ntp.org</span><span style="color:#710">&quot;</span></span>
PORT = <span style="color:#00D">123</span>
TIME1970 = <span style="color:#00D">2208988800</span>

client = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)

data = <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#b0b">\x1b</span><span style="color:#710">'</span></span> + <span style="color:#00D">47</span> * <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#b0b">\0</span><span style="color:#710">'</span></span>

<span style="color:#080;font-weight:bold">try</span>:
    client.sendto( data.encode(<span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">utf-8</span><span style="color:#710">'</span></span>), (NTP_SERVER, PORT))
    rdy = select.select([client], [], [], <span style="color:#60E">0.9</span>)

    <span style="color:#080;font-weight:bold">if</span> <span style="color:#080;font-weight:bold">not</span> rdy[<span style="color:#00D">0</span>]:
        <span style="color:#080;font-weight:bold">raise</span> <span style="color:#C00;font-weight:bold">RuntimeError</span>(<span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">socket recv broken</span><span style="color:#710">&quot;</span></span>)

    data, address = client.recvfrom(<span style="color:#00D">1024</span>)

    <span style="color:#080;font-weight:bold">if</span> data:
        <span style="color:#080;font-weight:bold">print</span> (<span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">Response received from:</span><span style="color:#710">'</span></span>, address)
        t = struct.unpack( <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">!12I</span><span style="color:#710">'</span></span>, data )[<span style="color:#00D">8</span>]
        t -= TIME1970
        <span style="color:#080;font-weight:bold">print</span> (<span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#b0b">\t</span><span style="color:#D20">Time=%s</span><span style="color:#710">'</span></span> % time.ctime(t))
<span style="color:#080;font-weight:bold">except</span> <span style="color:#C00;font-weight:bold">Exception</span> <span style="color:#080;font-weight:bold">as</span> e:
    <span style="color:#080;font-weight:bold">print</span> (<span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">Socket error: </span><span style="color:#710">&quot;</span></span> + <span style="color:#369;font-weight:bold">str</span>(e))</code></pre>
</div>
</div>
<div class="paragraph">
<p>Необходимо выполнить следующие действия:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Создать UDP сокет.</p>
</li>
<li>
<p>Отправить запрос на SNTP сервер.</p>
</li>
<li>
<p>Получить ответ, достать полученное время и вывести его на экран.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>Обратите внимание, в отличие от TCP-клиента у UDP-клиента нет необходимости устанавливать соединение. Как мы знаем, UDP протокол не поддерживает их.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="python">NTP_SERVER = <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">2.ru.pool.ntp.org</span><span style="color:#710">&quot;</span></span>
PORT = <span style="color:#00D">123</span>
TIME1970 = <span style="color:#00D">2208988800</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Переменные NTP_SERVER и PORT содержат имя сервера и порт, на который мы будем отправлять SNTP запрос. Переменная TIME1970 содержит количество секунд прошедших с 1 Января 1900 года по 1 Января 1970 года.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="python">client = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)</code></pre>
</div>
</div>
<div class="paragraph">
<p>Создание UDP-сокета. Когда мы создавали TCP-сокет, то вторым параметром указывали socket.SOCK_STREAM, для создания UDP-сокета нужно указать socket.SOCK_DGRAM.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="python">data = <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#b0b">\x1b</span><span style="color:#710">'</span></span> + <span style="color:#00D">47</span> * <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#b0b">\0</span><span style="color:#710">'</span></span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Запрос, который мы будем отправлять на SNTP сервер. Не суть, что именно означает такой запрос. Пока главное понять, что SNTP сервер получив такой запрос сформирует и отправит SNTP-ответ, в котором будет указано точное время.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
Более подробно про формат SNTP-пакета можно почитать в <a href="https://www.rfc-editor.org/rfc/rfc1769#page-5">RFC 1769</a>.
</td>
</tr>
</table>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="python">client.sendto( data.encode(<span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">utf-8</span><span style="color:#710">'</span></span>), (NTP_SERVER, PORT))</code></pre>
</div>
</div>
<div class="paragraph">
<p>Функция <code>sendto</code> используется для отправки данных по UDP. Она принимает второй аргумент аналогичный тому, который принимает функция <code>connect</code> при установке TCP-соединения - это имя сервера или его IP-адрес и порт назначения. Еще раз обратите внимание,  перед отправкой данных по UDP соединение не устанавливается.</p>
</div>
<div class="paragraph">
<p>Отсутствие установки соединения приводит к тому, что после создания UDP-сокета нельзя вызывать функция <code>recv</code> или её аналог. На какой входящий порт ожидать UDP-пакет? А когда мы вызовем функцию <code>sendto</code>, то ОС отправит пакет на заданный IP-адрес и порт, а порт источника выберет случайным образом. И именно после этого момента можно будет вызывать функции для получения данных. Теперь, если придет UDP пакет на наш случайно выбранный порт и IP-адрес и порт источника, при этому, будут идентичны тем, что мы указали при sendto - то ОС передаст нам пакет на обработку.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="python">rdy = select.select([client], [], [], <span style="color:#60E">0.9</span>)

    <span style="color:#080;font-weight:bold">if</span> <span style="color:#080;font-weight:bold">not</span> rdy[<span style="color:#00D">0</span>]:
        <span style="color:#080;font-weight:bold">raise</span> <span style="color:#C00;font-weight:bold">RuntimeError</span>(<span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">socket recv broken</span><span style="color:#710">&quot;</span></span>)</code></pre>
</div>
</div>
<div class="paragraph">
<p>UDP - ненадежный протокол передачи данных. Отправив запрос на SNTP сервер не факт, что он дойдет. И еще нет уверенности в том, что ответ не потеряется. Поэтому, есть не малая вероятность вызывать функцию чтения из сокета и зависнуть там на долго. Мы уже знакомы с <code>select</code>, поэтому воспользуемся этой функцией для проверки доступности данных в буфере на чтение.</p>
</div>
<div class="paragraph">
<p>Я намеренно установил время ожидания менее 1 секунды, чтобы показать такую возможность. Некоторые разработчик, когда им нужно подождать, например, 0.5 секунды, пишут <code>select([], [], [], 0.5)</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="python">data, address = client.recvfrom(<span style="color:#00D">1024</span>)</code></pre>
</div>
</div>
<div class="paragraph">
<p>Функция <code>recvfrom</code> аналогична <code>recv</code>, только еще возвращает пару IP-адрес и порт источника.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="python">    <span style="color:#080;font-weight:bold">if</span> data:
        <span style="color:#080;font-weight:bold">print</span> (<span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">Response received from:</span><span style="color:#710">'</span></span>, address)
        t = struct.unpack( <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">!12I</span><span style="color:#710">'</span></span>, data)[<span style="color:#00D">8</span>]
        t -= TIME1970
        <span style="color:#080;font-weight:bold">print</span> (<span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#b0b">\t</span><span style="color:#D20">Time=%s</span><span style="color:#710">'</span></span> % time.ctime(t))</code></pre>
</div>
</div>
<div class="paragraph">
<p>Проверяем, есть ли данные в полученном пакете. Если есть:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>печатаем IP-адрес и порт источника</p>
</li>
<li>
<p>достаем из SNTP пакета время с сервера (кому интересно, смотрите подробности в <a href="https://www.rfc-editor.org/rfc/rfc1769#page-5">RFC 1769</a>)</p>
</li>
<li>
<p>вычитаем из времени 70 лет. SNTP сервер считает время в секундах от 1 Января 1900 года, а модуль <code>time</code> ожидает, что на вход поступит количество секунд прошедших с 1 Января 1970 года. Поэтому нужно из времени от SNTP сервера вычесть 70 лет.</p>
</li>
<li>
<p>печатаем время в консоль.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Результат работы программы представлен ниже:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="console">(venv) ScrumBook:src ilya2$ python udp-client-1.py
Response received from: ('192.36.143.130', 123)
        Time=Wed Oct 16 17:50:43 2024</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
Если у вас в нашем примере очень часто не приходят пакеты от сервера времени, попробуйте поменять его на 3.ru.pool.ntp.org или 1.ru.pool.ntp.org.
</td>
</tr>
</table>
</div>
<div class="sect2">
<h3 id="_отправка_на_несколько_хостов">Отправка на несколько хостов</h3>
<div class="paragraph">
<p>Когда мы вызываем функцию <code>recvfrom</code>, то помимо самих данных приходит информация об отправителе. В частности, IP-адрес и порт отправителя.</p>
</div>
<div class="paragraph">
<p>Может показаться - зачем, ведь мы помним, кому мы отправили данные? Дело в том, что UDP-сокет позволяет отправлять данные разным клиентам и на разные порты. Давайте перепишем наш UDP-клиент таким образом, чтобы он отправлял данные сразу на 3 разных сервера времени:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>1.ru.pool.ntp.org</p>
</li>
<li>
<p>2.ru.pool.ntp.org</p>
</li>
<li>
<p>3.ru.pool.ntp.org</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="python"><span style="color:#080;font-weight:bold">import</span> <span style="color:#B44;font-weight:bold">socket</span>
<span style="color:#080;font-weight:bold">import</span> <span style="color:#B44;font-weight:bold">struct</span>
<span style="color:#080;font-weight:bold">import</span> <span style="color:#B44;font-weight:bold">time</span>
<span style="color:#080;font-weight:bold">import</span> <span style="color:#B44;font-weight:bold">select</span>

NTP_SERVER1 = <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">1.ru.pool.ntp.org</span><span style="color:#710">&quot;</span></span>
NTP_SERVER2 = <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">2.ru.pool.ntp.org</span><span style="color:#710">&quot;</span></span>
NTP_SERVER3 = <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">3.ru.pool.ntp.org</span><span style="color:#710">&quot;</span></span>
PORT = <span style="color:#00D">123</span>
TIME1970 = <span style="color:#00D">2208988800</span>

client = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)

data = <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#b0b">\x1b</span><span style="color:#710">'</span></span> + <span style="color:#00D">47</span> * <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#b0b">\0</span><span style="color:#710">'</span></span>

<span style="color:#080;font-weight:bold">try</span>:
    client.sendto( data.encode(<span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">utf-8</span><span style="color:#710">'</span></span>), (NTP_SERVER1, PORT))
    client.sendto( data.encode(<span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">utf-8</span><span style="color:#710">'</span></span>), (NTP_SERVER2, PORT))
    client.sendto( data.encode(<span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">utf-8</span><span style="color:#710">'</span></span>), (NTP_SERVER3, PORT))

    <span style="color:#080;font-weight:bold">for</span> i <span style="color:#080;font-weight:bold">in</span> <span style="color:#369;font-weight:bold">range</span>(<span style="color:#00D">3</span>):
        rdy = select.select([client], [], [], <span style="color:#60E">0.9</span>)

        <span style="color:#080;font-weight:bold">if</span> <span style="color:#080;font-weight:bold">not</span> rdy[<span style="color:#00D">0</span>]:
            <span style="color:#080;font-weight:bold">raise</span> <span style="color:#C00;font-weight:bold">RuntimeError</span>(<span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">socket recv broken</span><span style="color:#710">&quot;</span></span>)

        data, address = client.recvfrom(<span style="color:#00D">1024</span>)

        <span style="color:#080;font-weight:bold">if</span> data:
            <span style="color:#080;font-weight:bold">print</span> (<span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">Response received from:</span><span style="color:#710">'</span></span>, address)
            t = struct.unpack( <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">!12I</span><span style="color:#710">'</span></span>, data)[<span style="color:#00D">8</span>]
            t -= TIME1970
            <span style="color:#080;font-weight:bold">print</span> (<span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#b0b">\t</span><span style="color:#D20">Time=%s</span><span style="color:#710">'</span></span> % time.ctime(t))

<span style="color:#080;font-weight:bold">except</span> <span style="color:#C00;font-weight:bold">Exception</span> <span style="color:#080;font-weight:bold">as</span> e:
    <span style="color:#080;font-weight:bold">print</span> (<span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">Socket error: </span><span style="color:#710">&quot;</span></span> + <span style="color:#369;font-weight:bold">str</span>(e))</code></pre>
</div>
</div>
<div class="paragraph">
<p>Запустим код. У меня далеко не всегда удавалось получить 3 ответа, а вот 2 два ответа получаю регулярно.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="programming/python/socket/socket-client/socket-udp/images/3host.png" alt="Результат отправки SNTP-запроса на 3 различных SNTP-сервера.">
</div>
<div class="title">Figure 2. Результат отправки SNTP-запроса на 3 различных SNTP-сервера.</div>
</div>
<div class="paragraph">
<p>Если посмотреть пакеты в сниффере (например, в Wireshark), то мы обнаружим, что все запросы отправились с одного UDP порта. У меня это 59 485, как показано на рисунке ниже.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="programming/python/socket/socket-client/socket-udp/images/3host-wireshark.png" alt="Результат работы Wireshark.">
</div>
<div class="title">Figure 3. Результат работы Wireshark.</div>
</div>
<div class="paragraph">
<p>В коде мы сразу отправляем 3 SNTP-запроса разным хостам с использованием функции <code>sendto</code>. А раз мы отправили 3 запроса, то ожидаем 3 ответа. Не факт, что все они придут, но мы их ждем! Это означает, что на наш UDP порт (в данном случае 59 485) может прийти три SNTP-ответа (от 1.ru.pool.ntp.org, 2.ru.pool.ntp.org и от 3.ru.pool.ntp.org).</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="python">    <span style="color:#080;font-weight:bold">for</span> i <span style="color:#080;font-weight:bold">in</span> <span style="color:#369;font-weight:bold">range</span>(<span style="color:#00D">3</span>):
        rdy = select.select([client], [], [], <span style="color:#60E">0.9</span>)

        <span style="color:#080;font-weight:bold">if</span> <span style="color:#080;font-weight:bold">not</span> rdy[<span style="color:#00D">0</span>]:
            <span style="color:#080;font-weight:bold">raise</span> <span style="color:#C00;font-weight:bold">RuntimeError</span>(<span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">socket recv broken</span><span style="color:#710">&quot;</span></span>)

        data, address = client.recvfrom(<span style="color:#00D">1024</span>)

        <span style="color:#080;font-weight:bold">if</span> data:
            <span style="color:#080;font-weight:bold">print</span> (<span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">Response received from:</span><span style="color:#710">'</span></span>, address)
            t = struct.unpack( <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">!12I</span><span style="color:#710">'</span></span>, data)[<span style="color:#00D">8</span>]
            t -= TIME1970
            <span style="color:#080;font-weight:bold">print</span> (<span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#b0b">\t</span><span style="color:#D20">Time=%s</span><span style="color:#710">'</span></span> % time.ctime(t))</code></pre>
</div>
</div>
<div class="paragraph">
<p>Поэтому в цикле вызываем функцию <code>select</code> и ждем ответа. Если ответ пришел, выводим информацию об отправителе и его точно время. А если ответ не пришел, вызываем исключение.</p>
</div>
<div class="paragraph">
<p>UDP-сокет позволяет отправлять пакеты множеству хостов и затем получать от них ответы.</p>
</div>
</div>
<div class="sect2">
<h3 id="_udp_клиент_и_метод_connect">UDP-клиент и метод connect</h3>
<div class="paragraph">
<p>Как известно, протокол UDP не устанавливает соединения и не заботится о надежной доставке данных. Поэтому, при работе с UDP-сокетом, обычно, вызов метода <code>connect</code> не производится.</p>
</div>
<div class="paragraph">
<p>При вызове метода <code>sendto</code> указывается IP-адрес и порт, на который нужно отправить данные. И именно в этот момент наша ОС выбирает порт источника, который будет указан в UDP-пакете. И даже в этот момент никакого соединения не устанавливается.</p>
</div>
<div class="paragraph">
<p>Чтобы в этом убедиться, проведем эксперимент - перед вызовом <code>sendto</code> вызовем функцию <code>sleep</code> из модуля time. Вызов функции <code>sleep</code> заставит программу уснуть на указанное число секунд, в моем случае, это 20. А в этом время мы посмотрим состояние наших сокетов используя утилиту <code>netstat</code></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="python"><span style="color:#080;font-weight:bold">import</span> <span style="color:#B44;font-weight:bold">socket</span>
<span style="color:#080;font-weight:bold">import</span> <span style="color:#B44;font-weight:bold">struct</span>
<span style="color:#080;font-weight:bold">import</span> <span style="color:#B44;font-weight:bold">time</span>
<span style="color:#080;font-weight:bold">import</span> <span style="color:#B44;font-weight:bold">select</span>

NTP_SERVER = <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">2.ru.pool.ntp.org</span><span style="color:#710">&quot;</span></span>
PORT = <span style="color:#00D">123</span>
TIME1970 = <span style="color:#00D">2208988800</span>

client = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)

data = <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#b0b">\x1b</span><span style="color:#710">'</span></span> + <span style="color:#00D">47</span> * <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#b0b">\0</span><span style="color:#710">'</span></span>

<span style="color:#080;font-weight:bold">try</span>:
    time.sleep(<span style="color:#00D">20</span>)
    client.sendto( data.encode(<span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">utf-8</span><span style="color:#710">'</span></span>), (NTP_SERVER, PORT))
    rdy = select.select([client], [], [], <span style="color:#60E">0.9</span>)

    <span style="color:#080;font-weight:bold">if</span> <span style="color:#080;font-weight:bold">not</span> rdy[<span style="color:#00D">0</span>]:
        <span style="color:#080;font-weight:bold">raise</span> <span style="color:#C00;font-weight:bold">RuntimeError</span>(<span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">socket recv broken</span><span style="color:#710">&quot;</span></span>)

    data, address = client.recvfrom(<span style="color:#00D">1024</span>)

    <span style="color:#080;font-weight:bold">if</span> data:
        <span style="color:#080;font-weight:bold">print</span> (<span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">Response received from:</span><span style="color:#710">'</span></span>, address)
        t = struct.unpack( <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">!12I</span><span style="color:#710">'</span></span>, data)[<span style="color:#00D">8</span>]
        t -= TIME1970
        <span style="color:#080;font-weight:bold">print</span> (<span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#b0b">\t</span><span style="color:#D20">Time=%s</span><span style="color:#710">'</span></span> % time.ctime(t))
<span style="color:#080;font-weight:bold">except</span> <span style="color:#C00;font-weight:bold">Exception</span> <span style="color:#080;font-weight:bold">as</span> e:
    <span style="color:#080;font-weight:bold">print</span> (<span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">Socket error: </span><span style="color:#710">&quot;</span></span> + <span style="color:#369;font-weight:bold">str</span>(e))</code></pre>
</div>
</div>
<div class="paragraph">
<p>Запустим программу, и пока она спит, посмотрим список открытых соединений на нашем хосте.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
Если у вас ОС Linux или MacOS, то список открытых соединений можно посмотреть командой netstat -an. Если у вас Windows, то наберите в консоли netstat -n
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>У меня на хосте (MacOS) очень много открытых соединений и чтобы не искать нужное, я отфильтрую их по строке 123 командой <code>grep</code>. Фильтрация происходит по 123, так как именно на этот UDP порт мы отправляем SNTP-запросы.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="programming/python/socket/socket-client/socket-udp/images/netstat-1.png" alt="Вывод команды netstat в MacOS.">
</div>
<div class="title">Figure 4. Вывод команды netstat в MacOS</div>
</div>
<div class="paragraph">
<p>Как видно, никаких открытых соединений. А теперь давайте вызовем функцию sleep после функции <code>sendto</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="python"><span style="color:#080;font-weight:bold">try</span>:
    client.sendto( data.encode(<span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">utf-8</span><span style="color:#710">'</span></span>), (NTP_SERVER, PORT))
    time.sleep(<span style="color:#00D">2</span>)
    rdy = select.select([client], [], [], <span style="color:#60E">0.9</span>)</code></pre>
</div>
</div>
<div class="paragraph">
<p>На этот раз поспим всего 2 секунды. Снова выполним программу и пока она спит, быстро посмотрим список открытых соединений.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="programming/python/socket/socket-client/socket-udp/images/netstat-2.png" alt="Вывод команды netstat в MacOS.">
</div>
<div class="title">Figure 5. Вывод команды netstat в MacOS</div>
</div>
<div class="paragraph">
<p>Вывод команды <code>netstat</code> оказался аналогичным первому, никаких открытых соединений нет. Это логично, ведь UDP не открывает соединения, а когда мы отправляем данные с помощью функции <code>sendto</code>, то ОС просто запоминает IP-адрес и порт назначения и выбранный случайным образом порт источника.</p>
</div>
<div class="paragraph">
<p>А вот если вызывать метод <code>connect</code> на UDP сокет, то ОС:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>сразу выделит порт источника для будущих UDP-пакетов</p>
</li>
<li>
<p>добавит к сокету состояние соединения (установлено)</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Соединение будет считаться установленным, так как для его установки не требуется отправка каких-либо пакетов.</p>
</div>
<div class="paragraph">
<p>Зачем это нужно?</p>
</div>
<div class="paragraph">
<p>Хоть это и не главное достоинство, но после вызова функции <code>connect</code> на UDP можно вызывать функции <code>send</code> и <code>recv</code> вместо <code>sendto</code> и <code>recvfrom</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="python"><span style="color:#080;font-weight:bold">import</span> <span style="color:#B44;font-weight:bold">socket</span>
<span style="color:#080;font-weight:bold">import</span> <span style="color:#B44;font-weight:bold">struct</span>
<span style="color:#080;font-weight:bold">import</span> <span style="color:#B44;font-weight:bold">time</span>
<span style="color:#080;font-weight:bold">import</span> <span style="color:#B44;font-weight:bold">select</span>

NTP_SERVER = <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">3.ru.pool.ntp.org</span><span style="color:#710">&quot;</span></span>
PORT = <span style="color:#00D">123</span>
TIME1970 = <span style="color:#00D">2208988800</span>

client = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)

data = <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#b0b">\x1b</span><span style="color:#710">'</span></span> + <span style="color:#00D">47</span> * <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#b0b">\0</span><span style="color:#710">'</span></span>

<span style="color:#080;font-weight:bold">try</span>:
    client.connect((NTP_SERVER, PORT))
    client.send( data.encode(<span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">utf-8</span><span style="color:#710">'</span></span>))

    rdy = select.select([client], [], [client], <span style="color:#60E">0.9</span>)

    <span style="color:#080;font-weight:bold">if</span> <span style="color:#080;font-weight:bold">not</span> rdy[<span style="color:#00D">0</span>]:
        <span style="color:#080;font-weight:bold">raise</span> <span style="color:#C00;font-weight:bold">RuntimeError</span>(<span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">socket recv broken</span><span style="color:#710">&quot;</span></span>)

    data = client.recv(<span style="color:#00D">1024</span>)

    <span style="color:#080;font-weight:bold">if</span> data:
        t = struct.unpack( <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">!12I</span><span style="color:#710">'</span></span>, data)[<span style="color:#00D">8</span>]
        t -= TIME1970
        <span style="color:#080;font-weight:bold">print</span> (<span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#b0b">\t</span><span style="color:#D20">Time=%s</span><span style="color:#710">'</span></span> % time.ctime(t))
<span style="color:#080;font-weight:bold">except</span> <span style="color:#C00;font-weight:bold">Exception</span> <span style="color:#080;font-weight:bold">as</span> e:
    <span style="color:#080;font-weight:bold">print</span> (<span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">Socket error: </span><span style="color:#710">&quot;</span></span> + <span style="color:#369;font-weight:bold">str</span>(e))</code></pre>
</div>
</div>
<div class="paragraph">
<p>Запустив код мы увидим, что он работает нормально. Если SNTP-ответ доходит до нас, то мы просто печатает точно время, как обычно. А если нет, то получаем сообщение об ошибке.</p>
</div>
<div class="paragraph">
<p>Теперь с UDP сокетом можно работать также, как и с TCP. Если вы не собираетесь в рамках одного сокета работать с несколькими хостами, то смело вызывайте функцию <code>connect</code> вы используйте привычные функции <code>send</code> и <code>recv</code>.</p>
</div>
<div class="paragraph">
<p>Другим большим преимуществом вызову функции <code>connect</code> на UDP-сокет является обработка сетевых ошибок.</p>
</div>
<div class="paragraph">
<p>Когда TCP-клиент пытается установить соединение на закрытый порт, то в ответ он получает TCP-пакет с флагом RST. Таким образом, при вызове функции <code>connect</code> у TCP-клиента можно сразу сделать вывод о невозможности связаться с удаленной стороной и не отправлять данные. Или, удаленная сторона может закрыть соединение и тогда функция <code>recv</code> на TCP-клиенте вернет 0 байт.</p>
</div>
<div class="paragraph">
<p>А что делать в случае с UDP? Например, мы написали UDP-клиента для получения точного времени с SNTP серверов. Отправили SNTP-запрос, а в ответ тишина. Как реагировать на отсутствие ответов:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>SNTP-запрос не дошел до сервера?</p>
</li>
<li>
<p>SNTP-запрос не дошел от сервера до нас?</p>
</li>
<li>
<p>нет сервера, который слушает порт 123 (UDP)?</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>В первых двух случаях мы можем повторить отправку данных. А вот в последнем случае нет смысла повторно отправлять данные. Даже если они дойдут до удаленного хоста, никто не будет их обрабатывать.</p>
</div>
<div class="paragraph">
<p>Да, UDP не устанавливает соединение. И для того, чтобы хоть как-то определить отсутствие готовности удаленной стороны принимать данные используется ICMP сообщения. В частности, если хост получает UDP пакет на порт, который никто не слушает, то ОС в ответ отправляет ICMP сообщение тип=3, код=3 - Destination Port Unreachable.</p>
</div>
<div class="paragraph">
<p>Получив такое ICMP сообщение, ОС изменит состояние соединения и при попытке отправить или прочитать данные из сокета мы получим ошибку.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
Еще раз обратите внимание, что соединение - это просто некоторое состояние сокета.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Давайте воспроизведём ошибку. Отправим SNTP-запрос за закрытый порт. Например, на хост miminet.ru и порт 125.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="python"><span style="color:#080;font-weight:bold">import</span> <span style="color:#B44;font-weight:bold">socket</span>
<span style="color:#080;font-weight:bold">import</span> <span style="color:#B44;font-weight:bold">struct</span>
<span style="color:#080;font-weight:bold">import</span> <span style="color:#B44;font-weight:bold">time</span>
<span style="color:#080;font-weight:bold">import</span> <span style="color:#B44;font-weight:bold">select</span>

NTP_SERVER = <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">miminet.ru</span><span style="color:#710">&quot;</span></span>
PORT = <span style="color:#00D">125</span>
TIME1970 = <span style="color:#00D">2208988800</span>

client = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)

data = <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#b0b">\x1b</span><span style="color:#710">'</span></span> + <span style="color:#00D">47</span> * <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#b0b">\0</span><span style="color:#710">'</span></span>

<span style="color:#080;font-weight:bold">try</span>:
    client.connect((NTP_SERVER, PORT))
    client.send( data.encode(<span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">utf-8</span><span style="color:#710">'</span></span>))

    rdy = select.select([client], [], [], <span style="color:#60E">0.9</span>)

    <span style="color:#080;font-weight:bold">if</span> <span style="color:#080;font-weight:bold">not</span> rdy[<span style="color:#00D">0</span>]:
        <span style="color:#080;font-weight:bold">raise</span> <span style="color:#C00;font-weight:bold">RuntimeError</span>(<span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">socket recv broken</span><span style="color:#710">&quot;</span></span>)

    data = client.recv(<span style="color:#00D">1024</span>)

    <span style="color:#080;font-weight:bold">if</span> data:
        t = struct.unpack( <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">!12I</span><span style="color:#710">'</span></span>, data)[<span style="color:#00D">8</span>]
        t -= TIME1970
        <span style="color:#080;font-weight:bold">print</span> (<span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#b0b">\t</span><span style="color:#D20">Time=%s</span><span style="color:#710">'</span></span> % time.ctime(t))
<span style="color:#080;font-weight:bold">except</span> <span style="color:#C00;font-weight:bold">Exception</span> <span style="color:#080;font-weight:bold">as</span> e:
    <span style="color:#080;font-weight:bold">print</span> (<span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">Socket error: </span><span style="color:#710">&quot;</span></span> + <span style="color:#369;font-weight:bold">str</span>(e))</code></pre>
</div>
</div>
<div class="paragraph">
<p>Теперь, если мы запустим код то мы получим сообщение <code>Connection refused</code>, как показано ниже.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
Вы можете не получить это сообщение с первого раза, если по пути потеряется UDP или ICMP пакет. Попробуйте запустить программу несколько раз.
</td>
</tr>
</table>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="console">(venv) ScrumBook:src ilya2$ python3 udp-client-3-connect-icmp.py
Socket error: [Errno 61] Connection refused
(venv) ScrumBook:src ilya2$</code></pre>
</div>
</div>
<div class="paragraph">
<p>Если во время выполнения программу запустить сниффер Wireshark, то мы увидим ICMP пакет "Destination Port unreachable". И внутри этого сообщения будет находиться наш UDP пакет.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
Внутри ICMP сообщений с ошибками всегда находится пакет, который вызвал эту ошибку. Таким образом, получив такое ICMP сообщение ОС всегда сможет понять, какой именно пакет вызвал эту ошибку и отреагировать соответствующим образом. В нашем случае ОС установит состояние соединения у нашего сокета на "закрытый".
</td>
</tr>
</table>
</div>
<div class="imageblock">
<div class="content">
<img src="programming/python/socket/socket-client/socket-udp/images/connect-icmp.png" alt="UDP и ICMP пакеты в Wireshark.">
</div>
<div class="title">Figure 6. UDP и ICMP пакеты в Wireshark</div>
</div>
<div class="paragraph">
<p>А вот еще один пример, UDP-клиенту запрещено отправлять UDP пакеты на внешние IP-адреса. При попытке отправить любой UDP пакет в ответ приходит ICMP сообщение тип=3, код=13 - Communication Administratively Prohibited. Оно также влияет на состояние сокета и мы получаем ошибку <code>Connection refused</code>.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="programming/python/socket/socket-client/socket-udp/images/connect-icmp2.png" alt="UDP и ICMP пакеты в Wireshark.">
</div>
<div class="title">Figure 7. UDP и ICMP пакеты в Wireshark</div>
</div>
<div class="paragraph">
<p>Если вы используете UDP сокет для работы с одним удаленным приложением, то я еще раз рекомендую использовать функцию <code>connect</code>. Это позволит вам обнаруживать и реагировать на ошибки в сети.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_сокеты_2">Сокеты</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Для работы с сетью на низком уровне используются сокеты (socket). Сокет - это название программного интерфейса (API) для обеспечения обмена данными между процессами. Процессы при этом могут исполняться как на одном хосте, так и на различных.</p>
</div>
<div class="paragraph">
<p>Хорошей аналогией сокета является файловый дескриптор - некоторая абстракция, для работы с файлами в ОС. Вы можете открыть или закрыть файловый дескриптор, можете прочитать или записать туда данные и т.д.</p>
</div>
<div class="paragraph">
<p>Использование сокета у клиента немного отличается от сервера. Во время разработки сервера вы увидите эту разницу.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
Подробности по использованию сокетов в Python можно найти <a href="https://docs.python.org/3.8/library/socket.html">в официальной документации</a>.
</td>
</tr>
</table>
</div>
<div class="sect2">
<h3 id="_tcp_клиент_2">TCP-клиент</h3>
<div class="paragraph">
<p>Давайте напишем первого сетевого клиента, который будет подключаться к серверу miminet.ru на порт 80 (TCP), отправлять HTTP-запрос, получать HTTP-ответ и печатать содержимое ответа в консоль. Схема работы показана на рисунке ниже.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="programming/python/socket/socket-client/socket-tcp/images/http-schema.png" alt="Схема работы TCP-клиента.">
</div>
<div class="title">Figure 8. Схема работы TCP-клиента.</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
HTTP (HyperText Transfer Protocol) - протокол для коммуникации с веб-сервером. HTTP-запрос - запрос отправляемый клиентом на веб-сервер. В ответ на такой запрос веб-сервер отправляет данные (HTML страницу, JS код, картинки, видео и т.д.) или отправляет информационное сообщение.
</td>
</tr>
</table>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
По умолчанию, веб-сервер для работы использует порт 80 (TCP).
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Нам необходимо выполнить следующие действия:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Создать TCP сокет.</p>
</li>
<li>
<p>Подключиться к веб-серверу miminet.ru на порт 80.</p>
</li>
<li>
<p>Отправить HTTP-запрос.</p>
</li>
<li>
<p>Получить ответ и вывести его на экран.</p>
</li>
</ol>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="python"><span style="color:#777">#!/usr/bin/python</span>

<span style="color:#080;font-weight:bold">import</span> <span style="color:#B44;font-weight:bold">socket</span>

HOST = <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">miminet.ru</span><span style="color:#710">&quot;</span></span>
PORT = <span style="color:#00D">80</span>                                               <span style="color:#777"># HTTP port</span>

ip_addr = socket.gethostbyname(HOST)                    <span style="color:#777"># Get IP address by name</span>
s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)   <span style="color:#777"># Create TCP socket</span>
s.connect((ip_addr, PORT))                              <span style="color:#777"># Connect to miminet.ru</span>
s.send(<span style="color:#549"><span>b</span><span style="color:#325">'</span><span>GET / HTTP/1.0</span><span style="color:#325">\n</span><span style="color:#325">\n</span><span style="color:#325">'</span></span>)                           <span style="color:#777"># Send HTTP-request</span>
data = s.recv(<span style="color:#00D">4096</span>)                                     <span style="color:#777"># Recieve data from miminet.ru</span>
print(data)                                             <span style="color:#777"># Print data to console</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Вы можете скопировать этот код и попробовать выполнить его у себя. В результате его работы в консоль должно вывестись следующее сообщение:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code>(venv) ScrumBook:src ilya2$ python tcp-client-1.py
b'HTTP/1.1 301 Moved Permanently\r\nServer: nginx/1.25.4\r\nDate: Wed, 16 Oct 2024 08:40:37 GMT\r\nContent-Type: text/html\r\nContent-Length: 169\r\nConnection: close\r\nLocation: https://miminet.ru/\r\n\r\n&lt;html&gt;\r\n&lt;head&gt;&lt;title&gt;301 Moved Permanently&lt;/title&gt;&lt;/head&gt;\r\n&lt;body&gt;\r\n&lt;center&gt;&lt;h1&gt;301 Moved Permanently&lt;/h1&gt;&lt;/center&gt;\r\n&lt;hr&gt;&lt;center&gt;nginx/1.25.4&lt;/center&gt;\r\n&lt;/body&gt;\r\n&lt;/html&gt;\r\n'</code></pre>
</div>
</div>
<div class="paragraph">
<p>Я постарался прокомментировать каждую строку, но давайте подробней  разберем, что мы делаем и что происходит</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="python"><span style="color:#080;font-weight:bold">import</span> <span style="color:#B44;font-weight:bold">socket</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Импортируем модуль socket. Как раз он нам позволит работать с сокетами.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="python">ip_addr = socket.gethostbyname(HOST)</code></pre>
</div>
</div>
<div class="paragraph">
<p>Для создания TCP соединения необходимо знать IP-адрес хоста и порт, на который мы хотим подключиться. Пока мы знаем только имя хоста miminet.ru и порт 80. Функция gethostbyname позволяет по имени определить IP-адрес хоста. Т.е. по имени miminet.ru она вернет IP-адрес хоста. Сохраним его в переменную ip_addr.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="python">s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</code></pre>
</div>
</div>
<div class="paragraph">
<p>Данный код создает TCP сокет и сохраняет его в переменную <code>s</code>. Функция <code>socket</code> позволяет создавать не только TCP или UDP сокеты. Она принимает два обязательных параметра:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>socket.AF_INET - когда мы хотим открыть сокет из семейства протоколов TCP/IP</p>
</li>
<li>
<p>socket.SOCK_STREAM - для создания TCP-сокета.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>И так, сокет создан, IP-адрес и порт известны, можем подключаться.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="python">s.connect((ip_addr, PORT))</code></pre>
</div>
</div>
<div class="paragraph">
<p>Функция <code>connect</code> устанавливает TCP соединения (3-х разовое рукопожатие SYN, SYN+ACK, ACK) на заданный IP-адрес и порт. Обратите внимание, что функция <code>connect</code> принимает только один порт - это порт назначения. Т.е. порт, на который мы устанавливаем соединение. У клиентов (тот кто инициирует установку соединения) порт источника выбирается случайным образом.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="python">s.send(<span style="color:#549"><span>b</span><span style="color:#325">'</span><span>GET / HTTP/1.0</span><span style="color:#325">\n</span><span style="color:#325">\n</span><span style="color:#325">'</span></span>)</code></pre>
</div>
</div>
<div class="paragraph">
<p>Функция <code>send</code> отправляет данные в установленное TCP соединение. В данном случае мы отправили HTTP-запрос на веб-сервер miminet.ru. HTTP - это текстовый протокол, поэтому, запрос можно написать прямым текстом. Два подряд идущие перевода строки <code>\n\n</code> означают окончание HTTP-запроса. В этом HTTP-запросе мы хотим получить главную страницу miminet.ru.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="python">data = s.recv(<span style="color:#00D">4096</span>)</code></pre>
</div>
</div>
<div class="paragraph">
<p>Получаем данные из сокета. Функция <code>recv</code> по умолчанию работает в блокирующем режиме. Это означает, что вызвав эту функцию программа будет ожидать, пока не придут данные. Так как заранее не известно, сколько данных придет, указал 4096 байт. Если данных придет меньше, вернут их, если придет больше, вернут не более 4096 байт. Полученные данные сохраняем в переменную <code>data</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="python">print(data)</code></pre>
</div>
</div>
<div class="paragraph">
<p>Печатаем полученные данные в консоль.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
На самом деле можно опустить вызов функции <code>gethostbyname</code>, так как функция <code>connect</code> может самостоятельно по имени определить IP адрес. Я решил оставить <code>gethostbyname</code> для наглядности.
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="_обработка_ошибок_2">Обработка ошибок</h3>
<div class="paragraph">
<p>Код из примера выше годится только для примера. Не трудно заметить, что там нет обработки ошибок. Давайте добавим обработку ошибок и посмотрим, что может пойти не так.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="python"><span style="color:#777">#!/usr/bin/python</span>

<span style="color:#080;font-weight:bold">import</span> <span style="color:#B44;font-weight:bold">socket</span>

HOST = <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">miminet.ru</span><span style="color:#710">&quot;</span></span>
PORT = <span style="color:#00D">80</span>

s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)

<span style="color:#080;font-weight:bold">try</span>:
    s.connect((HOST, PORT))
    s.send(<span style="color:#549"><span>b</span><span style="color:#325">'</span><span>GET / HTTP/1.0</span><span style="color:#325">\n</span><span style="color:#325">\n</span><span style="color:#325">'</span></span>)
    data = s.recv(<span style="color:#00D">4096</span>)
    print(data)
<span style="color:#080;font-weight:bold">except</span> <span style="color:#C00;font-weight:bold">Exception</span> <span style="color:#080;font-weight:bold">as</span> e:
    <span style="color:#080;font-weight:bold">print</span> (<span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">Socket error: </span><span style="color:#710">&quot;</span></span> + <span style="color:#369;font-weight:bold">str</span>(e))</code></pre>
</div>
</div>
<div class="sect3">
<h4 id="_ошибка_преобразования_имени_в_ip_адрес_2">Ошибка преобразования имени в IP адрес</h4>
<div class="paragraph">
<p>Попробуем вместо имени хоста miminet.ru подставить несуществующее имя, например, miminet.rus.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="python">HOST = <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">miminet.rus</span><span style="color:#710">&quot;</span></span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Для этого изменим имя хоста в переменной HOST и запустим наш код. В результате мы получим ошибку:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="console">(venv) ScrumBook:src ilya2$ python tcp-client-2-hostname.py
Socket error: [Errno 8] nodename nor servname provided, or not known</code></pre>
</div>
</div>
<div class="paragraph">
<p>Она означает, что нам не удалось по имени хоста определить IP-адрес. Дальнейшая установка соединения бессмысленно, так как мы не знаем IP-адрес хоста.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
Для воспроизведения следующих ошибок верните имя в переменной HOST обратно на miminet.ru
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="_ошибка_подключения_2">Ошибка подключения</h4>
<div class="paragraph">
<p>Для воспроизведения ошибки подключения поменяем переменную PORT c 80 на 81 (можно и 81 и многие другие порты, которые закрыты). Запустим наш код и увидим ошибку подключения:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="console">(venv) ScrumBook:src ilya2$ python tcp-client-2-port81.py
Socket error: [Errno 61] Connection refused</code></pre>
</div>
</div>
<div class="paragraph">
<p>Данная ошибка сообщает, что на удаленной стороне нет программы, которая готова работать на указанном порту. В моем случае - это порт 81. Нет смысла продолжать выполнять программу и пытаться отправить данные. Ошибка появляется, когда во время установки TCP соединения клиент получает пакет с флагом RST. Из хорошего, данная ошибка появляется быстро. Т.е. наш хост отправил SYN пакет, в ответ получил RST и сообщил об этом нам.</p>
</div>
<div class="paragraph">
<p>А теперь попробуем установить TCP соединение на порт, который не будет отвечать пакетом с флагом RST. Посмотрим, как себя поведет наша программа. Для этого на сервере miminet.ru настроен фаервол, который отбрасывает все входящие TCP пакеты с портом назначения равным 8000.</p>
</div>
<div class="paragraph">
<p>Поменяем переменную PORT на 8000 и запустим нашу программу. После длительного ожидания появляется ошибка:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="console">(venv) ScrumBook:src ilya2$ python tcp-client-2-port8000-1.py
Socket error: [Errno 60] Operation timed out</code></pre>
</div>
</div>
<div class="paragraph">
<p>Ошибка означает, что не удалось установить TCP соединение. Такую ошибку можно наблюдать, когда пакеты по какой-то причине не доходят до сервера. Либо они блокируются фаерволом, либо сервер просто выключен.</p>
</div>
<div class="paragraph">
<p>Это неприятная ошибка! Сокет и все его функции, включая <code>connect</code>, по умолчанию работают в блокирующем режиме. Это когда программа вызывает функцию и ждет, пока эта функция не завершит свою работу. И когда пакеты во время установки соединения вот так теряются, то вся программа зависает. В моем случае программа зависла на 75 секунд.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="console">(venv) ScrumBook:src ilya2$ time python tcp-client-2-port8000-1.py
Socket error: [Errno 60] Operation timed out

real    1m15.779s
user    0m0.028s
sys     0m0.012s</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
Если у вас Linux или MacOS, то для замера времени исполнения программы, перед запуском напишите time. Общее время исполнения программы будет отображаться в строке real.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Чтобы решить проблему с подвисанием, можно запустить работу с сокетом в отдельном потоке. Но, даже в отдельном потоке установка соединения может происходить аж 70 секунд. Это очень долго! Современные сети работают на много быстрей, чтобы ждать столько времени перед тем, как будет принято решение о невозможности установить соединение. Для уменьшения таймаута воспользуемся функцией <code>settimeout</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="python">s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
s.settimeout(<span style="color:#00D">5</span>)</code></pre>
</div>
</div>
<div class="paragraph">
<p>Сразу после создания сокета установим таймаут на блокирующие операции в 5 секунд. Теперь функция <code>connect</code> ожидает всего 5 секунд, после чего сообщает об ошибке и завершает свою работу.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="console">(venv) ScrumBook:src ilya2$ time python tcp-client-2-port8000-2.py
Socket error: timed out

real    0m5.055s
user    0m0.032s
sys     0m0.013s</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
Установка таймаута в 0 переведет сокет в неблокирующий режим. В этом случае нужно будет поменять схему работы с сокетом. Об этом будет подробней рассказано дальше по курсу.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>При работе с сокетом я всегда рекомендую уменьшать таймауты до приемлемого значения. Современные компьютерные сети позволяют на много быстрей определить невозможность установки соединения и сообщить об этом.</p>
</div>
</div>
<div class="sect3">
<h4 id="_обработка_отправки_данных_send_2">Обработка отправки данных (send)</h4>
<div class="paragraph">
<p>Функция <code>send</code> обычно отрабатывает без сбоя. Но вот что стоит о ней знать! Когда вы вызываете send, то данные не передаются приложению на другом конце сокета. Функция send только помещает данные в буфер для отправки. И все.</p>
</div>
<div class="paragraph">
<p>После того как функция <code>send</code> поместила данные на отправку, соединение может быть уже разорвано и, соответственно, никакие данные никуда не будут переданы. Учтите этот момент!</p>
</div>
</div>
<div class="sect3">
<h4 id="_обработка_получения_данных_recv_2">Обработка получения данных (recv)</h4>
<div class="paragraph">
<p>Функция <code>recv</code> принимает один обязательный аргумент - это максимальное количество байт, которое можно вернуть. В случае ошибки функция <code>recv</code> вернёт 0 байт данных. Это будет означать, что соединение было закрыто и от туда больше ничего не может быть получено.</p>
</div>
<div class="paragraph">
<p>Особо внимание стоит обратить на работу функции <code>recv</code>. Функция recv - блокирующая функция и она будет ожидать данные вечно (либо пока соединение не будет закрыто). Теоретически, вызвав <code>recv</code> вы можете вечно ожидать, пока она что-то вернет.</p>
</div>
<div class="paragraph">
<p>Чтобы воспроизвести проблему с <code>recv</code> изменим наш код на следующий:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="python"><span style="color:#777">#!/usr/bin/python</span>

<span style="color:#080;font-weight:bold">import</span> <span style="color:#B44;font-weight:bold">socket</span>

HOST = <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">miminet.ru</span><span style="color:#710">&quot;</span></span>
PORT = <span style="color:#00D">80</span>

s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
s.settimeout(<span style="color:#00D">5</span>)

<span style="color:#080;font-weight:bold">try</span>:
    s.connect((HOST, PORT))
    data = s.recv(<span style="color:#00D">4096</span>)
    print(data)
<span style="color:#080;font-weight:bold">except</span> <span style="color:#C00;font-weight:bold">Exception</span> <span style="color:#080;font-weight:bold">as</span> e:
    <span style="color:#080;font-weight:bold">print</span> (<span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">Socket error: </span><span style="color:#710">&quot;</span></span> + <span style="color:#369;font-weight:bold">str</span>(e))</code></pre>
</div>
</div>
<div class="paragraph">
<p>В этом коде мы убрали отправку HTTP-запроса (<code>s.send</code>) и сразу ожидаем данные. Запустите этот код. Программа будет ожидать данные до тех пор, пока сокет не будет закрыт или пока не истечет таймаут.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="console">(venv) ScrumBook:src ilya2$ time python tcp-client-2-recv.py
Socket error: timed out

real    0m5.079s
user    0m0.028s
sys     0m0.011s</code></pre>
</div>
</div>
<div class="paragraph">
<p>В этом случае ожидание длилось 5 секунд - время установленного таймаута.</p>
</div>
</div>
<div class="sect3">
<h4 id="_tcp_клиент_с_обработкой_ошибок_2">TCP-клиент с обработкой ошибок</h4>
<div class="paragraph">
<p>Давайте посмотрим, как будет выглядеть наш TCP-клиент с обработкой указанных ошибок:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="python"><span style="color:#777">#!/usr/bin/python</span>

<span style="color:#080;font-weight:bold">import</span> <span style="color:#B44;font-weight:bold">socket</span>

HOST = <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">miminet.ru</span><span style="color:#710">&quot;</span></span>
PORT = <span style="color:#00D">80</span>

s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
s.settimeout(<span style="color:#00D">5</span>)

<span style="color:#080;font-weight:bold">try</span>:
    s.connect((HOST, PORT))
    s.send(<span style="color:#549"><span>b</span><span style="color:#325">'</span><span>GET / HTTP/1.0</span><span style="color:#325">\n</span><span style="color:#325">\n</span><span style="color:#325">'</span></span>)
    data = s.recv(<span style="color:#00D">4096</span>)

    <span style="color:#080;font-weight:bold">if</span> <span style="color:#080;font-weight:bold">not</span> data:
        <span style="color:#080;font-weight:bold">raise</span> <span style="color:#C00;font-weight:bold">RuntimeError</span>(<span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">socket connection broken</span><span style="color:#710">&quot;</span></span>)

    print(data)
<span style="color:#080;font-weight:bold">except</span> <span style="color:#C00;font-weight:bold">Exception</span> <span style="color:#080;font-weight:bold">as</span> e:
    <span style="color:#080;font-weight:bold">print</span> (<span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">Socket error: </span><span style="color:#710">&quot;</span></span>+<span style="color:#369;font-weight:bold">str</span>(e))</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="python">s.settimeout(<span style="color:#00D">5</span>)</code></pre>
</div>
</div>
<div class="paragraph">
<p>Чтобы не ждать слишком долго блокирующих операций (при невозможности установить соединение и когда нечего читать в буфере приема).</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="python">    <span style="color:#080;font-weight:bold">if</span> <span style="color:#080;font-weight:bold">not</span> data:
        <span style="color:#080;font-weight:bold">raise</span> <span style="color:#C00;font-weight:bold">RuntimeError</span>(<span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">socket connection broken</span><span style="color:#710">&quot;</span></span>)</code></pre>
</div>
</div>
<div class="paragraph">
<p>Проверяем результат работы функции <code>recv</code> и в случае ошибки сообщаем, что соединение было закрыто.</p>
</div>
<div class="paragraph">
<p>В целом, уже не плохо!</p>
</div>
<div class="paragraph">
<p>Правда, проблема с <code>recv</code> до конца не решена. Если данные не поступят, то <code>recv</code> будет их ждать 5 секунд.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_проверка_доступности_данных_select_2">Проверка доступности данных (select)</h3>
<div class="paragraph">
<p>Можно работу с сокетами выделить в отдельный поток (<code>thread</code>) и не переживать о блокировке кода. Но, это перенос проблемы из одного места в другое. Для решения данной проблемы используется функция <code>`select</code>.</p>
</div>
<div class="paragraph">
<p>Функция <code>select</code> позволяет проверить наличия данных в буфере, что дает возможность вызывать <code>recv</code> только тогда, когда буфер не пуст и избегать ненужных ожиданий. Ниже представлен код с использованием <code>select</code></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="python"><span style="color:#777">##!/usr/bin/python</span>

<span style="color:#080;font-weight:bold">import</span> <span style="color:#B44;font-weight:bold">socket</span>
<span style="color:#080;font-weight:bold">import</span> <span style="color:#B44;font-weight:bold">select</span>

HOST = <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">miminet.ru</span><span style="color:#710">&quot;</span></span>
PORT = <span style="color:#00D">80</span>

s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
s.settimeout(<span style="color:#00D">5</span>)

<span style="color:#080;font-weight:bold">try</span>:
    s.connect((HOST, PORT))
    s.send(<span style="color:#549"><span>b</span><span style="color:#325">'</span><span>GET / HTTP/1.0</span><span style="color:#325">\n</span><span style="color:#325">\n</span><span style="color:#325">'</span></span>)

    rdy = select.select([s], [], [], <span style="color:#00D">2</span>)
    <span style="color:#080;font-weight:bold">if</span> <span style="color:#080;font-weight:bold">not</span> rdy[<span style="color:#00D">0</span>]:
        <span style="color:#080;font-weight:bold">raise</span> <span style="color:#C00;font-weight:bold">RuntimeError</span>(<span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">no response</span><span style="color:#710">&quot;</span></span>)

    data = s.recv(<span style="color:#00D">4096</span>)

    <span style="color:#080;font-weight:bold">if</span> <span style="color:#080;font-weight:bold">not</span> data:
        <span style="color:#080;font-weight:bold">raise</span> <span style="color:#C00;font-weight:bold">RuntimeError</span>(<span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">socket connection broken</span><span style="color:#710">&quot;</span></span>)

    print(data)

<span style="color:#080;font-weight:bold">except</span> <span style="color:#C00;font-weight:bold">Exception</span> <span style="color:#080;font-weight:bold">as</span> e:
    <span style="color:#080;font-weight:bold">print</span> (<span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">Socket error: </span><span style="color:#710">&quot;</span></span>+<span style="color:#369;font-weight:bold">str</span>(e))</code></pre>
</div>
</div>
<div class="paragraph">
<p>Функция select принимает 4 аргумент:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>список дескрипторов, готовых для чтения</p>
</li>
<li>
<p>список дескрипторов, готовых для записи</p>
</li>
<li>
<p>список дескрипторов которые в исключительном состоянии (exceptional condition)</p>
</li>
<li>
<p>время ожидания (float)</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="python">    rdy = select.select([s], [], [], <span style="color:#00D">2</span>)
    <span style="color:#080;font-weight:bold">if</span> <span style="color:#080;font-weight:bold">not</span> rdy[<span style="color:#00D">0</span>]:
        <span style="color:#080;font-weight:bold">raise</span> <span style="color:#C00;font-weight:bold">RuntimeError</span>(<span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">no response</span><span style="color:#710">&quot;</span></span>)</code></pre>
</div>
</div>
<div class="paragraph">
<p>Как и многие другие функции, <code>select</code> - блокирующая функция. Код выше означает - жать 2 секунды или пока в сокете <code>s</code> не появятся данные для чтения.</p>
</div>
<div class="paragraph">
<p>Проверка нужна для того, чтобы определить, функция <code>select</code> завершилась по таймауту  (2 секунды) или появились данные для чтения.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
функция select работает с дескрипторами и ей все равно, это сокет, файловый дескриптор или дескриптор для ввода/вывода с консоли.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Таким образом, у нас получился следующий TCP-клиент:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>если все хорошо, то все хорошо</p>
</li>
<li>
<p>если невозможно установить TCP соединение, сразу сообщаем об этом</p>
</li>
<li>
<p>если TCP соединение не устанавливается 5 секунд (вместо 70), прекращаем работу с ошибкой</p>
</li>
<li>
<p>если данные не приходят в ответ на запрос, ждем 2 секунды (вместо 5) и прекращаем работу.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Это уже на много лучше того, что было изначально.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
Вся сила функции <code>select</code> совсем не в том, что мы ждем всего 2 секунды. Она раскрывается при работе с множеством сокетов. Что бы для каждого сокета не выделять отдельный поток, используя <code>select</code> всю работу можно организовать в одном потоке.
</td>
</tr>
</table>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_сервер">Сервер</h2>
<div class="sectionbody">
<div class="paragraph">
<p>В архтектуре клиент-сервер под сервером понимается программа, готовая обрабатывать данные на определнном IP-адресе и порту. Поэтому, перед началом работы, сервер регистрирует в ОС IP-адрес и порт для своей работы. Например:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>веб-сервер по умолчанию использует для работы порт 80 (TCP) или 443 (TCP) для безопасного соединения.</p>
</li>
<li>
<p>почтовый сервер использует порт 25 (TCP)</p>
</li>
<li>
<p>SSH - 22 (TCP)</p>
</li>
<li>
<p>DNS - 53 (UDP)</p>
</li>
<li>
<p>и т.д.</p>
</li>
</ul>
</div>
<div class="sect2">
<h3 id="_tcp_сервер">TCP-сервер</h3>
<div class="paragraph">
<p>Отличительной особенностью реализации сервера является открытие так называемого серверного сокета. Общая идея такая:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>создаем сокет (socket)</p>
</li>
<li>
<p>регистрируем в ОС IP-адрес и порт для работы (bind)</p>
</li>
<li>
<p>переводим сокет в режим ожидания соединения от клиентов (listening)</p>
</li>
<li>
<p>при подключении нового клиента ОС создает еще один сокет для работы с подключившимся клиентом (accept). Этот сокет еще называют "клиентский сокет"</p>
</li>
<li>
<p>выполняем обычную работу с клиентским сокетом (recv, send, select, close/shutdown).</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Давайте напишем простой TCP эхо-сервер и подробно разберём его устройство. TCP эхо-сервер будет принимать подключение от клиента и отправлять в ответ все, что клиент пришлёт ему.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="python"><span style="color:#080;font-weight:bold">import</span> <span style="color:#B44;font-weight:bold">socket</span>

HOST = <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">localhost</span><span style="color:#710">'</span></span>
PORT = <span style="color:#00D">30000</span>
data_payload = <span style="color:#00D">2048</span>
backlog = <span style="color:#00D">5</span>

<span style="color:#777"># Create a TCP socket</span>
sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)

<span style="color:#777"># Enable reuse address/port</span>
sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, <span style="color:#00D">1</span>)

print(<span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">Starting up echo server on %s port %s</span><span style="color:#710">&quot;</span></span> % (HOST, PORT))
sock.bind((HOST, PORT))

<span style="color:#777"># Listen to clients, backlog argument specifies the max no. of queued connections</span>
sock.listen(backlog)

<span style="color:#080;font-weight:bold">while</span> <span style="color:#069">True</span>:
    print(<span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">Waiting to receive message from client</span><span style="color:#710">&quot;</span></span>)
    client, address = sock.accept()
    print(<span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">Client connected from %s</span><span style="color:#710">&quot;</span></span> % (address,))
    data = client.recv(data_payload)
    <span style="color:#080;font-weight:bold">if</span> data:
        print(<span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">Data: %s</span><span style="color:#710">&quot;</span></span> % data)
        s = client.send(data)
        print(<span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">sent %s bytes back</span><span style="color:#710">&quot;</span></span> % (s,))

        <span style="color:#777"># end connection</span>
    client.close()</code></pre>
</div>
</div>
<div class="paragraph">
<p>Разберем этот пример подробней.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="python"><span style="color:#080;font-weight:bold">import</span> <span style="color:#B44;font-weight:bold">socket</span>

HOST = <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">localhost</span><span style="color:#710">'</span></span>
PORT = <span style="color:#00D">30000</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Переменные HOST и PORT указывают, какой IP и порт будет слушать TCP-сервер. Как и клиент, сервер может работать только с конкретным IP адресом, поэтому, значение <code>localhost</code> в последствии превратиться в IP-адрес 127.0.0.1.</p>
</div>
<div class="paragraph">
<p>Когда сервер слушает только IP-адрес 127.0.0.1, то подключиться к нему можно только с этого же хоста. Многие современные сервера, например, PostgreSQL, можно настраивать (администрировать) подключившись через сокет. Чтобы кто-то случайно или намеренно не смог подключиться из внешней сети и начать настраивать ваш PostgreSQL сервер, по умолчанию, сервер открывает сокет для настройки на адресе 127.0.0.1. Таким образом он гарантирует, что подключиться к нему сможет только локальный пользователь.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
Другими примером является ваш домашний Wi-Fi маршрутизатор. Многие домашние Wi-Fi маршрутизаторы можно настраивать удаленно, через веб-интерфейс. В целях безопасности, подключиться к веб-интерфейсу, по умолчанию, можно только из внутренней сети. Т.е. веб-сервер слушает не 127.0.0.1, а интерфейс с IP-адресом внутренней сети. Таким образом, настраивать Wi-Fi маршрутизатор могут все, кто смог подключиться к нему через Wi-Fi.
</td>
</tr>
</table>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="python">data_payload = <span style="color:#00D">2048</span>
backlog = <span style="color:#00D">5</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Переменная <code>data_payload</code> содержит размер данных, которые мы будем читать от клиента. Если придет меньге, то хорошо, а если больше, то сервер прочитает первые 2048 байта и все. Этот TCP-эхо-сервер для примера и нет смысла читать данные большими объмами. 2048 байт будет вполне достаточно.</p>
</div>
<div class="paragraph">
<p>Переменная <code>backlog</code> указыает на размер очереди на подключение.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="python"><span style="color:#777"># Create a TCP socket</span>
sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</code></pre>
</div>
</div>
<div class="paragraph">
<p>Создаем TCP-сокет и сохраняем его в переменную sock.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="python"><span style="color:#777"># Enable reuse address/port</span>
sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, <span style="color:#00D">1</span>)</code></pre>
</div>
</div>
<div class="paragraph">
<p>Используем функцию setsockopt для возможности переиспользовать IP-адрес и порт. Что это для чего будет немного дальше. А пока просто подметим это.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="python">print(<span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">Starting up echo server on %s port %s</span><span style="color:#710">&quot;</span></span> % (HOST, PORT))
sock.bind((HOST, PORT))</code></pre>
</div>
</div>
<div class="paragraph">
<p>Функция <code>bind</code> сообщает ОС какой IP-адрес и порт будуший сервер хочет использовать для своей работы. В качестве IP-адрес можно указать и имя, например, <code>localhost</code>. Получив вместо IP-адреса имя, функция bind постарается сопоставить этому имени конкретный IP-адрес.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="python">sock.listen(backlog)</code></pre>
</div>
</div>
<div class="paragraph">
<p>Функция <code>listen</code> переведет сокет в режим ожидания соединений от клиентов. Именно этот вызов разрешает клиентам подключаться к нашему серверу. Параметр <code>backlog</code> сообщает о размере очереди на ожидания клиентов, которые могут успешно подключиться к нашему серверу и ожидать обработку.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="python"><span style="color:#080;font-weight:bold">while</span> <span style="color:#069">True</span>:
    print(<span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">Waiting to receive message from client</span><span style="color:#710">&quot;</span></span>)
    client, address = sock.accept()
    print(<span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">Client connected from %s</span><span style="color:#710">&quot;</span></span> % (address,))
    data = client.recv(data_payload)
    <span style="color:#080;font-weight:bold">if</span> data:
        print(<span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">Data: %s</span><span style="color:#710">&quot;</span></span> % data)
        s = client.send(data)
        print(<span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">sent %s bytes back</span><span style="color:#710">&quot;</span></span> % (s,))

        <span style="color:#777"># end connection</span>
    client.close()</code></pre>
</div>
</div>
<div class="paragraph">
<p>А дальше идет вечный цикл. Предполагается, что любой сервер работает вечно, поэтому, рано или поздно должен встретиться вечный цикл. В этом цикле наш TCP эхо-сервер производит основную работу.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="python">client, address = sock.accept()</code></pre>
</div>
</div>
<div class="paragraph">
<p>Ожидаем подключения нового клиента. Функция <code>accept</code> блокирующая и сервер будет находиться в ней до тех пор, пока не подключиться клиент. Как только клиент подключится, функция <code>accept</code> вернет два значения:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>сокет для работы с клиентом (клиентский сокет)</p>
</li>
<li>
<p>IP-адрес и порт клиента.</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="python">data = client.recv(data_payload)</code></pre>
</div>
</div>
<div class="paragraph">
<p>Функция <code>recv</code> ожидает данные от клиента. Как было сказано в начале, <code>recv</code> прочитает от клиента не более <code>data_payload</code> (2048) байт данных. Напомню, что функция recv блокирующая и тут мы тоже будет находиться до тех пор, пока клиент не пришлёт данные или пока сокет не будет закрыт.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="python">    <span style="color:#080;font-weight:bold">if</span> data:
        print(<span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">Data: %s</span><span style="color:#710">&quot;</span></span> % data)
        s = client.send(data)
        print(<span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">sent %s bytes back</span><span style="color:#710">&quot;</span></span> % (s,))</code></pre>
</div>
</div>
<div class="paragraph">
<p>Если от клиента пришли данные, то мы их печатаем в консоль и отправляем (<code>send</code>) эти данные ему обратно, как настоящий эхо-сервер. После отправки данных печатаем в консоль количество байт отправленных данных.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="python">    client.close()</code></pre>
</div>
</div>
<div class="paragraph">
<p>Вызываем функцию <code>close</code>, которая закроет клиентский сокет. После этого снова возвращаемся в начало нашего вечного цикла и ожидаем подключения следующего клиента.</p>
</div>
</div>
<div class="sect2">
<h3 id="_запуск_tcp_сервера">Запуск TCP-сервера</h3>
<div class="paragraph">
<p>Запустим наш TCP-сервер.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="console">(venv) ScrumBook:src ilya2$ python tcp-server-1.py
Starting up echo server on localhost port 30000
Waiting to receive message from client</code></pre>
</div>
</div>
<div class="paragraph">
<p>Если сервер запустился удачно, то мы увидим сообщение об этом. Теперь, давайте подключимся к нашему серверу из другой консоли. Для этого я использую утилиту netcat (nc).</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
Для подключения к TCP-серверу я использую команду <code>netcat</code> (nc). В Ubuntu её можно установить командой <code>apt install netcat</code>. В MacOS она устанавливается командой <code>brew install netcat</code>.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>При подключении через netcat нужно передать два параметра:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>IP-адрес или имя хоста для подключения. В нашем случае это будет localhost или можно написать 127.0.0.1.</p>
</li>
<li>
<p>Номер порта для подключения. В нашем случае это порт 30000.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Ниже результат подключения к нашему серверу через утилиту netcat.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="console">ScrumBook:~ ilya2$ nc localhost 30000
Hello TCP-server
Hello TCP-server
ScrumBook:~ ilya2$</code></pre>
</div>
</div>
<div class="paragraph">
<p>После подключения я отправил строку Hello TCP-server. Вторая строка Hello TCP-server - это уже ответ от сервера. После получения ответа от сервера соединение было закрыто. Итого, наш сервер отработал, как и задумывалось.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="console">(venv) ScrumBook:src ilya2$ python tcp-server-1.py
Starting up echo server on localhost port 30000
Waiting to receive message from client
Client connected from ('127.0.0.1', 57195)
Data: b'Hello TCP-server\n'
sent 17 bytes back
Waiting to receive message from client</code></pre>
</div>
</div>
<div class="paragraph">
<p>Если посмотрим в консоль, где запущен TCP-сервер, то обнаружим вывод нескольких дополнительных сообщений:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Client connected from ('127.0.0.1', 57195) - IP-адрес и порт клиента</p>
</li>
<li>
<p>Data: b&#8217;Hello TCP-server\n' - строку, которую прислал клиент</p>
</li>
<li>
<p>sent 17 bytes back - размер данных отправленных клиенту обратно</p>
</li>
<li>
<p>Waiting to receive message from client - ожидание следующего клиента</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Мы можем повторить подключение через <code>nc</code>, результат должен быть одинаков.</p>
</div>
<div class="paragraph">
<p>Итого, для создания сервера необходимо:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Создать сокет (socket).</p>
</li>
<li>
<p>Зарегистрировать в ОС IP-адрес и порт для работы сервера (bind).</p>
</li>
<li>
<p>Перевести сокет в состояние прослушивание (listen).</p>
</li>
<li>
<p>В вечном цикле:</p>
<div class="olist loweralpha">
<ol class="loweralpha" type="a">
<li>
<p>Ожидание подключения клиента (accept).</p>
</li>
<li>
<p>Коммуникация с клиентом (recv/send).</p>
</li>
<li>
<p>Закрытие сокета (close).</p>
</li>
</ol>
</div>
</li>
</ol>
</div>
<div class="sect3">
<h4 id="_обработка_ошибок_3">Обработка ошибок</h4>
<div class="sect4">
<h5 id="_address_already_in_use">Address already in use</h5>
<div class="paragraph">
<p>Давайте чуть подробней разберем необходимость опции SO_REUSEADDR. А для этого, давайте посмотрим, что нам покажет утилита <code>netstat</code>. Запустим наш сервер, как обычно, и посмотрим на список текущих сетевых соединений.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="console">ScrumBook:.ssh ilya2$ netstat -ant | grep 30000
tcp4       0      0  127.0.0.1.30000        *.*                    LISTEN
ScrumBook:.ssh ilya2$</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
У меня на MacOS очень много сетевых соединений, поэтому я использую команду <code>grep</code>, чтобы отфильтровать только нужные мне.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Утилита <code>netstat</code> сообщает, что порт 30000 открыт и находится в состоянии LISTEN, т.е. готов к подключению новых клиентов.</p>
</div>
<div class="paragraph">
<p>А теперь давайте подключимся к нашему серверу, отправим сообщение <code>Hello</code> и снова посмотрим на список сетевых соединений.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="console">ScrumBook:.ssh ilya2$ netstat -ant | grep 30000
tcp4       0      0  127.0.0.1.30000        *.*                    LISTEN
ScrumBook:.ssh ilya2$ nc localhost 30000
Hello
Hello
ScrumBook:.ssh ilya2$ netstat -ant | grep 30000
tcp4       0      0  127.0.0.1.30000        *.*                    LISTEN
tcp4       0      0  127.0.0.1.30000        127.0.0.1.58156        TIME_WAIT
ScrumBook:.ssh ilya2$</code></pre>
</div>
</div>
<div class="paragraph">
<p>Мы увидим, что появился еще одно соединение на порту 30000, где IP-адрес источника 127.0.0.1 и порт 58156. Это соединение находится в состоянии TIME_WAIT. Это как раз наше соединение, по которому мы передали <code>Hello</code>. Состояние TIME_WAIT - это состояние, когда соединение уже закрыто, но ОС поддерживает его еще некоторое время, чтобы корректно обработать пакеты, которые по разным причинам могли задержаться в сети. Обычно этот таймаут составляет несколько десятков секунд или даже пару минут, зависит от настроек ОС.</p>
</div>
<div class="paragraph">
<p>Выполним следующие действия:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Запустим наш сервер (или он уже запущен).</p>
</li>
<li>
<p>Подключимся утилитой <code>nc</code></p>
</li>
<li>
<p>Отправим любую строку, например, Hello.</p>
</li>
<li>
<p>Получим ответ и вместе с этим сервер закрое соединение.</p>
</li>
<li>
<p>Остановим сервер (CRTL+C).</p>
</li>
<li>
<p>И снова посмотрим на текущие соединения (netstat)</p>
</li>
</ol>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="console">ScrumBook:.ssh ilya2$ netstat -ant | grep 30000
tcp4       0      0  127.0.0.1.30000        *.*                    LISTEN
ScrumBook:.ssh ilya2$ nc localhost 30000
Hello
Hello
ScrumBook:.ssh ilya2$ netstat -ant | grep 30000
tcp4       0      0  127.0.0.1.30000        *.*                    LISTEN
tcp4       0      0  127.0.0.1.30000        127.0.0.1.58824        TIME_WAIT
ScrumBook:.ssh ilya2$ netstat -ant | grep 30000
tcp4       0      0  127.0.0.1.30000        127.0.0.1.58824        TIME_WAIT
ScrumBook:.ssh ilya2$</code></pre>
</div>
</div>
<div class="paragraph">
<p>Мы увидим, что осталось только последнее соединение в состоянии TIME_WAIT.</p>
</div>
<div class="paragraph">
<p>Закомментируйте строку с опцией SO_REUSEADDR.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="python"><span style="color:#777"># Enable reuse address/port</span>
<span style="color:#777"># sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>И попробуйте повторить все еще раз:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Запустите сервер</p>
</li>
<li>
<p>Подключитесь утилитой <code>nc</code> и отправьте любую строку</p>
</li>
<li>
<p>После ответа сервера, остановите сервер (CRTL+C).</p>
</li>
<li>
<p>Попробуйте снова запустить сервер.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>При попытке запустить сервер вы получите ошибку <code>Address already in use</code></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="console">Traceback (most recent call last):
  File &quot;tcp-server-1.py&quot;, line 15, in &lt;module&gt;
    sock.bind((HOST, PORT))
OSError: [Errno 48] Address already in use</code></pre>
</div>
</div>
<div class="paragraph">
<p>Пока есть хоть одно соединение на нашем порту (30000), мы не можем его  использовать. Это не редкое состояние. Когда вы разрабатываете сервер, то вы будете очень часто выключать и включать его снова, для проверки работоспособности. И, чтобы не ждать таймаут TIME_WAIT перед повторным запуском сервера, можно  установить флаг SO_REUSEADDR в 1. Этот флаг разрешает ОС переиспользовать сокет в состоянии TIME_WAIT.</p>
</div>
</div>
<div class="sect4">
<h5 id="_cant_assign_requested_address">Can&#8217;t assign requested address</h5>
<div class="paragraph">
<p>Сервер может слушать только назначенные IP-адреса в вашей ОС. Например, сейчас у меня на хосте назначены два IP-адреса:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>127.0.0.1 (loopback)</p>
</li>
<li>
<p>192.168.1.131 (wi-fi)</p>
</li>
</ul>
</div>
<div class="imageblock">
<div class="content">
<img src="programming/python/socket/socket-server/tcp_udp_server/images/macos-ipaddr.png" alt="IP-адреса на моём MacOS.">
</div>
<div class="title">Figure 9. IP-адреса на моём MacOS.</div>
</div>
<div class="paragraph">
<p>Это означает, что я могу запустить сервер на адресе 127.0.0.1 или на 192.168.1.131 или на обоих сразу. При попытке зарегистрировать не ваш IP-адрес вы получите ошибку <code>Can&#8217;t assign requested address</code>.</p>
</div>
<div class="paragraph">
<p>Для примера, давайте запустим наш TCP эхо-сервер на адресе 77.88.8.8. Для этого поменяем переменную HOST в нашем примере.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="python"><span style="color:#080;font-weight:bold">import</span> <span style="color:#B44;font-weight:bold">socket</span>

HOST = <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">77.88.8.8</span><span style="color:#710">'</span></span>
PORT = <span style="color:#00D">30000</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>При попытке запустить такой сервер мы получим ошибку.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="console">(venv) ScrumBook:src ilya2$ python tcp-server-3.py
Starting up echo server on 77.88.8.8 port 30000
Traceback (most recent call last):
  File &quot;tcp-server-3.py&quot;, line 15, in &lt;module&gt;
    sock.bind((HOST, PORT))
OSError: [Errno 49] Can't assign requested address</code></pre>
</div>
</div>
<div class="paragraph">
<p>Если вы хотите принимать соединения на любой из доступным вам сетевых интерфейсов, то передайте пустое поле HOST.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="python"><span style="color:#080;font-weight:bold">import</span> <span style="color:#B44;font-weight:bold">socket</span>

HOST = <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#710">'</span></span>
PORT = <span style="color:#00D">30000</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Запустив такой сервер и посмотреть netstat вы увидите примерно следующее</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="console">ScrumBook:.ssh ilya2$ netstat -ant | grep 30000
tcp4       0      0  *.30000                *.*                    LISTEN
ScrumBook:.ssh ilya2$</code></pre>
</div>
</div>
<div class="paragraph">
<p>Теперь рядом с номером порта 30000 стоит не 127.0.0.1, как было раньше, а символ *. Этот символ означает, что сервер готов принимать соединения на любой сетевой интерфейс в вашей ОС.</p>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_udp_сервер">UDP-сервер</h3>
<div class="paragraph">
<p>Давайте напишем простой UDP эхо-сервер и на примере разберем его работу.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="python"><span style="color:#080;font-weight:bold">import</span> <span style="color:#B44;font-weight:bold">socket</span>

HOST = <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#710">'</span></span>
PORT = <span style="color:#00D">30000</span>
data_payload = <span style="color:#00D">2048</span>

<span style="color:#777"># Create a TCP socket</span>
sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)

print(<span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">Starting up UDP echo server on %s port %s</span><span style="color:#710">&quot;</span></span> % (HOST, PORT))
sock.bind((HOST, PORT))

<span style="color:#080;font-weight:bold">while</span> <span style="color:#069">True</span>:
    print(<span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">Waiting to receive message from client</span><span style="color:#710">&quot;</span></span>)
    data, address = sock.recvfrom(data_payload)

    <span style="color:#080;font-weight:bold">if</span> <span style="color:#080;font-weight:bold">not</span> data:
        <span style="color:#080;font-weight:bold">continue</span>

    print(<span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">Received %s bytes from %s</span><span style="color:#710">&quot;</span></span> % (<span style="color:#369;font-weight:bold">len</span>(data), address))
    s = sock.sendto(data, address)
    print(<span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">Sent %s bytes back</span><span style="color:#710">&quot;</span></span> % (s,))</code></pre>
</div>
</div>
<div class="paragraph">
<p>Он немного меньше, чем аналогичный TCP сервер:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>нет надобности использовать опцию <code>SO_REUSEADDR</code>, так как UDP сокет не может находиться в состоянии TIME_WAIT.</p>
</li>
<li>
<p>нет надобности вызывать функцию <code>listen</code> и <code>accept</code>, так как UDP не ожидает соединений от клиентов.</p>
</li>
<li>
<p>и не нужно в конце закрывать сокет функцией <code>close</code>.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Для работы UDP сервера нужно всего 3 действия:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Создать UDP сокет (socket).</p>
</li>
<li>
<p>Зарегистрировать IP-адрес и порт для работы (bind).</p>
</li>
<li>
<p>Обрабатывать запросы клиентов (recvfrom/sendto).</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>Запустим UDP эхо-сервер и попробуем с ним поработать.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="console">(venv) ScrumBook:src ilya2$ python udp-server-1.py
Starting up UDP echo server on  port 30000
Waiting to receive message from client</code></pre>
</div>
</div>
<div class="paragraph">
<p>После запуска сервера в консоль выводится сообщение о том, что он готов к работе на порту 30000. Для взаимодейстия с сервером воспользуемся утилитой <code>netcat</code> (nc).</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
По умолчанию утилита <code>nc</code> устанавливает TCP соединение. Для отправки UDP пакетов на заданный адрес и порт, нужно установить флаг -4u. Например, <code>nc -4u localhost 30000</code>
</td>
</tr>
</table>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="console">ScrumBook:~ ilya2$ nc -4u localhost 30000
Hello, UDP server!
Hello, UDP server!</code></pre>
</div>
</div>
<div class="paragraph">
<p>Как видно, отправив сообщение "Hello, UDP server!" мы получаем его в ответ. После получения сообщения мы можем дальше продолжать взаимодействовать с сервером.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
Обратите внимание, что UDP сервер не разрывает соединение после отправки ответа, как это было в TCP сервере. Еще раз напомню - UDP протокол не поддерживает соедиений.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Так как UDP не устанавливает соединений, а работает с датаграммами, то с UDP сервером могут взаимодействовать сразу несколько клиентов. Чтобы в этом убедиться, запустите несколько (2-3) консолей и в каждой запустите команду <code>nc -4u localhost 30000</code>. После этого вы можете поочередно печатать в консолях строки и получать ответы на них.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="python">data, address = sock.recvfrom(data_payload)</code></pre>
</div>
</div>
<div class="paragraph">
<p>Функция <code>recvfrom</code> возвращает не только данные, но и IP-адрес и порт клиента. Этого как раз достаточно, чтобы отправить клиенту ответ используя функцию <code>sendto</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="python">s = sock.sendto(data, address)</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_многопоточный_tcp_сервер">Многопоточный TCP-сервер</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Однопоточный TCP-сервер хорош только для примера. В реальности, конечно, TCP-сервер всегда многопоточный и готов одновременно обслуживать несколько клиентов. Разберем несколько способов создания многопточного TCP-сервера.</p>
</div>
<div class="sect2">
<h3 id="_многопоточный_tcp_сервер_fork">Многопоточный TCP-сервер (fork)</h3>
<div class="paragraph">
<p>В основе многопоточного TCP-сервера на fork лежит вызов функции <code>fork()</code>. <code>Fork()</code> - это системный вызов в UNIX-подобных ОС (в ОС windows он эмулируется). Вызова <code>fork()</code> создает в ОС идентичиный (полная копия процесса, включая состояния регистров процессора, открытых дескрипторов, памяти и фгалов) процесс (child/ребенок), который начинает свое выполнение со следующей команды сразу после <code>fork</code>.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
Более подробно про <code>fork()</code> - <a href="https://man7.org/linux/man-pages/man2/fork.2.html" class="bare">https://man7.org/linux/man-pages/man2/fork.2.html</a>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Общая идея работы многопоточного сервера через fork() такая:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Родительский процесс работает с серверным сокетом и ожидает подключения новых клиентов</p>
</li>
<li>
<p>При подключении клиента родительский процесс создает дочерний процесс</p>
</li>
<li>
<p>Дочерний процесс занимается обслуживанием клиента, а родительский, в это время, ожидает подключения нового клиента.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Ниже представлен пример многопоточного TCP эхо-сервера с использованием fork().</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="python"><span style="color:#777">#!/usr/bin/python</span>

<span style="color:#080;font-weight:bold">import</span> <span style="color:#B44;font-weight:bold">socket</span>
<span style="color:#080;font-weight:bold">import</span> <span style="color:#B44;font-weight:bold">os</span>
<span style="color:#080;font-weight:bold">import</span> <span style="color:#B44;font-weight:bold">sys</span>
<span style="color:#080;font-weight:bold">import</span> <span style="color:#B44;font-weight:bold">signal</span>

HOST = <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">localhost</span><span style="color:#710">'</span></span>
PORT = <span style="color:#00D">30001</span>
data_payload = <span style="color:#00D">2048</span>
backlog = <span style="color:#00D">5</span>

<span style="color:#080;font-weight:bold">def</span> <span style="color:#06B;font-weight:bold">sigchld_handler</span>(*args):
    pid, exit_code = os.wait()
    <span style="color:#080;font-weight:bold">print</span> (<span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">Child pid %d exiting with code %d</span><span style="color:#710">&quot;</span></span> % (pid, exit_code//<span style="color:#00D">256</span>))

<span style="color:#080;font-weight:bold">def</span> <span style="color:#06B;font-weight:bold">client_handler</span>(client):

    <span style="color:#080;font-weight:bold">while</span> <span style="color:#069">True</span>:
        data = client.recv(data_payload)

        <span style="color:#080;font-weight:bold">if</span> <span style="color:#080;font-weight:bold">not</span> data:
            <span style="color:#080;font-weight:bold">break</span>

        print(<span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">Data: %s</span><span style="color:#710">&quot;</span></span> % data)
        s = client.send(data)
        print(<span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">sent %s bytes back</span><span style="color:#710">&quot;</span></span> % (s,))

    <span style="color:#777"># End connection</span>
    client.close()


signal.signal(signal.SIGCHLD, sigchld_handler)

<span style="color:#777"># Create a TCP socket</span>
sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)

<span style="color:#777"># Enable reuse address/port</span>
sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, <span style="color:#00D">1</span>)

print(<span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">Starting up echo server on %s port %s</span><span style="color:#710">&quot;</span></span> % (HOST, PORT))
sock.bind((HOST, PORT))

<span style="color:#777"># Listen to clients, backlog argument specifies the max no. of queued connections</span>
sock.listen(backlog)

<span style="color:#080;font-weight:bold">while</span> <span style="color:#069">True</span>:
    print(<span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">Waiting to receive message from client</span><span style="color:#710">&quot;</span></span>)
    client, address = sock.accept()
    print(<span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">Client connected from %s</span><span style="color:#710">&quot;</span></span> % (address,))

    <span style="color:#777"># Create new child</span>
    p = os.fork()

    <span style="color:#777"># We're child?</span>
    <span style="color:#080;font-weight:bold">if</span> <span style="color:#080;font-weight:bold">not</span> p:
        client_handler(client)

        <span style="color:#777"># Exit from child</span>
        <span style="color:#777"># Don't go to while True!</span>
        sys.exit(<span style="color:#00D">1</span>)</code></pre>
</div>
</div>
<div class="paragraph">
<p>Запустим этот TCP эхо-сервер и проверим, на сколько он справляется с задачей. После запуска сервера он сообщит о готовности к работе, как показано ниже.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="console">(venv) ScrumBook:src ilya2$ python tcp-server-1-fork.py
Starting up echo server on localhost port 30001
Waiting to receive message from client</code></pre>
</div>
</div>
<div class="paragraph">
<p>Поочередно запустите утилиту <code>nc localhost 30001</code> из двух консолей. И попробуйте отправлять строки из первой и из второй консоли. У меня получается это сделать без проблем и задержек. Другими словами, TCP-сервер успешно обслуживает двух клиентов. Можете запустить еще несколько консолей, он успешно справится с десятками подобных запросов.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="console">ScrumBook:~ ilya2$ nc localhost 30001
Hello TCP-server with fork
Hello TCP-server with fork</code></pre>
</div>
</div>
<div class="paragraph">
<p>А теперь давайте разберемся, как все это работает.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
Считается, что вы уже понимаете основные моменты в работе TCP-сервера и разбор примера будет касаться только многопоточной реализации.
</td>
</tr>
</table>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="python"><span style="color:#080;font-weight:bold">def</span> <span style="color:#06B;font-weight:bold">sigchld_handler</span>(*args):
    pid, exit_code = os.wait()
    <span style="color:#080;font-weight:bold">print</span> (<span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">Child pid %d exiting with code %d</span><span style="color:#710">&quot;</span></span> % (pid, exit_code//<span style="color:#00D">256</span>))</code></pre>
</div>
</div>
<div class="paragraph">
<p>Функция <code>sigchld_handler</code> - обработчик сигнала SIGCHLD. Когда наша программа вызовет функцию fork(), то в системе появится идентичный процесс. Этот новый процесс называют дочерний, а тот кто его породил - родительский. Во время завершения работы дочерний процесс сообщает родительскому свой код возврата (статус выхода). Этот код возврата будет находиться в памяти ОС до тех пор, пока родительский процесс его не прочитает. Чтобы родительский процесс понял, что один из его детей завершил свою работу, система посылает родительскому процессу сигнал CHILD (SIGCHLD).</p>
</div>
<div class="paragraph">
<p>Другими словами, при завершении дочернего процесса ОС отправляет родительскому процессу сигнал SIGCHLD и держит в памяти код возврата ребенка.</p>
</div>
<div class="paragraph">
<p>По умолчанию, у сигнала SIGCHLD стоит пустой обработчик и родительский процесс  ничего не делает при его получении. Поэтому, мы поменяем обработчик сигнала SIGCHLD на свой.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="python">signal.signal(signal.SIGCHLD, sigchld_handler)</code></pre>
</div>
</div>
<div class="paragraph">
<p>Наша функция <code>sigchld_handler</code> вызывает функцию <code>os.wait</code>, которая вернет идентификатор завершившегося дочернего процесса (pid) и его код возврата (exit_code).</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="python"><span style="color:#080;font-weight:bold">def</span> <span style="color:#06B;font-weight:bold">client_handler</span>(client):

    <span style="color:#080;font-weight:bold">while</span> <span style="color:#069">True</span>:
        data = client.recv(data_payload)

        <span style="color:#080;font-weight:bold">if</span> <span style="color:#080;font-weight:bold">not</span> data:
            <span style="color:#080;font-weight:bold">break</span>

        print(<span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">Data: %s</span><span style="color:#710">&quot;</span></span> % data)
        s = client.send(data)
        print(<span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">sent %s bytes back</span><span style="color:#710">&quot;</span></span> % (s,))

    <span style="color:#777"># End connection</span>
    client.close()</code></pre>
</div>
</div>
<div class="paragraph">
<p>Функция <code>client_handler</code> будет заниматься обработкой клиента.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="python">data = client.recv(data_payload)</code></pre>
</div>
</div>
<div class="paragraph">
<p>В ней мы в вечном цикле ожидаем данных от клиента. Если данные пришли, отправляем их клиенту обратно и снова ждем данные от клиента. Очень простой эхо-сервер.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="python">s = client.send(data)</code></pre>
</div>
</div>
<div class="paragraph">
<p>Если клиент закроет соединение, то функция <code>recv</code> вернет пустое значение, мы выйдем из вечного цикла, закроем клиентское соединение со своей стороны и выйдем из функции.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="python">    <span style="color:#777"># Create new child</span>
    p = os.fork()

    <span style="color:#777"># We're child?</span>
    <span style="color:#080;font-weight:bold">if</span> <span style="color:#080;font-weight:bold">not</span> p:
        client_handler(client)

        <span style="color:#777"># Exit from child</span>
        <span style="color:#777"># Don't go to while True!</span>
        sys.exit(<span style="color:#00D">1</span>)</code></pre>
</div>
</div>
<div class="paragraph">
<p>А это основной код родительского процесса. Функция <code>fork</code> создает дочерний процесс и начинает его выполнение со следующей команды после вызова <code>fork</code>. Чтобы понять, где-кто, функция <code>fork</code> вернет родителю идентификатор (pid) ребенка, а ребенку 0.</p>
</div>
<div class="paragraph">
<p>Поэтому, если мы родитель, то пропускаем всю работу с клиентским сокетом и возвращаемся в функцию <code>accept</code>. Если мы ребенок, то вызываем функцию для работы с клиентом <code>client_handler</code>. По её завершению завершаем и весь наш дочерний процесс (<code>sys.exit(1)</code>).</p>
</div>
<div class="paragraph">
<p>Используя функцию <code>fork</code> можно очень просто реализовать многопоточный сервер.</p>
</div>
<div class="sect3">
<h4 id="_зомби_процессы">Зомби-процессы</h4>
<div class="paragraph">
<p>Если разработчик забудет или неверно реализует обработку сигнала SIGCHLD, то это приводит к появлению в системе так называемых зомби-процессов. Зомби-процесс - это завершившийся дочерний процесс, чей код возврата еще никто не прочитал. Зомби его называют потому, что он уже закончил работу и больше ничего делать не будет (по сути мертвый), но занимает pid и числится в списке процессов.</p>
</div>
<div class="paragraph">
<p>Давайте проведем небольшой эксперимент. Закомментируем строку с регистрацией нашего обработчика сигнала SIGCHLD.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="python"><span style="color:#777">#signal.signal(signal.SIGCHLD, sigchld_handler)</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Запустим наш эхо-сервер, несколько раз подключимся к нему утилитой <code>netcat</code> и отправим 1-2 строки (не важно сколько строк, главное, подключиться и отключиться, чтобы был создан дочерний процесс).</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="console">ScrumBook:~ ilya2$ nc localhost 30001
Hello TCP-server with fork
Hello TCP-server with fork
^C
ScrumBook:~ ilya2$ nc localhost 30001
Hello
Hello
^C
ScrumBook:~ ilya2$ nc localhost 30001
Privet
Privet
^C
ScrumBook:~ ilya2$ nc localhost 30001
Hi, my name is...
Hi, my name is...
^C
ScrumBook:~ ilya2$ nc localhost 30001</code></pre>
</div>
</div>
<div class="paragraph">
<p>А теперь посмотрим на список процессов.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
Если у вас ОС Linux, то это можно сделать с помощью команды <code>ps</code> с флагами axf (<code>ps axf</code>). Под MacOS лучше установить утилиту <code>pstree</code> через <code>brew</code> (<code>brwe install pstree</code>).
</td>
</tr>
</table>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="console">|   \-+= 49798 ilya2 /System/Library/Frameworks/Python.framework/Versions/2.7/Resources/Python.app/Contents/MacOS/Python tcp-server-1-fork-zombie.py
 |     |--- 49810 ilya2 (Python)
 |     |--- 49812 ilya2 (Python)
 |     |--- 49815 ilya2 (Python)
 |     \--- 52502 ilya2 (Python)</code></pre>
</div>
</div>
<div class="paragraph">
<p>Как видно, у родительского процесса tcp-server-1-fork-zombie.py висит 4 дочерних процесса. Если посмотреть статусы этих процессов, то видно, что все дочерние процессы в состоянии Z+ (из документации по утилите ps "Marks a dead process (a 'zombie')")</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="console">49798 s000  S+     0:00.09 /System/Library/Frameworks/Python.framework/Versions/2.7/Resources/Python.app/Contents/MacOS/Python tcp-server-1-fork-zombie.py
49810 s000  Z+     0:00.00 (Python)
49812 s000  Z+     0:00.00 (Python)
49815 s000  Z+     0:00.00 (Python)
52502 s000  Z+     0:00.00 (Python)</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
Так как я запускаю все примеры на MacOS, то для просмотра статуса процесса мне приходится использовать утилиту <code>ps</code>. А для рисования древовидной структуры <code>pstree</code>. В ОС Linux утилита <code>ps</code> умеет рисовать древовидную структуру процессов и отображать их статусы сразу.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>В процессе работы такого сервера в системе будут множиться зомби процессы. Лучше этого не допускать. А для этого не забывайте про сигнал SIGCHLD.</p>
</div>
</div>
<div class="sect3">
<h4 id="_межпроцессное_взаимодейтсвие">Межпроцессное взаимодейтсвие</h4>
<div class="paragraph">
<p>Функция <code>fork</code> создает отдельный процесс. Если во время работы вам потребуется обмениваться данными между обработчиками клиентов или между дочерним и родительским процессом, то вам придется использовать что-то для межпроцессного взаимодействия (пайп, сокет, файл, БД).</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_многопоточный_tcp_сервер_threadsпотокинити">Многопоточный TCP-сервер (threads/потоки/нити)</h3>
<div class="paragraph">
<p>В основе многопоточного сервера на потоках (threads) лежит возможность запускать несколько потоков исполнения кода в рамках одного процесса. Ниже представлен наш TCP эхо-сервер на потоках.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="python"><span style="color:#777">#!/usr/bin/python</span>

<span style="color:#080;font-weight:bold">import</span> <span style="color:#B44;font-weight:bold">socket</span>
<span style="color:#080;font-weight:bold">import</span> <span style="color:#B44;font-weight:bold">threading</span>

HOST = <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">localhost</span><span style="color:#710">'</span></span>
PORT = <span style="color:#00D">30002</span>
data_payload = <span style="color:#00D">2048</span>
backlog = <span style="color:#00D">5</span>

<span style="color:#080;font-weight:bold">def</span> <span style="color:#06B;font-weight:bold">client_handler</span>(client):

    <span style="color:#080;font-weight:bold">while</span> <span style="color:#069">True</span>:
        data = client.recv(data_payload)

        <span style="color:#080;font-weight:bold">if</span> <span style="color:#080;font-weight:bold">not</span> data:
            <span style="color:#080;font-weight:bold">break</span>

        print(<span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">Data: %s</span><span style="color:#710">&quot;</span></span> % data)
        s = client.send(data)
        print(<span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">sent %s bytes back</span><span style="color:#710">&quot;</span></span> % (s,))

    <span style="color:#777"># End connection</span>
    client.close()

<span style="color:#777"># Create a TCP socket</span>
sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)

<span style="color:#777"># Enable reuse address/port</span>
sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, <span style="color:#00D">1</span>)

print(<span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">Starting up echo server on %s port %s</span><span style="color:#710">&quot;</span></span> % (HOST, PORT))
sock.bind((HOST, PORT))

<span style="color:#777"># Listen to clients, backlog argument specifies the max no. of queued connections</span>
sock.listen(backlog)

<span style="color:#080;font-weight:bold">while</span> <span style="color:#069">True</span>:
    print(<span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">Waiting to receive message from client</span><span style="color:#710">&quot;</span></span>)
    client, address = sock.accept()
    print(<span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">Client connected from %s</span><span style="color:#710">&quot;</span></span> % (address,))

    <span style="color:#777"># Create and start thread</span>
    t = threading.Thread(target=client_handler, args=(client,))
    t.start()</code></pre>
</div>
</div>
<div class="paragraph">
<p>Запустим этот TCP эхо-сервер и проверим его работоспособность. После запуска, как обычно, подключимся к нему из нескольких консоль и убедимся, что эхо-сервер способен обрабатывать несколько клиентов одновременно.</p>
</div>
<div class="paragraph">
<p>А когда вы все проверили, давайте разбираться, как все работает.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="python"><span style="color:#777">#!/usr/bin/python</span>

<span style="color:#080;font-weight:bold">import</span> <span style="color:#B44;font-weight:bold">socket</span>
<span style="color:#080;font-weight:bold">import</span> <span style="color:#B44;font-weight:bold">threading</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Для работы с потоками в Python используется модуль threading.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="python"><span style="color:#080;font-weight:bold">def</span> <span style="color:#06B;font-weight:bold">client_handler</span>(client):

    <span style="color:#080;font-weight:bold">while</span> <span style="color:#069">True</span>:
        data = client.recv(data_payload)

        <span style="color:#080;font-weight:bold">if</span> <span style="color:#080;font-weight:bold">not</span> data:
            <span style="color:#080;font-weight:bold">break</span>

        print(<span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">Data: %s</span><span style="color:#710">&quot;</span></span> % data)
        s = client.send(data)
        print(<span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">sent %s bytes back</span><span style="color:#710">&quot;</span></span> % (s,))

    <span style="color:#777"># End connection</span>
    client.close()</code></pre>
</div>
</div>
<div class="paragraph">
<p>Наша функция <code>client_handler</code> для работы с клиентом. В начале она ожидает ввод от клиента. Если данные от клиента пришли, то она отправляет их ему обратно и снова начинает ждать данные от клиента. И так по кругу. А если функция <code>recv</code> вернулась без данных, значит соединение было закрыто и можно завершать работу. Вызываем функцию <code>close</code> и выходим из обработчика потока.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="python"><span style="color:#080;font-weight:bold">while</span> <span style="color:#069">True</span>:
    print(<span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">Waiting to receive message from client</span><span style="color:#710">&quot;</span></span>)
    client, address = sock.accept()
    print(<span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">Client connected from %s</span><span style="color:#710">&quot;</span></span> % (address,))

    <span style="color:#777"># Create and start thread</span>
    t = threading.Thread(target=client_handler, args=(client,))
    t.start()</code></pre>
</div>
</div>
<div class="paragraph">
<p>Главный поток ожидает подключения нового клиента (<code>accept</code>). Когда клиент подключился, формирует новый поток и запускает его (<code>t.start()</code>).</p>
</div>
<div class="paragraph">
<p>В целом, это все!</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
При работе с потоками важно помнить про Global Interpreter Lock (GIL).
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Такая реализация чуть попроще, чем через <code>fork()</code>, так как нет нужды обрабатывать SIGCHLD.</p>
</div>
<div class="paragraph">
<p>Реализации через fork и потоки имют свои достоинства и недостатки. Например, реализация многопоточной работы на потоках позволяет использовать общую память и обмениваться данными между потоками. С другой стороны, из-за GIL все потоки реально будут исполняться поочереди.</p>
</div>
</div>
<div class="sect2">
<h3 id="_многопоточный_tcp_сервер_потоки_и_select">Многопоточный TCP-сервер (потоки и select)</h3>
<div class="paragraph">
<p>Если внимательно проанализировать реализации многопоточного TCP-сервера через потоки или вызов функции <code>fork</code>, то вы увидим, что большую часть времени обработчик клиента просто ждет данных от пользователя в функции <code>recv</code>. В таком случае, выделять отдельный поток для работы с одним клиентом очень не эффективно.</p>
</div>
<div class="paragraph">
<p>Если мы не ожидаем большого количество клиентов, то для обработки сразу нескольких клиентов нам будет достаточно двух потоков:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Один основной поток, который принимает подключения от новых клиентов</p>
</li>
<li>
<p>Второй поток для работы со всеми подключенными клиентами.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Это можно добиться совмещая работу потоков и функции <code>select</code>.</p>
</div>
<div class="paragraph">
<p>Потоки могут общаться между собой используя общую память.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_raw_socket_сыройнеструктурированный_сокет">Raw socket (сырой/неструктурированный сокет)</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Неструктурированные (raw) сокеты позволяют реализовать новые протоколы IPv4 в пространстве пользователя. Неструктурированный сокет предоставляет доступ к содержимому Ethernet фрейма. Можно самостоятельно формировать IP, TCP, UDP, ICMP и другие заголовки.</p>
</div>
<div class="paragraph">
<p>В отличие от обыкновенных сокетов, неструктурированные сокеты могут открыть только процессы с идентификатором эффективного пользователя, равным 0 (root), или имеющие мандат CAP_NET_RAW. Другими словами, открыть их может только root (Администратор) или пользователь, которому выдвли права на работу с такими сокетами.</p>
</div>
<div class="paragraph">
<p>Неструктурированные (raw) сокеты часто применяеются для реализации снифера, IDS (Intrusion Detection System/Система Обнаружения Вторжения), для отправки ICMP пакетов (ping/pong) и так далее.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_raw_socket_icmp">Raw-socket - ICMP</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Используя raw сокет напишем свою простую реализацию утилиты <code>ping</code>:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Отправить ICMP эхо-запрос на определенный IP-адрес.</p>
</li>
<li>
<p>Получить ICMP эхо-ответ.</p>
</li>
<li>
<p>Провести расчет времени между запросом и ответом.</p>
</li>
<li>
<p>Напечатать результаты.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>Программа получилась не очень маленькой, но не переживайте, сейчас мы разберемся в её работе.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="python"><span style="color:#777">#!/usr/bin/env python</span>

<span style="color:#080;font-weight:bold">import</span> <span style="color:#B44;font-weight:bold">os</span>
<span style="color:#080;font-weight:bold">import</span> <span style="color:#B44;font-weight:bold">socket</span>
<span style="color:#080;font-weight:bold">import</span> <span style="color:#B44;font-weight:bold">struct</span>
<span style="color:#080;font-weight:bold">import</span> <span style="color:#B44;font-weight:bold">select</span>
<span style="color:#080;font-weight:bold">import</span> <span style="color:#B44;font-weight:bold">sys</span>
<span style="color:#080;font-weight:bold">import</span> <span style="color:#B44;font-weight:bold">time</span>

TARGET_HOST = <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">8.8.8.8</span><span style="color:#710">&quot;</span></span>
ICMP_ECHO_REQUEST = <span style="color:#00D">8</span>
DEFAULT_TIMEOUT = <span style="color:#00D">2</span>
DEFAULT_COUNT = <span style="color:#00D">4</span>


<span style="color:#080;font-weight:bold">class</span> <span style="color:#B06;font-weight:bold">Pinger</span>(<span style="color:#369;font-weight:bold">object</span>):

    <span style="color:#080;font-weight:bold">def</span> <span style="color:#06B;font-weight:bold">__init__</span>(<span style="color:#069">self</span>, target_host, count=DEFAULT_COUNT, timeout=DEFAULT_TIMEOUT):
        <span style="color:#069">self</span>.target_host = target_host
        <span style="color:#069">self</span>.count = count
        <span style="color:#069">self</span>.timeout = timeout

    <span style="color:#080;font-weight:bold">def</span> <span style="color:#06B;font-weight:bold">do_checksum</span>(<span style="color:#069">self</span>, source_string):
        <span style="color:#D42"><span style="color:black">&quot;&quot;&quot;</span><span>  Verify the packet integritity </span><span style="color:black">&quot;&quot;&quot;</span></span>
        sum = <span style="color:#00D">0</span>
        max_count = (<span style="color:#369;font-weight:bold">len</span>(source_string) / <span style="color:#00D">2</span>) * <span style="color:#00D">2</span>
        count = <span style="color:#00D">0</span>
        <span style="color:#080;font-weight:bold">while</span> count &lt; max_count:
            <span style="color:#777"># To make this program run with Python 2.7.x:</span>
            <span style="color:#777"># val = ord(source_string[count + 1])*256 + ord(source_string[count])</span>
            <span style="color:#777"># ### uncomment the above line, and comment out the below line.</span>
            val = source_string[count + <span style="color:#00D">1</span>] * <span style="color:#00D">256</span> + source_string[count]
            <span style="color:#777"># In Python 3, indexing a bytes object returns an integer.</span>
            <span style="color:#777"># Hence, ord() is redundant.</span>

            sum = <span style="color:#369;font-weight:bold">sum</span> + val
            sum = <span style="color:#369;font-weight:bold">sum</span> &amp; <span style="color:#02b">0xffffffff</span>
            count = count + <span style="color:#00D">2</span>

        <span style="color:#080;font-weight:bold">if</span> max_count &lt; <span style="color:#369;font-weight:bold">len</span>(source_string):
            sum = <span style="color:#369;font-weight:bold">sum</span> + <span style="color:#369;font-weight:bold">ord</span>(source_string[<span style="color:#369;font-weight:bold">len</span>(source_string) - <span style="color:#00D">1</span>])
            sum = <span style="color:#369;font-weight:bold">sum</span> &amp; <span style="color:#02b">0xffffffff</span>

        sum = (<span style="color:#369;font-weight:bold">sum</span> &gt;&gt; <span style="color:#00D">16</span>) + (<span style="color:#369;font-weight:bold">sum</span> &amp; <span style="color:#02b">0xffff</span>)
        sum = <span style="color:#369;font-weight:bold">sum</span> + (<span style="color:#369;font-weight:bold">sum</span> &gt;&gt; <span style="color:#00D">16</span>)
        answer = ~<span style="color:#369;font-weight:bold">sum</span>
        answer = answer &amp; <span style="color:#02b">0xffff</span>
        answer = answer &gt;&gt; <span style="color:#00D">8</span> | (answer &lt;&lt; <span style="color:#00D">8</span> &amp; <span style="color:#02b">0xff00</span>)
        <span style="color:#080;font-weight:bold">return</span> answer

    <span style="color:#080;font-weight:bold">def</span> <span style="color:#06B;font-weight:bold">receive_pong</span>(<span style="color:#069">self</span>, sock, ID, timeout):
        <span style="color:#D42"><span style="color:black">&quot;&quot;&quot;</span><span>
</span><span>        Receive ping from the socket.</span><span>
</span><span>        </span><span style="color:black">&quot;&quot;&quot;</span></span>
        time_remaining = timeout
        <span style="color:#080;font-weight:bold">while</span> <span style="color:#069">True</span>:
            start_time = time.time()
            readable = select.select([sock], [], [], time_remaining)
            time_spent = (time.time() - start_time)
            <span style="color:#080;font-weight:bold">if</span> readable[<span style="color:#00D">0</span>] == []:  <span style="color:#777"># Timeout</span>
                <span style="color:#080;font-weight:bold">return</span>

            time_received = time.time()
            recv_packet, addr = sock.recvfrom(<span style="color:#00D">1024</span>)
            icmp_header = recv_packet[<span style="color:#00D">20</span>:<span style="color:#00D">28</span>]
            <span style="color:#369;font-weight:bold">type</span>, code, checksum, packet_ID, sequence = struct.unpack(
                <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">bbHHh</span><span style="color:#710">&quot;</span></span>, icmp_header
            )
            <span style="color:#080;font-weight:bold">if</span> packet_ID == ID:
                bytes_In_double = struct.calcsize(<span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">d</span><span style="color:#710">&quot;</span></span>)
                time_sent = struct.unpack(<span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">d</span><span style="color:#710">&quot;</span></span>, recv_packet[<span style="color:#00D">28</span>:<span style="color:#00D">28</span> + bytes_In_double])[<span style="color:#00D">0</span>]
                <span style="color:#080;font-weight:bold">return</span> time_received - time_sent

            time_remaining = time_remaining - time_spent
            <span style="color:#080;font-weight:bold">if</span> time_remaining &lt;= <span style="color:#00D">0</span>:
                <span style="color:#080;font-weight:bold">return</span>

    <span style="color:#080;font-weight:bold">def</span> <span style="color:#06B;font-weight:bold">send_ping</span>(<span style="color:#069">self</span>, sock, ID):
        <span style="color:#D42"><span style="color:black">&quot;&quot;&quot;</span><span>
</span><span>        Send ping to the target host</span><span>
</span><span>        </span><span style="color:black">&quot;&quot;&quot;</span></span>
        target_addr = socket.gethostbyname(<span style="color:#069">self</span>.target_host)

        my_checksum = <span style="color:#00D">0</span>

        <span style="color:#777"># Create a dummy heder with a 0 checksum.</span>
        header = struct.pack(<span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">bbHHh</span><span style="color:#710">&quot;</span></span>, ICMP_ECHO_REQUEST, <span style="color:#00D">0</span>, my_checksum, ID, <span style="color:#00D">1</span>)
        bytes_In_double = struct.calcsize(<span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">d</span><span style="color:#710">&quot;</span></span>)
        data = (<span style="color:#00D">192</span> - bytes_In_double) * <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">Q</span><span style="color:#710">&quot;</span></span>
        data = struct.pack(<span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">d</span><span style="color:#710">&quot;</span></span>, time.time()) + <span style="color:#369;font-weight:bold">bytes</span>(data.encode(<span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">utf-8</span><span style="color:#710">'</span></span>))

        <span style="color:#777"># Get the checksum on the data and the dummy header.</span>
        my_checksum = <span style="color:#069">self</span>.do_checksum(header + data)
        header = struct.pack(
            <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">bbHHh</span><span style="color:#710">&quot;</span></span>, ICMP_ECHO_REQUEST, <span style="color:#00D">0</span>, socket.htons(my_checksum), ID, <span style="color:#00D">1</span>
        )
        packet = header + data
        sock.sendto(packet, (target_addr, <span style="color:#00D">1</span>))

    <span style="color:#080;font-weight:bold">def</span> <span style="color:#06B;font-weight:bold">ping_once</span>(<span style="color:#069">self</span>):
        <span style="color:#D42"><span style="color:black">&quot;&quot;&quot;</span><span>
</span><span>        Returns the delay (in seconds) or none on timeout.</span><span>
</span><span>        </span><span style="color:black">&quot;&quot;&quot;</span></span>
        icmp = socket.getprotobyname(<span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">icmp</span><span style="color:#710">&quot;</span></span>)
        <span style="color:#080;font-weight:bold">try</span>:
            sock = socket.socket(socket.AF_INET, socket.SOCK_RAW, icmp)
        <span style="color:#080;font-weight:bold">except</span> socket.error <span style="color:#080;font-weight:bold">as</span> e:
            <span style="color:#080;font-weight:bold">if</span> e.errno == <span style="color:#00D">1</span>:
                <span style="color:#777"># Not superuser, so operation not permitted</span>
                <span style="color:#080;font-weight:bold">print</span> (<span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">ICMP messages can only be sent from root user processes</span><span style="color:#710">&quot;</span></span>)
                sys.exit(<span style="color:#00D">2</span>)
        <span style="color:#080;font-weight:bold">except</span> <span style="color:#C00;font-weight:bold">Exception</span> <span style="color:#080;font-weight:bold">as</span> e:
            print(<span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">Exception: %s</span><span style="color:#710">&quot;</span></span> % (e))
            sys.exit(<span style="color:#00D">3</span>)

        my_ID = os.getpid() &amp; <span style="color:#02b">0xFFFF</span>

        <span style="color:#069">self</span>.send_ping(sock, my_ID)
        delay = <span style="color:#069">self</span>.receive_pong(sock, my_ID, <span style="color:#069">self</span>.timeout)
        sock.close()
        <span style="color:#080;font-weight:bold">return</span> delay

    <span style="color:#080;font-weight:bold">def</span> <span style="color:#06B;font-weight:bold">ping</span>(<span style="color:#069">self</span>):
        <span style="color:#D42"><span style="color:black">&quot;&quot;&quot;</span><span>
</span><span>        Run the ping process</span><span>
</span><span>        </span><span style="color:black">&quot;&quot;&quot;</span></span>
        <span style="color:#080;font-weight:bold">for</span> i <span style="color:#080;font-weight:bold">in</span> <span style="color:#369;font-weight:bold">range</span>(<span style="color:#069">self</span>.count):
            print(<span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">Ping to %s...</span><span style="color:#710">&quot;</span></span> % <span style="color:#069">self</span>.target_host, )
            <span style="color:#080;font-weight:bold">try</span>:
                delay = <span style="color:#069">self</span>.ping_once()
            <span style="color:#080;font-weight:bold">except</span> socket.gaierror <span style="color:#080;font-weight:bold">as</span> e:
                print(<span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">Ping failed. (socket error: '%s')</span><span style="color:#710">&quot;</span></span> % e[<span style="color:#00D">1</span>])
                <span style="color:#080;font-weight:bold">break</span>

            <span style="color:#080;font-weight:bold">if</span> delay == <span style="color:#069">None</span>:
                print(<span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">Ping failed. (timeout within %ssec.)</span><span style="color:#710">&quot;</span></span> % <span style="color:#069">self</span>.timeout)
            <span style="color:#080;font-weight:bold">else</span>:
                delay = delay * <span style="color:#00D">1000</span>
                print(<span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">Get pong in %0.4fms</span><span style="color:#710">&quot;</span></span> % delay)


<span style="color:#080;font-weight:bold">if</span> __name__ == <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">__main__</span><span style="color:#710">'</span></span>:
    pinger = Pinger(target_host=TARGET_HOST)
    pinger.ping()</code></pre>
</div>
</div>
<div class="paragraph">
<p>Попробуйте запустить её и убедитесь, что программа отправляет 4 раза ICMP эхо-запрос и ожидает получения 4-х ICMP эхо-ответов.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="console">(venv) ScrumBook:src ilya2$ sudo python ping-1.py
Ping to 8.8.8.8...
Get pong in 50.5660ms
Ping to 8.8.8.8...
Get pong in 32.7864ms
Ping to 8.8.8.8...
Get pong in 28.7151ms
Ping to 8.8.8.8...
Get pong in 37.4961ms</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
Обратите внимание, что программа может работать только с правами суперпольозвателя (root). На MacOS я запускаю эту программу от пользователя root <code>sudo python ping-1.py</code>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Для реализации своей утилиты <code>ping</code> сделаем класс <code>class Pinger(object)</code></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="python"><span style="color:#080;font-weight:bold">class</span> <span style="color:#B06;font-weight:bold">Pinger</span>(<span style="color:#369;font-weight:bold">object</span>):

    <span style="color:#080;font-weight:bold">def</span> <span style="color:#06B;font-weight:bold">__init__</span>(<span style="color:#069">self</span>, target_host, count=DEFAULT_COUNT, timeout=DEFAULT_TIMEOUT):
        <span style="color:#069">self</span>.target_host = target_host
        <span style="color:#069">self</span>.count = count
        <span style="color:#069">self</span>.timeout = timeout</code></pre>
</div>
</div>
<div class="paragraph">
<p>В конструкторе определим переменные:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>target_host</code> - кого будет пинговать.</p>
</li>
<li>
<p><code>count</code> - сколько раз отправлять ICMP эхо-запрос.</p>
</li>
<li>
<p><code>timeout</code> - время ожидания ICMP эхо-ответа.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Метод <code>ping</code> выполняет основную работу. Он в цикле вызывает функцию <code>ping_once</code> и печатает время, за которое пришел ответ. Если ответ не пришел, функция <code>ping</code> печатает "Ping failed".</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="python">    <span style="color:#080;font-weight:bold">def</span> <span style="color:#06B;font-weight:bold">ping</span>(<span style="color:#069">self</span>):
        <span style="color:#D42"><span style="color:black">&quot;&quot;&quot;</span><span>
</span><span>        Run the ping process</span><span>
</span><span>        </span><span style="color:black">&quot;&quot;&quot;</span></span>
        <span style="color:#080;font-weight:bold">for</span> i <span style="color:#080;font-weight:bold">in</span> <span style="color:#369;font-weight:bold">range</span>(<span style="color:#069">self</span>.count):
            print(<span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">Ping to %s...</span><span style="color:#710">&quot;</span></span> % <span style="color:#069">self</span>.target_host, )
            <span style="color:#080;font-weight:bold">try</span>:
                delay = <span style="color:#069">self</span>.ping_once()
            <span style="color:#080;font-weight:bold">except</span> socket.gaierror <span style="color:#080;font-weight:bold">as</span> e:
                print(<span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">Ping failed. (socket error: '%s')</span><span style="color:#710">&quot;</span></span> % e[<span style="color:#00D">1</span>])
                <span style="color:#080;font-weight:bold">break</span>

            <span style="color:#080;font-weight:bold">if</span> delay == <span style="color:#069">None</span>:
                print(<span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">Ping failed. (timeout within %ssec.)</span><span style="color:#710">&quot;</span></span> % <span style="color:#069">self</span>.timeout)
            <span style="color:#080;font-weight:bold">else</span>:
                delay = delay * <span style="color:#00D">1000</span>
                print(<span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">Get pong in %0.4fms</span><span style="color:#710">&quot;</span></span> % delay)</code></pre>
</div>
</div>
<div class="paragraph">
<p>Самое интересное спрятано как раз внутри функции <code>ping_once</code>. Именно здесь мы создаем raw socket и работаем с ним.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="python">    <span style="color:#080;font-weight:bold">def</span> <span style="color:#06B;font-weight:bold">ping_once</span>(<span style="color:#069">self</span>):
        <span style="color:#D42"><span style="color:black">&quot;&quot;&quot;</span><span>
</span><span>        Returns the delay (in seconds) or none on timeout.</span><span>
</span><span>        </span><span style="color:black">&quot;&quot;&quot;</span></span>
        icmp = socket.getprotobyname(<span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">icmp</span><span style="color:#710">&quot;</span></span>)
        <span style="color:#080;font-weight:bold">try</span>:
            sock = socket.socket(socket.AF_INET, socket.SOCK_RAW, icmp)
        <span style="color:#080;font-weight:bold">except</span> socket.error <span style="color:#080;font-weight:bold">as</span> e:
            <span style="color:#080;font-weight:bold">if</span> e.errno == <span style="color:#00D">1</span>:
                <span style="color:#777"># Not superuser, so operation not permitted</span>
                <span style="color:#080;font-weight:bold">print</span> (<span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">ICMP messages can only be sent from root user processes</span><span style="color:#710">&quot;</span></span>)
                sys.exit(<span style="color:#00D">2</span>)
        <span style="color:#080;font-weight:bold">except</span> <span style="color:#C00;font-weight:bold">Exception</span> <span style="color:#080;font-weight:bold">as</span> e:
            print(<span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">Exception: %s</span><span style="color:#710">&quot;</span></span> % (e))
            sys.exit(<span style="color:#00D">3</span>)

        my_ID = os.getpid() &amp; <span style="color:#02b">0xFFFF</span>

        <span style="color:#069">self</span>.send_ping(sock, my_ID)
        delay = <span style="color:#069">self</span>.receive_pong(sock, my_ID, <span style="color:#069">self</span>.timeout)
        sock.close()
        <span style="color:#080;font-weight:bold">return</span> delay</code></pre>
</div>
</div>
<div class="paragraph">
<p>При создании UDP сокета, мы указываем вторым параметром SOCK_DGRAM. При создании TCP сокета - SOCK_STREAM. Чтобы открыть raw socket, необходимо при создании сокета указать SOCK_RAW.</p>
</div>
<div class="paragraph">
<p>При создании raw socket необходимо указать протокол, который мы будем использовать. В нашем случае это ICMP. В IP заголовке есть поле <a href="https://datatracker.ietf.org/doc/html/rfc791#section-3.1">Protocol</a>, оно указывает на следующий за IP заголовком протокол. Так как raw socket позволяет нам писать только данные в IP пакет, то мы должны как-то сообщить ОС, что мы собираемся самостоятельно сформировать именно ICMP пакет.</p>
</div>
<div class="paragraph">
<p>Когда ОС парсит IP заголовок, то для определения, какой протокол лежит внутри IP</p>
</div>
<div class="paragraph">
<p>Такой raw socket позволит нам самостоятельно сформировать заголовок ICMP и данные. И, чтобы IP протокол знал, ч</p>
</div>
</div>
</div>
</div>
<div id="footer">
<div id="footer-text">
Last updated 2024-10-29 13:38:45 +0300
</div>
</div>
<script>
;(function () { /*! Asciidoctor Tabs | Copyright (c) 2018-present Dan Allen | MIT License */
  'use strict'

  var config = (document.currentScript || {}).dataset || {}
  var forEach = Array.prototype.forEach

  init(document.querySelectorAll('.tabs'))

  function init (tabsBlocks) {
    if (!tabsBlocks.length) return
    forEach.call(tabsBlocks, function (tabs) {
      var syncIds = tabs.classList.contains('is-sync') ? {} : undefined
      var tablist = tabs.querySelector('.tablist ul')
      tablist.setAttribute('role', 'tablist')
      var start
      forEach.call(tablist.querySelectorAll('li'), function (tab, idx) {
        tab.tabIndex = -1
        tab.setAttribute('role', tab.classList.add('tab') || 'tab')
        var id, anchor, syncId
        if (!(id = tab.id) && (anchor = tab.querySelector('a[id]'))) {
          id = tab.id = anchor.parentNode.removeChild(anchor).id
        }
        var panel = id && tabs.querySelector('.tabpanel[aria-labelledby~="' + id + '"]')
        if (!panel) return idx ? undefined : toggleSelected(tab, true) // invalid state
        syncIds && (((syncId = tab.textContent.trim()) in syncIds) ? (syncId = undefined) : true) &&
        (syncIds[(tab.dataset.syncId = syncId)] = tab)
        idx || (syncIds && (start = { tab: tab, panel: panel })) ? toggleHidden(panel, true) : toggleSelected(tab, true)
        tab.setAttribute('aria-controls', panel.id)
        panel.setAttribute('role', 'tabpanel')
        var onClick = syncId === undefined ? activateTab : activateTabSync
        tab.addEventListener('click', onClick.bind({ tabs: tabs, tab: tab, panel: panel }))
      })
      if (!tabs.closest('.tabpanel')) {
        forEach.call(tabs.querySelectorAll('.tabpanel table.tableblock'), function (table) {
          var container = Object.assign(document.createElement('div'), { className: 'tablecontainer' })
          table.parentNode.insertBefore(container, table).appendChild(table)
        })
      }
      if (start) {
        var syncGroupId
        for (var i = 0, lst = tabs.classList, len = lst.length, className; i !== len; i++) {
          if (!(className = lst.item(i)).startsWith('data-sync-group-id=')) continue
          tabs.dataset.syncGroupId = syncGroupId = lst.remove(className) || className.slice(19).replace(/\u00a0/g, ' ')
          break
        }
        if (syncGroupId === undefined) tabs.dataset.syncGroupId = syncGroupId = Object.keys(syncIds).sort().join('|')
        var preferredSyncId = 'syncStorageKey' in config &&
          window[(config.syncStorageScope || 'local') + 'Storage'].getItem(config.syncStorageKey + '-' + syncGroupId)
        var tab = preferredSyncId && syncIds[preferredSyncId]
        tab && Object.assign(start, { tab: tab, panel: document.getElementById(tab.getAttribute('aria-controls')) })
        toggleSelected(start.tab, true) || toggleHidden(start.panel, false)
      }
    })
    onHashChange()
    toggleClassOnEach(tabsBlocks, 'is-loading', 'remove')
    window.setTimeout(toggleClassOnEach.bind(null, tabsBlocks, 'is-loaded', 'add'), 0)
    window.addEventListener('hashchange', onHashChange)
  }

  function activateTab (e) {
    var tab = this.tab
    var tabs = this.tabs || (this.tabs = tab.closest('.tabs'))
    var panel = this.panel || (this.panel = document.getElementById(tab.getAttribute('aria-controls')))
    querySelectorWithSiblings(tabs, '.tablist .tab', 'tab').forEach(function (el) {
      toggleSelected(el, el === tab)
    })
    querySelectorWithSiblings(tabs, '.tabpanel', 'tabpanel').forEach(function (el) {
      toggleHidden(el, el !== panel)
    })
    if (!this.isSync && 'syncStorageKey' in config && 'syncGroupId' in tabs.dataset) {
      var storageKey = config.syncStorageKey + '-' + tabs.dataset.syncGroupId
      window[(config.syncStorageScope || 'local') + 'Storage'].setItem(storageKey, tab.dataset.syncId)
    }
    if (!e) return
    var loc = window.location
    var hashIdx = loc.hash ? loc.href.indexOf('#') : -1
    if (~hashIdx) window.history.replaceState(null, '', loc.href.slice(0, hashIdx))
    e.preventDefault()
  }

  function activateTabSync (e) {
    activateTab.call(this, e)
    var thisTabs = this.tabs
    var thisTab = this.tab
    var initialY = thisTabs.getBoundingClientRect().y
    forEach.call(document.querySelectorAll('.tabs'), function (tabs) {
      if (tabs === thisTabs || tabs.dataset.syncGroupId !== thisTabs.dataset.syncGroupId) return
      querySelectorWithSiblings(tabs, '.tablist .tab', 'tab').forEach(function (tab) {
        if (tab.dataset.syncId === thisTab.dataset.syncId) activateTab.call({ tabs: tabs, tab: tab, isSync: true })
      })
    })
    var shiftedBy = thisTabs.getBoundingClientRect().y - initialY
    if (shiftedBy && (shiftedBy = Math.round(shiftedBy))) window.scrollBy({ top: shiftedBy, behavior: 'instant' })
  }

  function querySelectorWithSiblings (scope, selector, siblingClass) {
    var el = scope.querySelector(selector)
    if (!el) return []
    var result = [el]
    while ((el = el.nextElementSibling) && el.classList.contains(siblingClass)) result.push(el)
    return result
  }

  function toggleClassOnEach (elements, className, method) {
    forEach.call(elements, function (el) {
      el.classList[method](className)
    })
  }

  function toggleHidden (el, state) {
    el.classList[(el.hidden = state) ? 'add' : 'remove']('is-hidden')
  }

  function toggleSelected (el, state) {
    el.setAttribute('aria-selected', '' + state)
    el.classList[state ? 'add' : 'remove']('is-selected')
    el.tabIndex = state ? 0 : -1
  }

  function onHashChange () {
    var id = window.location.hash.slice(1)
    if (!id) return
    var tab = document.getElementById(~id.indexOf('%') ? decodeURIComponent(id) : id)
    if (!(tab && tab.classList.contains('tab'))) return
    'syncId' in tab.dataset ? activateTabSync.call({ tab: tab }) : activateTab.call({ tab: tab })
  }
})()
</script>
</body>
</html>